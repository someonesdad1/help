*python*
                Go to end for vim tips 
Core
    |python_pathlib|                 
    |python_re|                      
    |python_lists|
    |python_deque|
    |python_sets|
    |python_requests| Popular library for downloading web stuff
    |python_dictionaries|
    |python_descriptors|
    |python_streams|
    |python_bytes|
    |python_keywords|
    |python_collections|
    |python_subprocess|
    |python_memory_usage|
Strings
    |python_strings|
    |python_string|
    |python_string_formatting|
    |python_string_stuff|
    |python_StringIO|
    |python_strings_and_bytes|       
Functional
    |python_functions|
    |python_object_methods|
    |python_toolz|
    |python_itertools|
Numerical
    |python_decimal|                 
    |python_fractions|               
    |python_uncertainties|
    |python_random|
    |python_math|                    
    |python_cmath|                   
    |python_number_methods|          
Other
    |python_typehints|
    |python_readline|
    |python_pip|
    |python_PyPDF2|
    |python_dataclasses|
    |python_enums|
    |python_exceptions|
    |python_getopt|
    |python_idioms|
    |python_precedence|
    |python_struct|
    |python_sys|
    |python_threads|
    |python_time|
    |python_types|
Less-used stuff
    |python_bitarray|
    |python_debugger|
    |python_inspect|
    |python_logging|
    |python_optimization|
    |python_os_path|
    |python_os|
    |python_pickle|
    |python_tmp_stuff|
    |python_unittest|
    |python_wconio|
    |python_windows_printing|

----------------------------------------------------------------------
Miscellaneous stuff

Python's FAQ: https://docs.python.org/3/faq/

Open a website url
    First, make sure you use this:
        export BROWSER=cygstart
    import webbrowser
    url = "https://docs.python.org/3/faq/"
    webbrowser.open(url)

How to put a dict of variables into a function's local namespace
    di = {
        "x":44,
        "y":3.45,
    }
    def A():
        # Put di's variables into our namespace
        for i in di:
            s = f"{i} = eval('di[i]')"
            exec(s)
        del s, i
    A()

Circular imports
    Can lead to difficult-to-debug problems
    Fixes:
        - Refactor
        - Combine modules
        - Deferred import (e.g., import one item in the function that needs
          it)

* in function parameter list
    Either * by itself or * followed by a symbol name
    Example:
        def __init__(self, indent=1, width=80, depth=None, stream=None, *,
                 compact=False):
    Means that all arguments after that point are keyword arguments only.

Fast way to remove whitespace from string s
    ''.join(s.split())
    Whitespace == ' ' \t \n \r \f \v
    Use /plib/dpstr.RemoveWhitespace(s)
    Note using regexp or str.translate() are significantly slower (see
    http://www.qtrac.eu/01_nows.html)
    
Nested scopes:  how to change variables in upper scope
    print("Naive way:")
    def f():
        x = 0
        def g():
            x = 1
            print("  x inside g =", x)
        g()
        print("  x outside g =", x)
    f()
    print("Note that g() was unable to change x's value")
    print("\nUse an iterable")
    def f():
        x = [0]
        def g():
            x[0] = 1
            print("  x inside g =", x[0])
        g()
        print("  x outside g =", x[0])
    f()
    print("\nUse an attribute of f")
    def f():
        f.x = 0
        def g():
            f.x = 1
            print("  x inside g =", f.x)
        g()
        print("  x outside g =", f.x)
    f()
    print("\nUse nonlocal keyword")
    def f():
        x = 0
        def g():
            nonlocal x
            x = 1
            print("  x inside g =", x)
        g()
        print("  x outside g =", x)
    f()

A quirk in python's if syntax (learned from line 164 fractions.py)
    if type(x) is int is type(y) is type(z) <... etc.>:
        do_something

    Normally 'type(x) is int' returns a bool, but in the if
    statement it returns the type of numerator, allowing this shortcut
    syntax.

How to add methods at runtime
    https://www.oreilly.com/library/view/python-cookbook/0596001673/ch05s13.html

    class dec: pass
    def Add(name, numargs):
        if not numargs:
            f = lambda: eval(f"dec(super().{name}())")
        elif len(numargs) ==  1:
            f = lambda x: eval(f"dec(super().{name}(x))")
        elif len(numargs) ==  2:
            f = lambda x, y: eval(f"dec(super().{name}(x, y))")
        elif len(args) ==  3:
            f = lambda x, y, z: eval(f"dec(super().{name}(x, y, z))")
        else:
            raise ValueError("Too many args")
        setattr(dec, name, f)
    Note:  a problem with this method is that you can't pass in a keyword
    dictionary to the functions.  In dpdecimal.py, I had to find all the 
    Decimal functions that returned a Decimal, then add in a method for each
    of them in the dec implementation to get the infection model I was
    after.  This was 81 functions, but it wasn't too painful to implement,
    as I did most of it with the output of help(Decimal)'s function
    signatures and 10-15 minutes in the editor with copy/paste of names.

Unzipping a zip
    Given two sequences x and y
    a = zip(x, y)
        a = [[x0, y0], [x1, y1], ...]
    X, Y = zip(*a)
    X == x and Y == y

Executing a file
    exec(open("filename.py").read())

    The python 2 method was:
        execfile("somefile.py", global_vars, local_vars)

    For python 3, use
        with open("somefile.py") as f:
            code = compile(f.read(), "somefile.py", 'exec')
            exec(code, global_vars, local_vars)
    
    The compile step isn't mandatory, but it associates the file name with
    the code object, making debugging a little easier.

    Here's a python 3 substitute for execfile.
    (https://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3)
    It has the advantage of getting the locals and globals from the caller's
    environment.

    import sys
    def execfile(filename, globals=None, locals=None, use_user_env=True):
        '''Python 3 substitute for python 2's execfile.  It gets the locals
        and globals from the caller's environment unless use_user_env is
        False.
        '''
        # https://stackoverflow.com/questions/436198/what-is-an-alternative-
        #    to-execfile-in-python-3
        e = sys._getframe(1)
        if globals is None and use_user_env:
            globals = e.f_globals
        if locals is None and use_user_env:
            locals = e.f_locals
        with open(filename, "r") as fh:
            s = fh.read() + "\n"
            exec(s, globals, locals)

Getting set of n random integers between 0 and maxint - 1
    If you don't care if there are duplicates, change s from a set to a list.
    Because it uses os.urandom(), the sequence is not repeatable.
        s, numbytes = set(), maxint.bit_length()//8 + 1
        while len(s) < n:
            s.add(int.from_bytes(os.urandom(numbytes), "big") % maxint)

    If you'd rather the set be repeatable, use the random module:
        s, numbytes = set(), maxint.bit_length()//8 + 1
        random.seed(myvalue)    # Set the seed to get a repeatable sequence
        while len(s) < n:
            s.add(random.randint(0, maxint - 1))

Getters/Setters via @property
    The following is the preferred method of setting up getters and setters
    because it is concise and readable.  You can use the property()
    function instead:
        class Foo
            @property
            def name(self):
                return ...
            @name.setter
            def name(self, value):
                ...
            @name.deleter
            def name(self):
                ...
    
    The older method is:
        class Foo
            def _get_name(self):
                return ...
            def _set_name(self, value):
                ...
            def _del_name(self):
                ...
            property(_get_name, _set_name, _del_name, helpstring)

raise syntax:  raise new_exc from original_exc

    The expression following from must be an exception or None. It will be
    set as __cause__ on the raised exception. Setting __cause__ also
    implicitly sets the __suppress_context__ attribute to True, so that using
    raise new_exc from None effectively replaces the old exception with the
    new one for display purposes (e.g. converting KeyError to
    AttributeError), while leaving the old exception available in __context__
    for introspection when debugging.

    The default traceback display code shows these chained exceptions in
    addition to the traceback for the exception itself. An explicitly chained
    exception in __cause__ is always shown when present. An implicitly
    chained exception in __context__ is shown only if __cause__ is None and
    __suppress_context__ is false.

    In either case, the exception itself is always shown after any chained
    exceptions so that the final line of the traceback always shows the last
    exception that was raised.

contextlib for redirecting stdout
    Here's a pattern to avoid an annoying bug when a script redirects stdout
    and you forget to reconnect the plumbing.  This example gets the output
    of the help() command into a string:

        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            help(pow)
        s = f.getvalue()

    To send the output of help() to a file:

        with open('help.txt', 'w') as f:
            with redirect_stdout(f):
                help(pow)

    Here's how to capture both stdout and stderr:

        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            with contextlib.redirect_stderr(f):
                help(pow)
                print("Ouch!", file=sys.stderr)
        s = f.getvalue()
        print(s)

def x(a, b, /):  The slash means only a and b are allowed and they are
positional parameters.

getattr to get at attributes
    https://docs.python.org/3/faq/programming.html#how-do-i-use-strings-to-call-functions-methods
    import foo
    getattr(foo, "bar")()
        --> Calls foo.bar()

html2txt
    https://github.com/Alir3z4/html2text/blob/master/docs/usage.md
    Example:
        import html2text
        html = function_to_get_some_html()
        text = html2text.html2text(html)
        print(text)

Hex to bytes
    s = "4002 0303 4441 5332 3230 5f30 3930 3435"
    b''.fromhex(s) --> t = b'@\x02\x03\x03DAS220_09045'
    t.hex() --> "400203034441533232305f3039303435"

    Also
        from binascii import unhexlify, hexlify
        b = unhexlify(s.replace(" ", ""))
        print(b)
        print(hexlify(b))
    gives
        b'@\x02\x03\x03DAS220_09045'
        b'400203034441533232305f3039303435'
    Note hexlify produces bytes, not a string.

push() and pop() for an instance
    It is useful to store an instance's information in its attributes.
    Sometimes you'd like to be able to change the attributes, do something,
    then get back to the old attributes.  A good example is an instance that
    constructs a graphical plot and you'd like to change a line color in a
    subroutine, then get back to the original state when you're finished.
    Here's one way with a mixin:
        
        import copy 

        class PushPop:
            _stack = []
            def push(self):
                PushPop._stack.append(copy.deepcopy(vars(self)))
            def pop(self):
                if PushPop._stack:
                    old = PushPop._stack.pop()
                    vars(self).update(old)
                else:
                    raise ValueError("PushPop mixin:  Empty PushPop._stack")

        class A(PushPop):
            def __init__(self, a, b):
                self.a = a
                self.b = [1, [2, 3], 4]
            def __str__(self):
                return str(vars(self))

        a = A(1, 5)
        print(a)
        a.push()
        a.a = -34
        a.b[1][1] = 58
        print(a)
        a.pop()
        print(a)

    which prints out

        {'a': 1, 'b': [1, [2, 3], 4]}
        {'a': -34, 'b': [1, [2, 58], 4]}
        {'a': 1, 'b': [1, [2, 3], 4]}

    The deepcopy() is needed to handle sequences and classes.

Pass variables with dict and exec
    def func(d):
        # d["vars"] maps variables to values
        for v in d["vars"]:
            exec(f"{v} = d['vars']['{v}']")

Finding files
    from pathlib import Path
    # Recursive
        for filename in Path('src').rglob('*.c'):
            print(filename)
    # Not recursive
        for filename in Path('src').glob('*.c'):
            print(filename)
    Also: glob.glob(path, *, recursive=True)

Performance measurement with timeit
    Put the following function in a file a.py:
        def foo(): return "hi"
    Then execute
        python -mtimeit -s'import a' 'a.foo()'
    It will execute the loop many times and return the best of 3 
    measurements.  See the timeit module for more details and how to do 
    this from within a script.

Stdout going to tty
    It's useful to distinguish when stdout is going to a tty or not.  For
    example, in the former case, ANSI escape codes for color are OK, but not
    for the latter.  Use
        sys.stdout.isatty()

Static variables in a function
    def func():
        if "my_variable" not in dir(func):
            func.my_variable = set()
    def f():
        f.attribute += 1
        print f.attribute
    f.attribute = 7
    f()
    f()
    f()

    prints
        8
        9
        10

Useful mapping in vim
        map <s-f8> :w\|!python %<cr>
    which will run the script being edited and show you the results (hit
    return to return to vim).

Source file encoding (PEP263)
    Must be first two lines of file):
        # coding: latin-1
        # This Python file uses the following encoding: utf-8

with statements
    Factor out standard uses of try/finally.  See
    http://legacy.python.org/dev/peps/pep-0343/ for details.

    Syntax:
        with EXPR as VAR:
            BLOCK
    which means
        mgr = (EXPR)
        exit = type(mgr).__exit__  # Not calling it yet
        value = type(mgr).__enter__(mgr)
        exc = True
        try:
            try:
                VAR = value  # Only if "as VAR" is present
                BLOCK
            except:
                # The exceptional case is handled here
                exc = False
                if not exit(mgr, *sys.exc_info()):
                    raise
                # The exception is swallowed if exit() returns true
        finally:
            # The normal and non-local-goto cases are handled here
            if exc:
                exit(mgr, None, None, None)

    The lowercase variables (mgr, exit, value, exc) are internal
    variables and not accessible to the user.

  Examples
  --------
    - Ensure a lock that is acquired at the start of a block is 
      released when the block is left:
        @contextmanager
        def locked(lock):
            lock.acquire()
            try:
                yield
            finally:
                lock.release()

      Used as follows:
        with locked(myLock):
            # Code here executes with myLock held.  The lock is
            # guaranteed to be released when the block is left (even
            # if via return or by an uncaught exception). 

    - Ensure a file is closed when a block is left, even if an
      exception occurs:
        @contextmanager
        def opened(filename, mode="r"):
            f = open(filename, mode)
            try:
                yield f
            finally:
                f.close()

      Used as follows:
        with opened("/etc/passwd") as f:
            for line in f:
                print line.rstrip()

      Here's another form:
        with open(file, "r") as f:
            data = f.read()

Avoiding carriage returns in output
    Start python with the -u option under Windows to avoid the inclusion
    of carriage returns in the output.

Common error:  'the file is being used by another process'
    WindowsError: (32, 'The process cannot access the file because it is
    being used by another process'.  If no other process is using the file,
    then it can happen because your script has an open file handle to the
    file.
 
    Example:  you're making a zipfile, discover an error while processing one
    of the zipfile's files, then try to delete the zipfile.  Until you execute
    close() on the ZipFile instance, you won't be able to remove the zipfile.

How to construct zipfiles
    from zipfile import ZipFile
    z = ZipFile("aa.zip", "w")
    z.write("aa")                   # Writes the file directly
    z.write("bb", "bbxy")           # Shows how to rename
    # Organize into a different directory
    z.write("cc", "oops/cc")
    z.close()

bytearrays:  mutable sequences of bytes
    a = bytearray(10)

    Can also be initialized from a string & encoding method, or an object with
    the buffer interface, or an iterable that returns integers in the range 0
    to 0xff.  Now have an array of 10 8-bit integer values.  Can use mutable
    sequence methods such as append, del, a + a, etc.

Note:  "%r" with string interpolation uses repr() (%s uses str())

Use of underscores in identifiers:
    _x   Private name in a module when you import it.
    __x  Class-private name (is name mangled)
    Example:
        class A():
            def __init__(self):
                self.a=1
                self._a=2
                self.__a=3
        a = A()
        print a.a
        print a._a
        print a._A__a
    results in 
        1
        2
        3

maketrans and translate
  These are utilities to modify strings and bytes.

  str.maketrans(x[, y[, z]])
      Returns a translation table for use with str.translate().

      maketrans(x) uses a dictionary x that maps Unicode ordinals
      (i.e., integers) to ordinals, strings, or None.  Character keys
      are converted to ordinals.

      maketrans(x, y) must have x and y being strings of equal length.
      Corresponding characters in x are mapped to y.  

      If z is present, it must be a string whose characters are mapped
      to None.

    str.translate(table)
        Returns a copy of the string that has been mapped through the
        given table.  The table must be an object that implements
        indexing via __getitem__(), typically a mapping or sequence.
        When indexed by an integer (Unicode ordinal), the table object
        can return 1) a Unicode integer, 2) map to one or more other
        characters, 3) return None, or 4) raise a LookupError exception
        to map the character to itself.

        See the codecs module for a more flexible approach to custom
        character mappings.

    Examples:

        - Remove a set of characters from a string.  This example shows how
          to remove all ASCII characters.

            def RemASCII(s):
                if not hasattr(RemASCII, "table"):   
                    # Initialize and cache a translation table
                    r = range(0, 0x7f)
                    chars = [chr(i) for i in r]
                    none = [None]*len(chars)
                    RemASCII.table = ''.maketrans(dict(zip(chars, none)))
                # Remove ASCII characters from string s
                return s.translate(RemASCII.table)

        - Delete vowels and punctuation from a string.  This is about 20%
          faster than using re.sub().

            def remove(chars, di={}, replace=False):
                '''Returns a function that will remove the indicated
                characters from a string.  You can pass in the dictionary di,
                which will be updated to include all the characters from
                chars each call.  If replace is True, then a space character
                replaces the letters to be removed (this is useful when e.g.
                parsing text for its tokens).
         
                Example to remove vowels and punctuation:
                    d, vowels = {}, "aeiou"
                    remove(vowels, di=d)
                    remove(vowels.upper(), di=d)
                    f = remove(string.punctuation, di=d)

                The first two calls update the dictionary di.  You'd
                then use the function f() to remove vowels and punctuation
                from the argument string.

                '''
                for i in set(chars):
                    di[ord(i)] = " " if replace else None
                return lambda x: x.translate(di)

        - Implement a rot13 transformation:
            import codecs
            import sys
 
            def rot13():
                '''Returns a function that transforms a string using the
                rot13 (Caesar) substitution cipher.
                '''
                clr = "abcdefghijklmnopqrstuvwxyz"
                enc = "nopqrstuvwxyzabcdefghijklm"
                d = dict(zip(clr + clr.upper(), enc + enc.lower()))
                return lambda x: x.translate(''.maketrans(d))
            f = rot13()
            clr = sys.stdin.read()
            print("By rot13:")
            print(f(clr))
            # Show we get the same with the rot13 transformation in the
            # codecs module.
            print("\nBy codecs built-in:")
            print(codecs.encode(clr, encoding="rot13"))

Getting python version:
    print(sys.version_info)
    gives (2, 6, 5, 'final', 0)

Interpreting escaped string characters:
    Python 2:
        s = r"\xb1ab\t\nc\n"
        print(s.decode("string_escape"))
    Python 3:
        s = b"\xb1ab\t\nc\n"        # Note its a bytes object
        print(s.decode("unicode_escape"))
    Escape sequences:
        \\      Backslash
        \'      Single quote
        \"      Double quote
        \a      ASCII bell
        \b      ASCII backspace
        \f      ASCII formfeed
        \n      ASCII linefeed
        \r      ASCII carriage return
        \t      ASCII horizontal tab
        \v      ASCII vertical tab
        \ooo    Character with octal value ooo
        \xhh    Character with hex value 0xhh

        \N{name}    Character with name in Unicode database
        \uxxxx      Character with 16 bit hex value xxxx
        \uxxxxxxxx  Character with 32 bit hex value xxxxxxxx

Case-insensitive sort:
    keys = sorted(keys, key=str.lower, reverse=False)
        Sorts folded with 'A' and 'a' adjacent
    
    Sort by element of sequence of sequences:
        a = ((1, 10), (2, 8), (-4, -3))
        f = lambda x: x[1]                                                              
        print(sorted(a, key=f))
            --> [(-4, -3), (2, 8), (1, 10)]

PEP-8 recommendations:
    Use
        if x is None:
            rather than
        if x == None:

        The reason is that is causes comparison of pointers, whereas ==
        requires the objects to be compared.
    Don't use:
        if x:
            when you mean
        if x is not None:

    Instead of slicing, use:
        if mystring.beginswith("abc")
        if mystring.endswith("abc")
        This is cleaner and less error-prone

    Checking strings:  use
        if isinstance(obj, basestring):
    because the string could be Unicode.  In python 3, use
        if isinstance(obj, str):
    Also, always use
        if isinstance(obj, int):   # 2nd arg can also be a sequence
    instead of
        if type(obj) == type(1):

    Don't compare Boolean values:
        yes:  if greeting:
        no:   if greeting == True:
        no:   if greeting is True:

Use 'any' and 'all' for quick, readable tests.  any(iterable) returns
True if any element is True (returns False if iterable is empty;
all(iterable) returns True if all the items are True or if the
iterable is empty.

Always use the c:/python2x/Lib/pydoc.py script to inspect a module for
a summary of its capabilities.

How to ignore deprecation warnings with command line switch:
    -W ignore::DeprecationWarning

Use http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html
for useful info about styles and idioms.  Also see the links at the bottom.

---------------------------------------------------------------------------
Streams I/O (io module)                                    *python_streams*

io.IOBase
    - No public constructor
    - Is a context manager; file is closed after CM block finishes
    - Iterator:  use 'for line in file:'
    close()     Flush & close stream
    closed      Bool:  True if stream is closed
    fileno()    Return underlying file description (int)
    flush()     Flush write buffers if applicable
    isatty()    Bool:  return True if stream is interactive
    readable()  Bool:  True if can be read from
    readline(size=-1)   Read and return one line; at most size bytes if
                size is not -1
    readlines(hint=-1)  Read and return list of lines
    seek(offset[, whence])  Change stream position to byte offset.  whence
                is 0 = start of stream, 1 = current stream position (offset
                can be negative), 2 = end of stream, offset is usually
                negative).  Returns new absolute position.
    seekable()  Bool:  True if file is seekable
    tell()      int:  return the current stream position
    truncate(size=None)     Resize the stream (fill with null bytes if
                extended)
    writable()  Bool:  True if stream supports writing
    writelines(lines)   Write a sequence of lines (line separators not added)

io.RawIOBase(io.IOBase)
    - Base class for raw binary I/O
    read(size=-1)   Read up to size bytes or all bytes until EOF if size is
                    -1 and return them.  Only one system call if size is 
                    specified.
    readall()       Return all bytes until EOF.
    readinto(b)     Read bytes into a preallocated bytes-like object and
                    return number of bytes read.  If object is in
                    non-blocking mode and no bytes are available, None is
                    returned.
    write(b)        Write the bytes-like object b to the stream and return
                    the number of bytes written.

Reading text files:
    f = open(file)
    while f:
        line = f.readline() # Includes the single newline
        Process(line)

    f.read(size=-1)  # Read size bytes; for -1, read whole file
    f.seek(offset[, whence]) # 0:start, 1:"seek" to current position and
        offset must be 0, 2:seek to end and offset must be 0
    f.tell()  # Current stream position
    f.write(s: str) # Write and return number of bytes written

---------------------------------------------------------------------------
super([T[, object-or-type]]):  calling a method in a parent class
    super returns a proxy object that delegates method calls to a parent or
    sibling class of type T.  This is useful for accessing inherited methods
    that have been overridden in a class.

    If object-or-type is omitted, the returned super object is unbound; if
    object-or-type is an object, then isinstance(object, T) must be True.
    If object-or-type is a class, then issubclass(type2, T) must be True.

    Use cases:
        1.  Single inheritance:  refer to parent classes without naming them
            explicitly, making code more maintainable.
        2.  Support cooperative multiple inheritance.  See
            file:///p/manuals/doc/python_docs/python-3.4.1-docs-html/library/functions.html#super

    class Parent(object):
        def __init__(self, x):
            self.x = x

    class Child(Parent):
        def __init__(self, x, y):
            # Call the parent's constructor
            super(Child, self).__init__(x)

    In this case, the call could be made as
        super().__init__(x)
    and the correct method will be called.

---------------------------------------------------------------------------
Getting a class name
    type(self).__name__ returns a string (use for new classes)

How to check if an object is an iterable
----------------------------------------

    There doesn't seem to be any standard way.  Here's a thread that talks
    about some methods:

    http://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-a-variable-is-iterable

    One recommendation is to try to use it as an iterator and if it fails
    with a TypeError, it wasn't an iterator.  The short-sightedness of this
    solution is that other things can generate a TypeError.  However, it is
    likely the easiest solution in most cases.

    Other suggestions:

    Using collections (this will return True on strings, sequences, iterators)
        Python >= 2.6
        from collections import Iterable
        if isinstance(l, Iterable):
            ...

    If you _don't_ want to consider strings, then look for the __iter__ method:
        hasattr(object, string)
        if hasattr(x, "__iter__"):
            ...
        A string returns False; a sequence or iterator True.

    Note util.py has is_iterable(x, exclude_strings=False).

You can use the string method encode to change encodings.  Examples:
    s = "Hello\tthere\n"
    codecs = (
        "base64_codec",
        "bz2_codec",
        "hex_codec",
        "quopri_codec",
        "rot_13",
        "string_escape",
        "uu_codec",
        "zlib_codec",
    )
    print("Original string = '%r'" % s)
    for c in codecs:
        print(c, repr(s.encode(c)))

  produces:

    Original string = ''Hello\tthere\n''
    base64_codec 'SGVsbG8JdGhlcmUK\n'
    bz2_codec 'BZh91AY&SY\xbc\xf2\x00\xfc\x00\x00\x01E\x80\x000\x00@\x02D\x94\x00 \x00"\x01\x93\xd4 \xc9\x88{\x9c\x98\x88\xa3\xc5\xdc\x91N\x14$/<\x80?\x00'
    hex_codec '48656c6c6f0974686572650a'
    quopri_codec 'Hello=09there\n'
    rot_13 'Uryyb\tgurer\n'
    string_escape 'Hello\\tthere\\n'
    uu_codec 'begin 666 <data>\n,2&5L;&\\)=&AE<F4*\n \nend\n'
    zlib_codec 'x\x9c\xf3H\xcd\xc9\xc9\xe7,\xc9H-J\xe5\x02\x00\x1b\xfc\x04 '

Encoding:
    See http://www.python.org/dev/peps/pep-0263/
    Python defaults to ASCII encoding unless the first or second line of
    the file matches
        "coding[:=]\s*([-\w.]+)"

    Examples:
        # coding=<encoding name>
        # -*- coding: <encoding name> -*-               [emacs]
        # vim: set fileencoding=<encoding name> :       [vim]

    Typical uses with interpreter spec first line are:
        # -*- coding: latin-1 -*-
        # -*- coding: iso-8859-15 -*-
        # -*- coding: ascii -*-

    Use without interpreter line:
        # This Python file uses the following encoding: utf-8

Under python 3 and Windows, it's not unusual to see:
    UnicodeEncodeError: 'charmap' codec can't encode character '\x80' in
        position 39: character maps to <undefined>

    A fix is to set an environment variable defining the encoding to use.
    Here's one that works:

        export PYTHONIOENCODING="cp850:backslashreplace"

    The cp850 is a code page; a list of different code pages can be found
    at http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html.
    850 is a "Personal computer multilingual page".

  Under python 3 on Linux, just set PYTHONIOENCODING=utf-8 and you should be
  happy from then on.

---------------------------------------------------------------------------
Distutils
    This is one of the most confusing and poorly-documented packages in
    python.  What they don't tell you is that the MANIFEST.in file is a
    key.  You should put the files in it that you want included in your
    distribution.  There are three basic syntaxes:

    A single file (relative to the directory setup.py is in):
        include path/file another_path/file
    or a glob spec:
        include path/*.txt
    You can do a recursive include:
        recursive-include dir *

Note that a README or README.txt file will automatically get included if
it's there.

---------------------------------------------------------------------------
locals() is readonly
globals() is writable:
    globals()["z"] = 3
    print(z)
        --> gives 3
---------------------------------------------------------------------------
Here's how to inspect the running program for classes that are defined
in it:

    import inspect
    for name, obj in inspect.getmembers(sys.modules[__name__]):
        if inspect.isclass(obj):
            print(obj)

You can return the class' name with the following code:
    s = str(obj).split()[1].replace("'", "")
    print(s.split(".")[1].replace(">", ""))

---------------------------------------------------------------------------
compile/eval/exec
    eval(expression, globals=None, locals=None)
        expression is a string, globals must be a dict, locals can be any
        mapping object.  Returns the value of expression.
    exec(object[ , globals[ , locals]])
        exec executes arbitrary python code.  It is executed in the namespace
        of the caller as if the code appeared in place of the exec statement.
        If only globals is present, it must be a dictionary.  object can be
        either a string or a code object made with compile().

    compile(str, filename, kind) compiles a string to bytecode.
        kind:  "single" for a single statement
               "exec"   for a set of statements
               "eval"   for an expression
        The code object returned can be passed to eval or exec.
            c = compile(s, "", "exec")
            exec(c)
            ...
            c = compile(s, "", "eval")
            a = eval(c)

    Python 2 trick
    --------------
    Here's a handy use of exec.  Suppose you want to have the same local
    variable namespace in the function you call as the one you're calling
    from.  Execute code like the following to give the function a the same
    namespace as b:
            def a(d):
                for k in d:
                    exec "%s = d['%s']" % (k, k)
                print("x =", x)
                print("y =", y)
            def b():
                x=4
                y=88
                a(locals())
            b()
        You'll get the results
            x = 4
            y = 88
        as you'd expect.  Note this is calling by value, as you can't make
        changes to the locals and expect them to update the calling
        function's locals (it could be done by passing the locals() of a()
        back to b() and having b do the same exec loop.  But then b's local
        namespace would be contaminated by the locals in a that you defined
        normally.  The way around this would be to define all of a's locals
        first and keep a copy of the locals() dict at that point.  Then
        before you return, clean the locals() dict you'll pass back to b of
        the names in the saved dict.  Another way is to name the
        local variables that aren't wanted to be returned with leading
        double underscores; then remove them before returning the
        dictionary.

    Here's another tidbit:  you can get some or all of a library's
    namespace into the local namespace:
        import math
        def f():
            for i in [i for i in math.__dict__ if i[0] != "_"]:
                exec("from math import %s" % i)
            # Print out locals
            print("Locals:")
            for i in locals():
                print(" ", i)

Putting commas in numbers:
    import locale
    locale.setlocale(locale.LC_ALL, "")
    locale.format("%d", num, grouping=True)

    The following code shows more detail
        n = 8375937937493
        print("Number =", n)
        print("format() with no locale set =", format(n, "n"))
        orig = locale.getlocale()
        print("Original locale =", orig)
        locale.setlocale(locale.LC_ALL, '')
        default_locale = locale.getlocale()
        print("Default locale =", default_locale)
        locale.setlocale(locale.LC_ALL, default_locale)
        print("Number with default locale set =", format(n, "n"))
        locale.setlocale(locale.LC_ALL, orig)
        print("Reset back to original locale =", format(n, "n"))
    which prints
        Number = 8375937937493
        format() with no locale set = 8375937937493
        Original locale = (None, None)
        Default locale = ('English_United States', '1252')
        Number with default locale set = 8,375,937,937,493
        Reset back to original locale = 8375937937493

Using csv files:
    import csv
    from out import out

    s = '''
    "f1","f1","f3"
    "first","second","third"
    "1","2","3"
    '''[1:-1]
    f = "a.csv"
    open(f, "wb").write(s)
    c = csv.reader(open(f))
    for i in c:
        out(i)

    Also look up the cvskit on the web -- it has some very helpful tools for
    getting a picture of a big CSV file, its data ranges, and extracting
    subsets.

It is pythonic to keep data in sequences and operate on them with map,
  filter, and list comprehensions.  

    filter(predicate, iterable)
        Returns an iterator for those items in iterable that the function
        predicate returns True.

        filter(function, iterable) is equivalent to
            (item for item in iterable if item) if function == None
            (item for item in iterable if function(item)) otherwise

    itertools.filterfalse(predicate, iterable)
        Same as filter but where predicate returns False.

    map(function, iterable, ...)
        Returns an iterator that applies function to each item in the
        iterator.  If more than one iterator is provided, then each of
        these is an independent parameter of function; the iterables are
        used in parallel and stop when the smallest iterature is exhausted.

    itertools.starmap(function, iterable)
        function has n parameters and iterable is a sequence of n-tuples,
        meaning the arguments have been "pre-zipped".

  Example:  The following is a common pattern:

    selected = []
    fp = open(filename)
    for line in fp.readlines():
        if predicate(line):
            selected.append(line)
    del line

  This can be done faster and better (and you grok it as one line) as

    selected = filter(predicate, open(filename))

  as filter returns those items for which predicate is True.

  Slightly more pythonic is

    filter(predicate, file(filename))

  Construct predicates as needed and use filter & itertools.filterfalse

    def KeepThese(x):
        if x meets condition:
            return True
        return False
    from itertools import filterfalse
    # Keep the items in mylist
    mylist = filter(KeepThese, mylist)
    # Get rid of the relevant items in mylist
    mylist = filterfalse(KeepThese, mylist)

If you need speed, consider the following recommendations from Guido
http://www.python.org/doc/essays/list2str.html

    * Rule number one: only optimize when there is a proven speed
      bottleneck. Only optimize the innermost loop.
    * Small is beautiful. Given Python's hefty charges for bytecode
      instructions and variable look-up, it rarely pays off to add extra
      tests to save a little bit of work.
    * Use intrinsic operations. An implied loop in map() is faster than an
      explicit for loop; a while loop with an explicit loop counter is even
      slower.
    * Avoid calling functions written in Python in your inner loop. This
      includes lambdas. In-lining the inner loop can save a lot of time.
    * Local variables are faster than globals; if you use a global constant
      in a loop, copy it to a local variable before the loop. And in
      Python, function names (global or built-in) are also global
      constants!
    * Try to use map(), filter() or reduce() to replace an explicit for
      loop, but only if you can use a built-in function: map with a
      built-in function beats a for loop, but a for loop with in-line code
      beats map with a lambda function!
    * Check your algorithms for quadratic behavior. But notice that a more
      complex algorithm only pays off for large N - for small N, the
      complexity doesn't pay off. In our case, 256 turned out to be small
      enough that the simpler version was still a tad faster. Your mileage
      may vary - this is worth investigating.
    * And last but not least: collect data. Python's excellent profile
      module can quickly show the bottleneck in your code. if you're
      considering different versions of an algorithm, test it in a tight
      loop using the time.clock() function.

You can iterate on files; each item is a line from the file (this works only
in python 2):
    for i in file("filename"):
        print(i)
  For python 2 and 3, use
    for i in open("filename"):
        print(i)

__mro__ attribute: 

    'method resolution order' tuple defining the order superclasses
    are searched for name resolution.  Only works for new-style
    classes.  Example:
        class A(object): pass
        class B(A): pass
        print(B.__mro__)
    prints
        (<class '__main__.B'>, <class '__main__.A'>, <type 'object'>)

To atomically execute some code:
http://code.activestate.com/recipes/475125-atomically-execute-a-block-of-python-statements/
    try:
        sys.setcheckinterval(sys.maxint)
        # Statements in this block are
        # assured to run atomically
    finally:
        sys.setcheckinterval(100)

Readability is good.  Unpack things to help document structure, such as:
        for address, name in user_data:
            Do stuff with it
    This is better than e.g.
        for item in user_data:
            Do stuff with item[0] and item[1]...

Combinations/permutations
    itertools.combinations('ABCD', 2) --> AB AC AD BC BD CD
    itertools.permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC

Read the unit tests in Lib/test!  There are lots of test cases and you
    can see how things are supposed to work.  There are over 400 python
    files there and over 130,000 lines of stuff.  For example, here's a
    line from test_functools.py for functools.partial:
        functools.partial(map, lambda x: x*10)
    It returns a function that will multiply the elements of any sequence
    by 10.

Function attributes
    Note:  these have been renamed in python 3.

    my_function.func_name
    my_function.func_doc
    my_function.func_defaults
    my_function.func_dict
    my_function.func_closure
    my_function.func_globals
    my_function.func_code

Avoid string concatenations!
    IMPORTANT:  if you want to concatenate a bunch of strings, use the
    string join method over '+'; join is O(N) and '+' is O(N^2).

        ''.join(my_list)
        ''.join(func(i) for i in mylist)  (Generator expression)

    rather than
        for s in strings:
            result += s

If you're getting weird behavior on an import, you might have an improperly
named file somewhere; check it by
    import xxxx
    print(xxxx.__file__)

How to dump locals:
    from pprint import pprint
    pprint(locals())

An object's instance attributes are in self.__dict__.  Thus, you can do
things like:
    print("There were %(error_count)d errors" % self.__dict__)

Things about integers
    int(a, base) can convert strings from a specified base
        int("1001", 2) == 9
        int("20", 36)  == 72
        int("g", 36)   == 16
    bin(5) is '0b101'
    oct(5) is '0o5'
    hex(5) is '0x5'

Use enumerate for better readability:
        a = ["a", "b", "c"]
        for i, item in enumerate(a):
            print(i, item)
    instead of
        for i in range(len(a)):
            print(i, a[i])

    Number lines of a file:
        with open(filename) as f:
            for linenumber, line in enumerate(f, start=1):
                do stuff...

fileinput module
    Loops over sys.argv[1:] files or stdin:
        for line in fileinput.input():
            process(line)
    Pass alternate list of filenames to input()

    Comment:  I don't like this use, even though the module is also available
    in python 3; the reason is that the programmer needs to know this special
    iteration over the command line's arguments.  It's better to be explicit:

        for file in sys.argv[1:]:
            for line in open(file):
                process(line)

    which clearly shows what's going on.

iter() can take a callable argument and sentinel:
    def seek_next_line(f):
        for c in iter(lambda: f.read(1),'\n'):
            pass
  This reads 1 byte from the file at a time until the sentinel value of
  linefeed is reached, at which point the iteration stops.

    Iterators can also remember state:
        a = range(10)
        L = iter(a)
        for i in L:
            if i > 4:
                break
            print(i)
        print("Picking up where we left off:")
        for i in L:
            print(i)

Named tuples
    Use named tuples for more readable code.  They are lightweight and
    use no more memory than regular tuples.  Example:

        from collections import namedtuple  # Datatype factory function
        Point = namedtuple('Point', 'x y')  # Defines field names and returns a
                new type named 'Point'.
        p = Point(11, y=22)  # Use position or kw access
        print(p)
    produces the more readable:
        Point(x=11, y=22)

    They are useful for e.g. dealing with CSV data:
        EmployeeRecord = namedtuple('EmployeeRecord',
            'name, age, title, department, paygrade')  # Commas are optional
        import csv
        for emp in map(EmployeeRecord._make,
                       csv.reader(open("employees.csv", "rb"))):
            print(emp.name, emp.title)

Simple command interpreter:
    from cmd import Cmd

    class MyCmd(Cmd):
        count = 0
        def do_help(self, x):
            if   x == "f": self.help_f()
            elif x == "q": self.help_q()
            elif x == "abc": self.help_abc()
            else:
                print('''Supported commands:
      abc Demonstrates a simple command and its argument
      f   Demonstrates another command and its argument
      q   Quits''')
        def update_count(self):
            MyCmd.count += 1
            self.prompt = "<%d> " % MyCmd.count
        def do_f(self, x):
            print("Got an f command; argument =", x)
            self.update_count()
        def do_q(self, x):
            print("Quitting...")
            exit(0)
        def do_abc(self, x):
            print("Got an abc command; argument =", x)
            self.update_count()
        def help_f(self):
            print("Shows an example command")
        def help_q(self):
            print("Quits the program")
        def help_abc(self):
            print("Another example command")
    c = MyCmd()
    c.prompt = "<0> "
    c.cmdloop("Hi, start typing commands")

Enumerated constants:
    class Status:
        open, pending, closed = range(3)
    Then access as e.g. Status.open.

Tracing a file's execution:
    python -m trace --count myfile.py
        will execute myfile.py and count the number of times a line was
        executed.
    Example:
        a.py:
            import sys
            def f():
                print(sys.argv)
            for i in range(4):
                f()
    'python -m trace --count a.py' results in a file a.cover:
        1: import sys
        1: def f():
        4:     print(sys.argv)
        5: for i in range(4):
        4:     f()
    Another use is 'python -m trace -t a.py':  this will print a trace of
    the lines that are executed.

    You can also use the module to trace execution of a function.
    See more details in trace module.

Array indexing:
    a = [1,2,3,4,5,6,7,8]
    Change default stride:
        a[::2] --> [1, 3, 5, 7]
    Begin at different spot:
        a[1::2] --> [2, 4, 6, 8]
    Reverse order:
        a[::-1] --> [8, 7, 6, 5, 4, 3, 2, 1]
        This is the fastest way to reverse a string, about 8 times
        faster than ''.join(reversed(s))

Use the ctypes module to call into a DLL.

List Comprehensions:
    [[x, x**3] for x in range(10) if x % 2 == 0]
    [(x, y) for x in range(4) for y in range(5)]
    [(x, y) for x in range(4) if x > 0 for y in range(5) if y < 4]

map, filter, reduce:
    Use these where you can, as they take place completely in C code and
    are thus fast.  map applies a function to a sequence; filter returns
    only those elements where the predicate is true.  These will in general
    be faster than list comprehensions, but perhaps not as readable.

    Examples:
        Convert a list to strings:
            newlst = map(str, lst)
        Only keep numbers > 4:
            newlst = filter(lambda x: x > 4, lst)
        Use functions with more arguments:
            def f(x, y, z):
                return x + y + z
            newlst = map(f, a1, a2, a3)
        Use list comprehensions or generators if there are conditions attached.

    reduce takes two elements at a time, combines them, then grabs the next
    element, combines the result and new elements, etc.  Here's an example
    that efficiently calculates the factorial of an integer n:
        reduce(operator.mul, range(2, n+1))

Operators for functional programming
    The operators module has some nice tools for quickly getting at various
    things as function calls:
        attrgetter(attr1[, attr2, ...])
            Returns a callable that fetches attr1 from its operand.
            After f = attrgetter('name', 'date'), the call f(b) returns
            (b.name, b.date).
        itemgetter(item1[, item2, ...])
            Returns the indicated item; item can be numbers, dict key, etc.
            itemgetter(1,3,5)('ABCDEFG') --> ('B', 'D', 'F')
        methodcaller(name1[, args, ...])
            After f = methodcaller('name', 'foo', bar=1), the call f(b)
            returns b.name('foo', bar=1).

Generators:  create iterators (Note:  generators maintain state)
    def reverse(data):
        for index in range(len(data) - 1, -1, -1):
            yield data[index]   # This special keyword creates the iterator

    for char in reverse("golf"):
        print(char, end="")

    f l o g

    Generator expressions can also be used:
        Sum of squares:
            sum(i*i for i in range(10))

        Dot product:
            xvec = [10, 20, 30]
            yvec = [7, 5, 3]
            sum(x*y for x,y in zip(xvec, yvec))

        valedictorian = max((student.gpa, student.name) for
                            student in graduates)

        Quickly create a lookup table:
            from math import pi, sin
            sine_table = dict((x, sin(x*pi/180)) for x in range(0, 91))

    For speed and memory use, the following is preferred:
        for i in (i for i in collection if f(i)):
            Process(i)
    instead of using a list comprehension.

  IMPORTANT:
  ----------
    Generators are lazy, unlike list comprehensions:
        total = sum([i*i for i in number_list])
    vs.
        total = sum(i*i for i in number_list)

    The list comprehension creates the whole list in memory, while the
    generator just creates one item at a time (which gets fed to the sum()
    function).

    You can pass in a value to a generator by calling its send() method.
    Here's an example from http://docs.python.org/dev/howto/functional.html:

    We define a counter that increments by 1 and allows changing the
    counter's value:

        def counter(maximum):
            i = 0
            while i < maximum:
                val = (yield i)
                # If value provided, change counter
                if val is not None:
                    i = val
                else:
                    i += 1

    Here's how it works:
        >>> it = counter(10)
        >>> next(it)
        0
        >>> next(it)
        1
        >>> it.send(8)
        8
        >>> next(it)
        9
        >>> next(it)
        Traceback (most recent call last):
          File "t.py", line 15, in ?
            it.next()
        StopIteration

    Note you have to put parentheses around the 'yield i' if there's a
    following term; the recommendation is to always include the parentheses
    as it will be a clue to the programmer that there's a special behavior
    going on.  Always check for the None case.

*.pth files:
    You can add a *.pth file to a directory already in PYTHONPATH and it
    will add to sys.path, one line for each directory.

Function factories
    Use function factories when you need to use map and filter a lot.
    Example:
        def multiply_by_attr(attrname, multiplier):
            '''Return function that multiplies atttribute "attrname" by
            multiplier.'''
            def multiplier(x):
                return getattr(x, attrname) * multiplier
            return multiplier
        triple    = multiply_by_attr('Count', 3)
        quadruple = multiply_by_attr('Count', 4)
        halve_sum = multiply_by_attr('Sum', 0.5)

Closures

    A closure is a function that is bound with its free variables; the
    variables' lifetimes are as long as the function's lifetime.  Here's an
    example from
    https://realpython.com/inner-functions-what-are-they-good-for/#retaining-state-with-inner-functions-closures

        def generate_power(exponent):
            def power(base):
                return base**exponent
            return power

    When you call generate_power, it's argument is bound to the function
    power, creating a closure.  Example:  generate_power(2) returns a
    function power(x), which will compute x**2 when you call it with an
    argument.  Python had to "remember" the value of exponent with the 
    returned function power.

    Since functions are first-class objects, any state you want to add
    can be stuck in as an attribute.  Even the caller can add state if
    desired; this can be used to change behavior dynamically.  Here's another
    way the above functionality can be gotten:

        def generate_power(exponent):
            def power(base):
                power.exponent = exponent
                return base**power.exponent
            return power

For mutable objects, x += y and x = x + y may not be the same; example:
    >>> z = [1, 2, 3]
    >>> id(z)
    11050240
    >>> z += [4]
    >>> id(z)
    11050240
    >>> z = z + [5]
    >>> id(z)
    11035832

Using 'any' and 'all':
    numbers = [1, 10, 100, 1000, 10000]
    if any(number < 10 for number in numbers):
        print('Success')
    # Outputs: 'Success!'

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    if all(number < 10 for number in numbers):
        print('Success!')
    # Outputs: 'Success!'

else statement
--------------
    Use as needed after for and while loops.  The else clause will be
    executed unless the loop executed a break, return, or had an
    exception.

        a = True
        while a:
            print("Hi")
            a = False
        else:
            print("oops")

    prints

        Hi
        oops

    Another example is as follows:

        for item in sequence:
            if condition(item):
                break
        else:
            raise Exception("Condition not satisfied")

  Note that try/except blocks also have an else statement:
        try:
            a = 5
            <variable b set elsewhere>
            c = 1/b
            print("Did all settings OK")
        except ZeroDivisionError:
            print("Caught division by zero")
        else:
            print("This is else")
        finally:
            print("This is finally")

    This prints

        Caught division by zero
        This is finally

    when b = 0 and

        Did all settings OK
        This is else
        This is finally

    when b != 0.

Conditional syntax
    result = "Result1" if x < 0 else "Result2"

Simulating a C static variable
    def func(item, stuff=[])
        stuff.append(item)
        print(stuff)

    func(1)
    # prints [1]

    func(2)
    # prints [1, 2]

    The reason is that the default value for a function argument is only
    evaluated once, when the function is defined.  Thus, the value persists
    across function calls.

    To avoid this behavior, don't use mutable objects as default values.

Passing a list or dictionary as arguments
    args = [1, 2]
    math.pow(*args)  # *args converts the list to positional parameters
    # returns math.pow(1, 2)

    kwargs = {"a" : True, "b" : False}
    do_something(**kwargs)  # Passes in dictionary as keyword arguments

Function decorators
    A decorator is a function that wraps another function: the main
    function is called and its return value is passed to the decorator. The
    decorator then returns a function that replaces the wrapped function as
    far as the rest of the program is concerned.

    def decorator1(func):
        return lambda: func() + 1

    def decorator2(func):
        def print_func():
            print(func())
        return print_func

    @decorator2
    @decorator1
    def function():
        return 41

    function()
    # prints '42'

    'function' is passed to 'decorator1'. 'decorator1' returns a function
    that calls 'function' and adds 1. This function is then passed to
    'decorator2', which returns a function that calls the function returned
    by 'decorator1' and prints the result. This last function is the
    function you are actually calling when you call 'function'.

Emulating a switch statement

    def key_1_pressed():
        print('Key 1 Pressed')
    def key_2_pressed():
        print('Key 2 Pressed')
    def key_3_pressed():
        print('Key 3 Pressed')
    def unknown_key_pressed():
        print('Unknown Key Pressed')

    The typical idiom is a bunch of elifs (but a bunch of these can raise the
    McCabe complexity count even though they're easy to read and understand):
        keycode = 2
        if keycode == 1:
           key_1_pressed()
        elif keycode == 2:
           key_2_pressed()
        elif number == 3:
           key_3_pressed()
        else:
           unknown_key_pressed()
        # prints 'Key 2 Pressed'

    Here's a better way with a dictionary, but it's harder to read:
        keycode = 2
        functions = {1: key_1_pressed, 2: key_2_pressed, 3: key_3_pressed}
        functions.get(keycode, unknown_key_pressed)()

    This would be useful with lots of elifs.

Dynamic classes (see http://www.devx.com/opensource/Article/31482/0/page/2)
    def init_method(self, x, y):
          self.x = x
          self.y = y
    def dumpSum_method(self):
          print(self.x + self.y)
    D = type('DynamicClass', (object,),
             {'__init__':init_method, 'dumpSum':dumpSum_method})
    d = D(3, 4)
    d.dumpSum()

atexit
    from atexit import register
    # Register cleanup functions.
    register( func[, *args[, **kargs]])
        args and kargs are passed to stated function.
    Executed in LIFO order
    Always called unless os._exit is called (note it doesn't e.g.
    flush stdio buffers).

---------------------------------------------------------------------------
@staticmethod and @classmethod

See
https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods

@staticmethod is a decorator used to declare a function in a class
that is not bound to any instance of the class -- thus, it's a plain
function.  However, the semantics let you override the definition in a
subclass if you choose.  

    --> Use a static method when the method doesn't utilize the state 
        of an object.

@classmethod is a decorator used to declare a function in a class
that is bound to a class.  Thus, the first argument of the function
must be a class name.

Here's a distinction between bound and unbound methods; the code
    class A:
        def x(self): pass
    print(A.x)
    a = A()
    print(a.x)
produces
    <unbound method A.x>
    <bound method A.x of <__main__.A instance at 0x00C4D8A0>>
The unbound message means it's a function that is not attached to any
instance; contrast to the second message where it is.  Trying to call
A.x() results in the message
    TypeError: unbound method x() must be called with A instance as
    first argument (got nothing instead)
Python 2 requires the method's first argument to be an instance of
that same class.  Thus, in the above code we could successfully call
A.x(a) and not get an exception.  In python 3, it can be bound to any
object.

When to use @classmethod (earlier examples at the web page gave Pizza
class examples):

- Factory methods, that are used to create an instance for a class
  using for example some sort of pre-processing. If we use a
  @staticmethod instead, we would have to hardcode the Pizza class
  name in our function, making any class inheriting from Pizza unable
  to use our factory for its own use.

    class Pizza(object):
        def __init__(self, ingredients):
            self.ingredients = ingredients
 
        @classmethod
        def from_fridge(cls, fridge):
            return cls(fridge.get_cheese() + fridge.get_vegetables())

- Static methods calling static methods: if you split a static methods
  in several static methods, you shouldn't hard-code the class name
  but use class methods.  Using this way to declare ou method, the
  Pizza name is never directly referenced and inheritance and method
  overriding will work flawlessly:

    class Pizza(object):
        def __init__(self, radius, height):
            self.radius = radius
            self.height = height
 
        @staticmethod
        def compute_circumference(radius):
             return math.pi * (radius ** 2)
 
        @classmethod
        def compute_volume(cls, height, radius):
             return height * cls.compute_circumference(radius)
 
        def get_volume(self):
            return self.compute_volume(self.height, self.radius)

---------------------------------------------------------------------------
Python interpreter command line options:

usage: c:\python26\python.exe [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-B     : don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x
-c cmd : program passed in as string (terminates option list)
-d     : debug output from parser; also PYTHONDEBUG=x
-E     : ignore PYTHON* environment variables (such as PYTHONPATH)
-h     : print this help message and exit (also --help)
-i     : inspect interactively after running script; forces a prompt even
         if stdin does not appear to be a terminal; also PYTHONINSPECT=x
-m mod : run library module as a script (terminates option list)
-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x
-OO    : remove doc-strings in addition to the -O optimizations
-Q arg : division options: -Qold (default), -Qwarn, -Qwarnall, -Qnew
-s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE
-S     : don't imply 'import site' on initialization
-t     : issue warnings about inconsistent tab usage (-tt: issue errors)
-u     : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x
         see man page for details on internal buffering relating to '-u'
-v     : verbose (trace import statements); also PYTHONVERBOSE=x
         can be supplied multiple times to increase verbosity
-V     : print the Python version number and exit (also --version)
-W arg : warning control; arg is action:message:category:module:lineno
-x     : skip first line of source, allowing use of non-Unix forms of #!cmd
-3     : warn about Python 3.x incompatibilities that 2to3 cannot trivially fix
file   : program read from script file
-      : program read from stdin (default; interactive mode if a tty)
arg ...: arguments passed to program in sys.argv[1:]

Other environment variables:
PYTHONSTARTUP: file executed on interactive startup (no default)
PYTHONPATH   : ';'-separated list of directories prefixed to the
               default module search path.  The result is sys.path.
PYTHONHOME   : alternate <prefix> directory (or <prefix>;<exec_prefix>).
               The default module search path uses <prefix>\lib.
PYTHONCASEOK : ignore case in 'import' statements (Windows).
PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr.

----------------------------------------------------------------------
Keywords and built-in functions                  *python_keywords* 

    import keyword
    keyword.iskeyword(s)    Returns True if s is a keyword
    keyword.kwlist          Sequence of keywords

Keywords
    False      await      else       import     pass
    None       break      except     in         raise
    True       class      finally    is         return
    and        continue   for        lambda     try
    as         def        from       nonlocal   while
    assert     del        global     not        with
    async      elif       if         or         yield

Built-in functions
    __import__()   complex()      hasattr()      max()          round()
    abs()          delattr()      hash()         memoryview()   set()
    all()          dict()         help()         min()          setattr()
    any()          dir()          hex()          next()         slice()
    ascii()        divmod()       id()           object()       sorted()
    bin()          enumerate()    input()        oct()          staticmethod()
    bool()         eval()         int()          open()         str()
    breakpoint()   exec()         isinstance()   ord()          sum()
    bytearray()    filter()       issubclass()   pow()          super()
    bytes()        float()        iter()         print()        tuple()
    callable()     format()       len()          property()     type()
    chr()          frozenset()    list()         range()        vars()
    classmethod()  getattr()      locals()       repr()         zip()
    compile()      globals()      map()          reversed()

----------------------------------------------------------------------
Bytes and bytearrays                               *python_bytes*

bytes       = Immutable sequences of single bytes.
bytearrays  = Mutable sequences of single bytes.

Init
    b"one two", b'one two'
    b'''one two''', b"""one two""", 
    rb"one two" :  r disables processing of escape sequences
    bytes(10)   Zero-filled of length 10
    bytes(range(20))
    bytes(obj)  obj must support buffer protocol

    Only ASCII characters allowed.  Any value over 0x7f must be escaped.

Important!
    b[0] returns an integer
    b[0:1] returns a bytes object of length 1

str(bytes_obj) returns b"..." form.  Use list(bytes_obj) to get list
of integers.

Methods (see string methods)
    capitalize()
    casefold()
    center(width[, fillchar])
    count(sub[, start[, end]])
    decode(encoding="utf-8", errors="strict")
    endswith(suffix[, start[, end]])
    expandtabs(tabsize=8)
    find(sub[, start[, end]])
    format_map(mapping)
    fromhex(string) (e.g., string = "2Ef0 F1f2  "
    index(sub[, start[, end]])
    isalnum()
    isalpha()
    isdigit()
    islower()
    isspace()
    istitle()
    isupper()
    join(iterable)
    ljust(width[, fillchar])
    lower()
    lstrip([chars])
    static str.maketrans(x[, y[, z]])
    partition(sep)
    replace(old, new[, count])
    rfind(sub[, start[, end]])
    rindex(sub[, start[, end]])
    rjust(width[, fillchar])
    rpartition(sep)
    rsplit(sep=None, maxsplit=-1)
    rstrip([chars])
    split(sep=None, maxsplit=-1)
    splitlines([keepends])
    startswith(prefix[, start[, end]])
    strip([chars])
    swapcase()
    title()
    translate(table[, delete])
        table must be of length 256.  See below.
    upper()
    zfill(width)

The search methods in, count(), find(), index(), rfind() and rindex())
all accept both integers in the range 0 to 255 (inclusive) as well as
bytes and byte array sequences.

translate() is different from string, which uses a dict.  You can use
bytes.maketrans(from, to) to create a translation table.  from and to
must be bytes objects of the same length.

----------------------------------------------------------------------
readline                                                *python_readline*

import readline

To use readline's editing with a script:

    readline.set_startup_hook(input)
    s = input("> ")

----------------------------------------------------------------------
pip                                                     *python_pip*

Use 'ph cmd' to get pip's help on a command (this script filters out the
general options)

To install pip
    python -m pip install pip
To upgrade pip
    python -m pip install --upgrade pip
To install some package pkg
    python -m pip install pkg

Use 'pip install --dry-run Pkg" to see what will be done

Use 'pip install Pkg==2.0.0" to install a specific version of Pkg

Commands:
  install          Install packages
    Install a package                pip install Pkg
    Upgrade a package                pip install --upgrade Pkg
  download         Download packages
  uninstall        Uninstall packages
    Uninstall a package              pip uninstall Pkg
  freeze           Output installed packages in requirements format
  inspect          Inspect the python environment
  list             List installed packages
    Show installed packages:         pip list
    Show outdate packages:           pip list --outdated
  show             Show information about installed packages
    Show what was installed:         pip show -f Pkg
    Show missing dependencies:       pip show
  check            Verify installed packages have compatible dependencies
  config           Manage local and global configuration
  search           Search PyPI for packages
  cache            Inspect and manage pip's wheel cache
  index            Inspect information available from package indexes
  wheel            Build wheels from your requirements
  hash             Compute hashes of package archives
  completion       A helper command used for command completion
  debug            Show information useful for debugging
  help             Show help for commands

    The inspect command is experimental, but produces a JSON report of the
    details of the installed python stuff.

Requirements files

    For a complicated project, you'll want to set up a requirements file.
    This is a text file with lines like

        mpmath==1.2.1
        PyPDF4 @ file:///pub/devel/python/python-pypdf/.../PyPDF4-1.27.0-py3-none-any.whl

    which describes the package and version (it's the syntax needed on the
    'pip install' line.  The second form is a wheel file.  

    The easiest way to create a requirements file for an existing project is 

        pip freeze >requirements.txt

    Then you use it with

        pip install -r requirements.txt

https://pypi.python.org/pypi/pip
---------------------------------------------------------------------------
list methods and operations                     *python_lists*

s[i] = x        Replace the ith item by x
s[i:j] = t      The slice is replaced by the contents of the iterable
s[i:j:k] = t    The slice is replaced by the contents of the iterable; t
                must have the same length as what's being replaced.
del s[i]        Delete the indicated element
del s[i:j]      Same as s[i:j] = []

append(x)       Add x to end of list
clear()         Empty the list
extend(L)       Append items from list L to end of list
insert(i, x)    Insert x before item i
remove(x)       Remove first x from list
pop([i])        Remove item from position i (default -1) and return it
index(x)        Return index of x (ValueError if not present)
count(x)        Return number of times x is in list
sort()          Sort items in place (see below)
reverse()       Reverse items in place

You can change or clear a slice:
    letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    Change some of them:
        letters[2:5] = ['C', 'D', 'E']
    Remove them:
        letters[2:5] = []
    Clear the list:
        1.  letters = []
        2.  letters[:] = []
        3a. del letters[:]
        3b. del letters[0:-1]
        4.  letters.clear()
        5.  while letters:
                letters.pop()

Copying a list x with approximate timings
    Cloning:  copy = x[:]                   # 40 ms
    Extend:  copy = []; copy.extend(x)      # 50 ms
    Constructor:  copy = list(x)            # 75 ms
    Comprehension:  copy = [i for i in x]   # 220 ms
    Append:                                 # 320 ms
        copy = []
        for item in x:
            copy.append(item)
    Copy module:                            # 190 ms
        import copy
        cpy = copy.copy(x)                  # Shallow copy
        cpy = copy.deepcopy(x)              # Deep (recursive) copy
    Copy method:  cpy = x.copy()            # (shallow copy) 1500 ms

Try to avoid doing lots of inserts at the beginning of the list, as this may
involve moving things around in memory.

sort has parameters sort(cmp=None, key=None, reverse=False)
    cmp is a two parameter function that returns -1, 0, or 1 if the
    arguments compare <, == or >.

    key is a one parameter function that extracts a comparison key from
    each list element.

    If reverse is true, sort as if each comparison was reversed.

List methods:
    L = list.__dict__.keys()
    for i in sorted(L):
        print(i)
  gives for python 3.7:

    __add__          __hash__         __ne__           copy
    __contains__     __iadd__         __new__          count
    __delitem__      __imul__         __repr__         extend
    __doc__          __init__         __reversed__     index
    __eq__           __iter__         __rmul__         insert
    __ge__           __le__           __setitem__      pop
    __getattribute__ __len__          __sizeof__       remove
    __getitem__      __lt__           append           reverse
    __gt__           __mul__          clear            sort

Use sorted to generate a sorted list from any iterable.
    sorted(iterable, cmp=None, key=None, reverse=False)
  Example of sort keys:
    students = (
        # Name  Grade Age
        ("john", "A", 15),
        ("jane", "B", 12),
        ("dave", "B", 10),
    )
    sorted(students, key= lambda s: s[2])  # Sorts by age
    --> [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    Since this pattern is common, use convenience functions from operator
    module:
        from operator import itemgetter
        sorted(students, key=itemgetter(2))
    Can also use operator.attrgetter for objects with attributes in the
    same fashion.

    itemgetter is a useful pattern:  it's a closure equivalent to the
    following:
        def itemgetter(*items):
            if len(items) == 1:
                item = items[0]
                def g(obj):
                    return obj[item]
            else:
                def g(obj):
                    return tuple(obj[item] for item in items)
            return g

---------------------------------------------------------------------------
Descriptors                                    *python_descriptors*

https://realpython.com/python-getter-setter/#replacing-getters-and-setters-with-more-advanced-tools

Python makes it easy to let users access attributes.  However, a
fundamental problem is that if you want to change the implementation from a
variable access to a computed access, you'll break the user's API.  

    Rule:  public attributes should only be used when you're sure no one
    will ever need to attach behavior to them.

    If you need to attach behavior, you need getters & setters.

Descriptors use the __set__, __get__, and __set_name__ methods to make a
reusable component that has computable getters and setters.

You can also use __getattr__ and __setattr__ for these tasks which allow
the attributes to be computed:

    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y
        def __getattr__(self, name: str):
            return self.__dict__[f"_{name}"]
        def __setattr__(self, name, value):
            self.__dict__[f"_{name}"] = float(value)

    Note the addition of an underscore to the name; this is what allows you
    to avoid a recursive mess.

Properties are an intermediate way of avoiding getters and setters for each
attribute; they allow you to turn class attributes into managed attributes.
https://realpython.com/python-property/  This is the old "functional" form
of property(), but today I prefer to use the @property decorator.

---------------------------------------------------------------------------
Dictionary methods and operations              *python_dictionaries*

class dict([arg])
    dict(one=2, two=3)   Only works for valid python identifiers
    {"one":2, "two":3}
    dict(zip(("one", "two"), (2, 3)))
    dict(["one", 2], ["two", 3])
    dict(("one", 2), ("two", 3))

len(d)                  Returns number of items in dictionary
d[key]                  Returns value associated with key (KeyError if key
                        is not in map)
d[key] = value          How to set value
del d[key]              Remove a value/key pair (KeyError)
key in d                True if key in d
key not in d            False if key in d
iter(d)                 Returns an iterator over the keys
clear()                 Empties the dictionary
copy()                  Shallow copy
fromkeys(seq[, x)       New dictionary with keys from seq and values set to x
get(key[, x])           Return value for key or x if key not in dict
has_key(key)            Deprecated; use key in d
items()                 Copy of (key, value) pairs
iteritems()             Return an iterator over (key, value) pairs
iterkeys()              Return an iterator over keys
itervalues()            Return an iterator over values
keys()                  Copy of list of keys
pop(key[, x])           Return d[key] or x if key not present
popitem()               Remove and return arbitrary (key, value)
setdefault(key[, x])    If key in d, return value; otherwise set d[key] = x
                        and return x.
update([other])         Update with key/value pairs from other.
values()                Return copy of list of values

If you want to iterate and change the dictionary, use
    for key in d.keys():
        do something with d

  instead of
    for key in d:
        do something with d

  because the later will get a RuntimeError because the dictionary changed
  during iteration.

Instead of (d is a dictionary defined elsewhere)
    for i, j in data:
        if i not in d:
            d[i] = 0
        d[i] += j
  use
    for i, j in data:
        d[i] = d.get(i, 0) + j

Or, use a defaultdict:
    from collections import defaultdict
    equities = defaultdict(list)
    for portfolio, equity in data:
        equities[portfolio].append(equity)

This is because each dictionary value is initialized to an empty list.  If
you wanted integers instead, use defaultdict(int) and each value would
start at zero.  Note, however, that you'll never get a KeyError with a
properly-initialized defaultdict.

---------------------------------------------------------------------------
Set methods and operations                     *python_sets*

class set([iterable])
class frozenset([iterable])  (Immutable and hashable)

For sets of sets, the inner sets must be frozen sets.

Two sets are equal iff every element of one set is in the other (each is a
subset of the other).

Basic operations (the methods will accept any iterables)
    add(elem)
        Add element to set
    clear()
        Remove all elements
    copy()
        Shallow copy
    difference(*others)    or set - other - ...
        Set without items in others
    difference_update(*others)  or   set -= other -= ...
        Update by removing elements in others
    discard(elem)
        Discard element if it is present
    intersection(*others)   or  set & other & ...
    intersection_update(*others)   or    set &= other &= ...
        Update but keep only elements in set and in all others
    pop()
        Remove and return arbitrary element
    remove(elem)
        Remove (KeyError if not element)
    symmetric_difference(*others)   or set ^ other ^ ...
        Set with elements in either the set or the others but not both
        A^B == (A - B)|(B - A)
    symmetric_difference_update(other)  or  set ^= other
        Update by keeping elements in either set, but not both
    union(*others)   or  set | other | ...
    update(*others)  or  set |= other |= ...
        Update by adding all elements from others.  others can be a single
        element or an iterable.

Member testing
    x in x
    x not in s

Logical tests
    isdisjoint(other)       True if intersection is null
    issubset(other)         True if set is a subset of other
    set <= other            True if set is a subset of other
    set < other             True if set is a proper subset of other
    issuperset(other)       True if set is a superset of other
    set >= other            True if set is a superset of other
    set > other             True if set is a proper superset of other

-----------------------------------------------------------------------------
From types.py                                              *python_types*

NoneType (== TypeType)

IntType
LongType
FloatType
ComplexType

StringType
UnicodeType
StringsType = (StringType, UnicodeType)
BufferType

TupleType
ListType
DictType

FunctionType (== LambdaType)
CodeType
ClassType
UnboundMethodType
InstanceType
MethodType
BuiltinFunctionType (== BuiltinMethodType)
ModuleType

FileType
XRangeType
TypeError
SliceType
EllipsisType

-----------------------------------------------------------------------------
debugger                                                *python_debugger*

My usual method of debugging is a line in the code
    from pdb import set_trace as xx 
    from dpdb import set_trace as xx  (My modified debugger with colorizing)

Then xx() anywhere in the code drops into the debugger at that point.

Key debugger commands

    h           Show list of commands.  'h cmd' gives help on cmd.
    n           Execute next statement
    s           Step into next statement
    a           Show arguments of current frame
    w, bt       Show backtrace
    b, tb       Breakpoint, temporary breakpoint
    r           Continue until return
    c           Continue execution
    d, u        Down and up in the stack frames
    p expr      Print value of expression
    pp expr     Pretty print value of expression
    l           List code
    ll          List code of current function

Use .pdbrc in $HOME or current directory to init the debugger.  This is
useful to define command aliases.  Example:

    alias i interact    
        Lets you start a REPL with the current globals and locals, then
        quit to go back to debugger.

pdb module's methods:

    run(statement [, globals [, locals]])
        Execute statement with debugger.  Prompt before code executes.
    runeval(expression [, globals [, locals]])
        Evaluate expression with debugger.  On success, value of expression
        is returned.
    runcall(function [, argument, ...])
        Calls a function with debugger.
    set_trace()
        Hard-codes a breakpoint into the code.
    post_mortem(traceback)
        Post-mortem debug using a traceback object.
    pm()
        Enters post-mortem debug using sys.last_traceback.  Example:  this
        is called in TraceInfo() in debug.py, in turn called by
        SetDebugger() on an unhandled exception.

Command list
------------

    a, args         Args of current function
    alias           Make an alias
    b, break        Set a breakpoint
    w, where, bt    Stack trace (backtrace)
    c               Continue execution
    cl, clear       Remove breakpoint
    clr             Select colorizing (only in dpdb.py)
    commands        Set a group of commands to be executed when a breakpoint is
                    encountered
    condition       Sets a logical condition for a breakpoint to be honored
    d, down         Move down in the stack frames
    debug           Enter a recursive debugger
    disable         Disable a breakpoint
    display         Display an expression if it has changed each time execution
                    stops in the current frame
    enable          Enable one or more breakpoint numbers
    EOF             
    q, exit         Quit
    h, help         Show commands, show help on a particular command.  Use arg
                    of 'pdb' to see all help.
    ignore          How many times to ignore a breakpoint
    interact        Enter a python REPL with current globals/locals
    j, jump         Set next line; only works in bottom frame
    l, list         List source
    ll, longlist    List source of current function
    n, next         Step through next line
    p               Print value of expression
    pp              Pretty print value of expression
    r, return       Continue until function returns
    rv, retval      Print return value of last function
    run, restart    Restart the program
    s, step         Step into next line
    source          Display source code for argument
    tbreak          Set a temporary breakpoint
    u, up           Move up in the stack frames
    unalias         Delete an alias
    undisplay       Remove a set display command
    unt, until      Continue execution until later line or frame returns
    whatis          Print the type of the argument

-----------------------------------------------------------------------------
re                                                      *python_re*

Special Sequences
    \num    Matches content of the group with the same number; groups
            are numbered starting from 1.
    \g<name>    Named group reference.
    \A      Matches only at the start of the string.
    \b      Empty string at beginning or end of word:  '\bis\b'
            matches 'is' but not 'his'.
    \B      Empty string not at beginning or end of word.
    \d      Any decimal digit == [0-9]
    \D      Any non decimal digit == [^0-9]
    \s      Any whitespace character == [ \t\n\r\f\v]
    \S      Any nonwhitespace character == [^ \t\n\r\f\v]
    \w      Any alphanumeric character (depends on LOCALE flag)
    \W      Any non-alphanumeric character (depends on LOCALE flag)
    \Z      Matches only at the end of the string

Flags
    A       ASCII only matching instead of Unicode
    I       Ignore case
    L       \w, \b etc. locale-dependent (only works with bytes)
    M       Multiline
    S       '.' matches any character including a newline
    X       Verbose expressions (lets you use comments)

Character meanings
    .           Matches any character (including newline if DOTALL flag
                specified)
    ^           Matches start of the string (of every line in MULTILINE
                mode)
    $           Matches end of the string (of every line in MULTILINE mode)
    *           0 or more of the preceding RE (as many as possible)
    +           1 or more of the preceding RE (as many as possible)
    ?           0 or 1 occurence of the preceding RE
    *?, +?, ??  Same as *, +, and ? but matches as few characters as
                possible (non-greedy match)
    {n}         Match exactly n repetitions of preceding RE
    {n,m}       Match from n to m repetitions of preceding RE
    {n,m}?      Match from n to m repetitions of preceding RE, but match as
                few as possible
    [ ]         Defines character set:  e.g., '[a-zA-Z]' to match all
                letters (see also \w and \S).  Magic characters lose their
                meaning in brackets.  Complement the set with ^.
    [^ ]        Defines complemented character set; matches if character is
                not in set
    \           Escapes special characters '*?+&$|()' and introduces special
                sequences (see below).  Due to python string rules, write as
                '\\' or r'\' in the pattern string.
    \\          Matches a literal '\'; due to python string rules, write as
                '\\\\' in pattern string, or better using raw string:
                r'\\'.
    |           Specifies alternative: 'foo|bar' matches 'foo' or 'bar'.
    (...)       Group delimiter; matches any RE inside ( ).
    (?=...)     Matches if ... doesn't match next, but doesn't consume any
                of the string e.g., 'Isaac (?=Asimov)' matches 'Isaac' only
                if followed by 'Asimov'. (lookahead assertion)
    (?!...)     Matches if ... doesn't match next.  Negative of (?=...).
                (negative lookahead assertion)
    (?<=...)    Matches if current position in string is preceded by a match
                for ... that ends at the current position (positive
                lookbehind assertion).  (?<=abc)def will find a match in
                'abcdef', since the lookbehind will back up 3 characters and
                check if the contained pattern matches. 
    (?<!...)    Matches if current position in string is not preceded by a
                match (negative lookbehind assertion).
    (?P<name>   Matches any RE inside ( ) and delimits a named group.  e.g.,
    ...)        r'(?P<id>[a-zA-Z_]\w*)' defines a group named id.
    (?P=name)   Matches whatever text was matched by the earlier group named
                name (i.e., a backreference).
    (?#...)     A comment; ignored.
    (?aiLmsux)  Flags corresponding to (re.A, re.I, re.L, re.M, re.S, re.X) 
                for the entire RE.  Example "\$(?i)rel" matches "Rel", "rel",
                and "REL".
    (?:...)     Sames as (...), but doesn't keep the matched substring.
    (?aiLmsux-imsx:...)
                Set or remove the flags, but only within the inline group.
    (?(id/name)yes-pattern|no-pattern)
                Will try to match with yes-pattern if the group with given id
                or name exists, and with no-pattern if it doesn’t.

    Back references:  Use \num to refer to matched groups by their number.
    For named groups, use "\g<name>".

Match strings or bytes patterns (but they can't be mixed).  Synopsis:
    Bytes
        r = re.compile(b'ab')
        r.search(b'cdabef')
        Produces:  <re.Match object; span=(2, 4), match=b'ab'>
    Strings
        r = re.compile('ab')
        r.search('cdabef')
        Produces:  <re.Match object; span=(2, 4), match='ab'>

Variables
    error   Exception when pattern string isn't valid RE

Module functions
    compile(pattern[, flags=0])              
        Returns a regular expression object (see below).
        Flags:
            re.A, re.ASCII (inline flag (?a))
                Make \w, \W, \b, \B, \d, \D, \s and \S perform ASCII-only
                matching instead of full Unicode matching.
            re.DEBUG
                Prints debug info.
            re.I, re.IGNORECASE (inline flag (?i))
                [A-Z] will match lowercase letters if True.
            re.L, re.LOCALE (inline flag (?L))
                Make \w, \W, \b, \B and case-insensitive matching dependent
                on the current locale.  Works only with byte patterns.
                Discouraged because locale mechanism is unreliable.
            re.M (inline flag (?m))
                Multiline matching
            re.S (inline flag (?s))
                Dotall; '.' matches everything including newline
            re.U (inline flag (?u))
                Redundant, as python 3 uses Unicode by default.  Make \w,
                \W, \b, \B, \d, \D, \s and \S dependent on the Unicode
                character properties database.
            re.X (inline flag (?x))
                Allow verbose strings; (?x) must be first in regexp; no
                leading spaces.
    search(pattern, string, flags=0)
        Return mo if pattern is found within string or None
    match(pattern, string, flags=0)
        Return mo if pattern matches at beginning of string or None
    fullmatch(pattern, string, flags=0)
        Return mo if whole string matches or None
    split(pattern, string, maxsplit=0, flags=0)
    sub(pattern, repl, string, count=0, flags=0)
        Replace leftmost match.  repl can be a string or function (fn gets a
        Match object & should return a str).
    subn(pattern, repl, string, count=0, flags=0)
        Same as sub(), but returns a tuple (newString, numberOfSubsMade)
    findall(pattern, string, flags=0)
        Return a list of all non-overlapping matches
    finditer(pattern, string, flags=0)
    escape(pattern)
        Returns a string with non-alphas escaped
    purge()
        Clear the regular expression cache.

Regular expression objects
    Attributes
        flags        Flags argument used when RE object was compiled
        groupindex   Dictionary of {group name: group number} in pattern
        pattern      Pattern string from which RE object was compiled

    Methods (mo = Match object)
        fullmatch(string[, pos[, endpos]])      Returns mo
        match(string[, pos[, endpos]])          Returns mo
        search(string[, pos[, endpos]])         Returns mo
        split(string[, maxsplit=0])
        sub(repl, string[, count=0])
        subn(repl, string[, count=0])

Match objects
  Attributes:
        pos     Value of pos passed to search() or match(); index into
                string at which RE engine started to search.
        endpos  Value of endpos passed to search() or match(); index into
                string beyond which RE won't go.
        re      RE object whose match or search method produced this
                MatchObject instance
        string  String passed to match() or search()
  Methods:
    group(g1, g2, ...)
        Returns one or more groups of the match.  If one argument, result is
        a string.  If multiple arguments, result is a tuple with one item per
        argument.  If gi is 0 return value is entire matching string; if 1 <=
        gi <= 99, return string matching group #gi (or None if no such
        group); gi may also be a group name.
    groups()
        Returns a tuple of all groups of the match; groups not participating
        to the match have a value of None.  Returns a string instead of a
        tuple if len(tuple) == 1.
    start(group), end(group)
        Returns indices of start and end of substring matched by group (or
        None if group exists but doesn't contribute to the match).
    span(group)
        Returns the 2-tuple (start(group), end(group)); can be (None, None)
        if the group didn't contribute to the match.

Idioms
    1.  Simple matching

        r = re.compile("(file)")
        mo = r.search("Usage:  dec.py [options] regexp [file1 [file2 ...]]")
        if mo is not None:
            print("Groups =", mo.groups())
            print("Match =", mo.start(), mo.end())

        prints
            Groups = ('file',)
            Match = 33 37

        Note there's only one group matched (i.e., the second 'file' on
        the line is missed.  The fix for this would be to start another
        regexp search after the end of the first match.  This would show
        all non-overlapping matches.

    2. More complicated:  match an integer or floating point number:
        b  = r'''
                (?x)                            # Allow verbosity
                (                               # Group
                    [+-]?                       # Optional sign
                    \.\d+                       # Number like .345
                    ([eE][+-]?\d+)?|            # Optional exponent
                # or
                    [+-]?                       # Optional sign
                    \d+\.?\d*                   # Number:  2.345
                    ([eE][+-]?\d+)?             # Optional exponent
                )                               # End group
                '''
        s  = "^" + b + "$"

    3. Put re.DEBUG in as a flag to regex's -- it can help with debugging
       them:

        >>> r = re.compile("ab(c)", re.DEBUG)
        LITERAL 97
        LITERAL 98
        SUBPATTERN 1 0 0
        LITERAL 99

        0. INFO 12 0b1 3 3 (to 13)
            prefix_skip 2
            prefix [0x61, 0x62, 0x63] ('abc')
            overlap [0, 0, 0]
        13: LITERAL 0x61 ('a')
        15. LITERAL 0x62 ('b')
        17. MARK 0
        19. LITERAL 0x63 ('c')
        21. MARK 1
        23. SUCCESS

Driver code:  
    r = re.compile(s)
    line = ".1,-.2,3,-4,-5.6,+7.8e-6,48.7654,.4444e+99"
    for item in line.split(","):
        mo = r.match(item)
        if mo:
            print("%-20s" % item, repr(mo.groups()[0]))
    Output:
        .1                   '.1'
        -.2                  '-.2'
        3                    '3'
        -4                   '-4'
        -5.6                 '-5.6'
        +7.8e-6              '+7.8e-6'
        48.7654              '48.7654'
        .4444e+99            '.4444e+99'

-----------------------------------------------------------------------------
getopt                                              *python_getopt*

Example:
    # Invocation was 'python test.py -c hi -a arg1 arg2'
    opts, args = getopt.getopt(sys.argv[1:], 'ab:c:')
    # opts would be
        [('-c', 'hi'), ('-a', '')]
    # args would be
        ['arg1', 'arg2']

Another example:

    try:
        optlist, args = getopt.getopt(sys.argv[1:], "v:d")
    except getopt.error, str:
        print("getopt error:  %s\n" % str)
        sys.exit(1)
    for opt in optlist:
        if opt[0] == "-v":
            PrintVersions()
        elif opt[0] == "-d":
            dbfileG = "stdout"

-----------------------------------------------------------------------------
random                                              *python_random*
 
Random variates
    betavariate(alpha, beta)
        alpha > 0, beta > 0, returns on [0, 1].
    expovariate(lambd)
        lambd is 1/(desired mean), returns on [0, ∞].
    gammavariate(alpha, beta)
        alpha > 0, beta > 0.
        pdf = (x**(alpha - 1)*math.exp(-x/beta))/A
          A = math.gamma(alpha)*beta**alpha
    gauss(mu, sigma)
        Normal dist, but not thread safe.
    lognormvariate(mu, sigma)
    normalvariate(mu, sigma)
        Normal dist, thread safe.
    paretovariate(alpha)
    random()  Returns a random float on [0, 1).
    triangular(low, high, mode)
        Returns x such that low <= x <= high with the indicated mode.  low
        and high default to 0 and 1.  mode defaults to (low + high)/2.
    uniform(a, b)
        Return a random floating point number x such that a <= x <=b if 
        a <= b and b <= x <= a if b < a.
    vonmisesvariate(mu, kappa)
        mu is the mean angle, expressed in radians between 0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero. If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0 to 2*pi.
    weibullvariate(alpha, beta)
        alpha is scale, beta is shape.

Other selection methods
    choice(seq)
        Returns a random element from a sequence.
    choices(population, weights=None, *, cum_weights=None, k=1)
        Return a k sized list of elements chosen from the population with
        replacement.  Selections are made with equal probability if weights are
        not specified.  If a weights sequence is specified, selections are made
        according to the relative weights.  The relative weights [10, 5, 30, 5]
        are equivalent to the cumulative weights [10, 15, 45, 50].
    getrandbits(k)
    `   Returns a integer with k random bits.
    randrange([start], stop[, step])
        Randomly selected value from range(start, stop, step).  Same as 
        choice(range(start, stop, step)).
    randint(a, b)
        Returns a random integer between a and b inclusive.
    sample(population, k, *, counts=None)
        Return a new list of k elements, samping without replacement.  The
        original sequence is not changed.  Repeated elements can be specified
        one at a time or with the counts parameter. For example, sample(['red',
        'blue'], counts=[4, 2], k=5) is equivalent to sample(['red', 'red',
        'red', 'red', 'blue', 'blue'], k=5).
    shuffle(seq [, random])
        Shuffle the sequence in-place.  random is a 0-arg function that
        returns a float on [0, 1).  random argument is deprecated.

Utility functions
    seed([x]) 
        Seed RNG with hashable object; if x is missing or None, the system
        clock is used.
    getstate() 
        Return a state object that can be used with setstate().
    setstate(state)
        Set the state to a previously-saved state using getstate().
    jumpahead(n)
        Change the state from the current state.  n is an integer >= 0.

If you need cryptographically-secure random number stuff, use
        import random
        r = random.SystemRandom()
    and the r object has the same functions as the regular random
    module's calls (except for seed-related stuff).  The difference is
    that os.urandom() calls are used.
  
    But, for security stuff, the best choice is the secrets module.
 
-----------------------------------------------------------------------------
secrets                                              *python_secrets*

secrets.SystemRandom:  generates random numbers using system resources.
Otherwise behaves as random.SystemRandom.

secrets.choice(sequence)
    Return a randomly chosen element from a non-empty sequence.
secrets.randbelow(n)
    Return a random int in the range [0, n).
secrets.randbits(k)
    Return an int with k random bits.

secrets.token_bytes([nbytes=None])
    Return a random byte string containing nbytes number of bytes. If
    nbytes is None or not supplied, a reasonable default is used.
secrets.token_hex([nbytes=None])
    Return a random text string, in hexadecimal. The string has nbytes
    random bytes, each byte converted to two hex digits. If nbytes is None
    or not supplied, a reasonable default is used.
secrets.token_urlsafe([nbytes=None])
    Return a random URL-safe text string, containing nbytes random bytes.
    The text is Base64 encoded, so on average each byte results in
    approximately 1.3 characters. If nbytes is None or not supplied, a
    reasonable default is used.

Recipes
    8 character password
        import string
        import secrets
        alphabet = string.ascii_letters + string.digits
        password = ''.join(secrets.choice(alphabet) for i in range(8))
 
    10 character alphanumeric password with at least one lowercase
    character, at least one uppercase character, and at least three digits:
        import string
        import secrets
        alphabet = string.ascii_letters + string.digits
        while True:
            password = ''.join(secrets.choice(alphabet) for i in range(10))
            if (any(c.islower() for c in password)
                    and any(c.isupper() for c in password)
                    and sum(c.isdigit() for c in password) >= 3):
                break
 
    Generate an XKCD-style passphrase:
        import secrets
        # On standard Linux systems, use a convenient dictionary file.
        # Other platforms may need to provide their own word-list.
        with open('/usr/share/dict/words') as f:
            words = [word.strip() for word in f]
            password = ' '.join(secrets.choice(words) for i in range(4))
 
    Generate a hard-to-guess temporary URL containing a security token
    suitable for password recovery applications:
        import secrets
        url = 'https://example.com/reset=' + secrets.token_urlsafe()

-----------------------------------------------------------------------------
os                 *python_os*            Pg 145 Beazley
--

Useful recursive tool:  os.walk:
    for root, dirs, files in os.walk("."):
        print(root, dirs, files)


     Variables

name      Name of OS specific module (e.g., 'posix', 'mac', 'nt')
path      OS specific module for path manipulations
curdir    String used to represent current directory ('.')
pardir    String used to represent parent directory ('..')
sep       String used to separate directories ('/' or '\')
pathsep   Character to separate search path components (as in $PATH),
          e.g., ';' for Windows or ':' for UNIX.
linesep   String used for EOL
environ   Dictionary of environment variables
error     Exception raised on POSIX-related error.  Corresponding value
          is tuple of errno code and perror() string.

     Functions

chdir(path)                  Change current directory to path.
chmod(path, mode)            Change the mode of path to the numeric mode.
                             On Windows, you can only make a file read
                             only.  You must use a specifier like
                             0444 (i.e., it needs to be an octal number,
                             just like on UNIX).
close(fd)                    Close file descriptor fd opened with
                             posix.open.
_exit(n)                     Immediate exit with no cleanups or
                             SystemExit.  Should use this to exit a child
                             process.
execv(p, args)               "Become" executable p with args args.
getcwd()                     Return a string representing the current
                             directory.
getpid()                     Return the current process ID.
fork()                       Like C's fork().  Returns 0 to child, child
                             pid to parent. (Not on Windows)
kill(pid, signal)            Like C's kill() (not on Windows).
listdir(path)                List names of entries in directory path.
lseek(fd, pos, how)          Set position in file fd to position pos,
                             expressed as an offset relative to beginning
                             of file (how=0), to current position
                             (how=1), or to end of file (how=2).
mkdir(path[, mode])          Creates a directory path with numeric mode
                             (default 0777).
open(file, flags, mode)      Like C's open().  Returns file descriptor.
                             Use file object functions rather than this
                             low level one.
pipe()                       Creates a pipe.  Returns pair of file
                             descriptors (r, w).  Not on Windows.
popen(command, mode='r',     Open a pipe to or from command.  Result is a
putenv(varname, value)       Set env variable; affects subprocesses started
                             with os.system, popen, fork, execv, but doesn't
                             update os.environ.
buffSize=0)                  file object to read or write from, as
                             indicated by mode being 'r' or 'w'.
remove(path)                 See unlink().
rename(src, dest)            Rename/move the file or directory src to
                             dest.  Error if target name already exists.
rmdir(path)                  Remove the directory path.
stat(path)                   Returns (st_mode, st_ino, st_dev, st_nlink,
                             st_uid, st_gid, st_size, st_atime, st_mtime,
                             st_ctime).  Most items are dummy on Windows.
strerror(code)               Error msg; see errno.
system(command)              Execute string command in a subshell.
                             Returns exit status of subshell.
times()                      Return accumulated CPU time in sec (user,
                             system, children's user, children's sys,
                             elapsed real time).  Last 3 not on Windows.
umask(mask)                  Sets current umask and returns old umask.
unlink(path)                 Delete path; same as remove(path).
utime(path, (aTime, mTime)   Set the access and modified time of the file
                             to the given tuple.
wait()                       Wait for child process completion.  Returns
                             tuple of (pid, exit_status).  Not on
                             Windows.
waitpid(pid, options)        Wait for process pid to complete.  Returns
                             tuple of (pid, exit_status).  Not on
                             Windows.
write(fd, str)               Write str to fd.  Returns number of bytes
                             written.

-----------------------------------------------------------------------------
os.path                  *python_os_path*             Pg 154 Beazley

abspath(p)      Return a normalized form of path p.

basename(p)     Second half of os.path.split(path).

commonprefix(list)  Return the longest path prefix that is common to
                items in list.

exists(p)       True if string p is an existing path.

lexists(p)      True if string p is an existing path.  Returns True
                for broken symbolic links.

expanduser(p)   Returns string that is a copy of p with tilde expansion done.

expandvars(p)   Returns string that is a copy of p with environment variables
                expanded.  Windows:  case is significant; use UNIX $var
                notation, not %var%.

getatime(p)     Time of last access.

getmtime(p)     Time of last modification.

getctime(p)     Time of creation (Windows) or last change (Unix).

getsize(p)      Size in bytes.

isabs(p)        True if string p is an absolute path.

isfile(p)       True if string p is a regular file.

isdir(p)        True if string p is a directory.

islink(p)       True if string p is a symbolic link.

ismount(p)      True if string p is a mount point (true for all directories on
                Windows).

join(p[, q[,    Joins one or more path components intelligently.
...]])

normcase(p)     Normalize case; converts to lower case on Windows;
                leaves file alone on Unix.  On Windows, converts
                forward slashes to backslashes.

normpath(p)     Normalizes a path by removing redundant separators and
                up-references.  On Windows, converts forward slashes to 
                backslashes.  Can change the meaning of a path if it
                contains symbolic links.

realpath(p)     Return the canonical path, removing any symbolic
                links.

relpath(p,      Return a relative path from current directory or the
[start])        indicated start directory.

split(p)        Splits into (head, tail) where tail is last pathname component
                and head is everything leading up to that.  [ == (dirname(p),
                basename(p)) ]

splitdrive(p)   Splits path in a pair on Windows ('drive:', tail).

splitext(p)     Splits into (root, ext) where last component of root contains
                no periods and ext is empty or starts with a period.

splitunc(p)     Split p into (unc, rest) so that unc is the UNC mount
                point, if present, and rest is the rest.  Windows
                only.  If the path contains a drive letter, unc will
                always be empty.

walk(p, visit,  Calls the function visit with arguments (<arg>, <dirname>,
arg)            <names>) for each directory recursively in the directory tree
                rooted at p (including p itself if it's a directory).  The
                argument dirname specifies the visited directory, names lists
                the files in the directory.  The visit function may modify
                names to influence the set of directories visited below
                dirname, e.g., to avoid visiting certain parts of the tree.

-----------------------------------------------------------------------------
sys                  *python_sys*               Pg 101 Beazley
---

version:
    sys.version_info = tuple of (major, minor, micro, releaselevel serial)

Variables

argv              Command line arguments
check_interval
    How often to check for thread switches or signals (measured in
    number of virtual machine instructions)
copyright
    The copyright string.
displayhook(value)
    The interactive interpreter calls displayhook; value is the result
    of each expression. 
excepthook(type, value, traceback)
    Called when an exception is not caught.
exc_info()
    (cls, obj, traceback) for an exception; (None, None, None) if no
    exception occurred.
exit(n)
    Exit with status n; raises SystemExit exception.
exitfunc(func)
    User can set to a parameterless function which will get called
    before interpreter exits.
getdefaultencoding()
    Returns the name of the default codec.
getrefcount(obj)
    Returns the reference count of object obj.
getrecursionlimit()
    Returns the recursion limit.
_getframe(depth=0)
    Returns a specified frame from the stack.
maxint
    The largest integer.  Most negative is -maxint - 1.
modules
    A dictionary detailing loaded modules.
path
    List of strings that are searched to load modules.
platform
    String describing the platform.
prefix
    Directory where platform-independent files are.
ps1, ps2
    Primary and secondary interpreter prompts.  If you bind a
    non-string object to either, python calls the str method on the
    object.
setdefaultencoding(name)
    Sets the default codec.  Intended to be call from sitecustomize.py
    only.
setprofile(profile_func)
    Sets a global function that is called at each function entry and
    exit.
setrecursionlimit(limit)
    Sets depth limit on call stack.  Improper messing with can lead to
    hard system crashes.
settrace(trace_func)
    Sets a trace function that python calls as each logical line
    executes.
stdin, stdout, stderr
    Standard streams.  Can be rebound.
tracebacklimit
    Maximum number of levels displayed in a traceback.  Default is no
    limit.  If <= 0, only exception type and value are printed.
version
    E.g. '2.6.5 (r265:79096, Mar 19 2010, 21:48:26) [MSC v.1500 32 bit
    (Intel)]'

Here's a script to get the following lists of sys contents:
    import sys
    def g(s):
        f = str(s).split("'")
        t = f[1]
        if t == "builtin_function_or_method":
            t = "func"
        return t
    d = dir(sys)
    n = max([len(i) for i in d]) + 2
    for i in d:
        s = type(eval("sys.%s" % i))
        print("%-*s %s" % (n, i, g(s)))

Here's a list of sys module objects & types (gotten with dir()) for
python 2.6.5:

    __displayhook__         func
    __doc__                 str
    __excepthook__          func
    __name__                str
    __package__             NoneType
    __stderr__              file
    __stdin__               file
    __stdout__              file
    _clear_type_cache       func
    _current_frames         func
    _getframe               func
    api_version             int
    argv                    list
    builtin_module_names    tuple
    byteorder               str
    call_tracing            func
    callstats               func
    copyright               str
    displayhook             func
    dllhandle               int
    dont_write_bytecode     bool
    exc_clear               func
    exc_info                func
    exc_type                NoneType
    excepthook              func
    exec_prefix             str
    executable              str
    exit                    func
    flags                   sys.flags
    float_info              sys.floatinfo
    getcheckinterval        func
    getdefaultencoding      func
    getfilesystemencoding   func
    getprofile              func
    getrecursionlimit       func
    getrefcount             func
    getsizeof               func
    gettrace                func
    getwindowsversion       func
    hexversion              int
    maxint                  int
    maxsize                 int
    maxunicode              int
    meta_path               list
    modules                 dict
    path                    list
    path_hooks              list
    path_importer_cache     dict
    platform                str
    prefix                  str
    py3kwarning             bool
    setcheckinterval        func
    setprofile              func
    setrecursionlimit       func
    settrace                func
    stderr                  file
    stdin                   file
    stdout                  file
    subversion              tuple
    version                 str
    version_info            tuple
    warnoptions             list
    winver                  str

Changes in python 2.7.2 (+ means additions):
    float_info              sys.float_info
  + mercurial               tuple
  + float_repr_style        str
  + long_info               sys.long_info
    version_info            sys.version_info

Changes in python 3.2.2
    __stderr__              _io.TextIOWrapper
    __stdin__               _io.TextIOWrapper
    __stdout__              _io.TextIOWrapper
  + _mercurial              tuple
  + _xoptions               dict
  - exc_clear               func
  - exc_type                NoneType
    float_info              sys.float_info
  + float_repr_style        str
  + getswitchinterval       func
  + hash_info               sys.hash_info
  - maxint                  int
  + int_info                sys.int_info
  + intern                  func
  - py3kwarning             bool
  + setswitchinterval       func
    stderr                  _io.TextIOWrapper
    stdin                   _io.TextIOWrapper
    stdout                  _io.TextIOWrapper
    version_info            sys.version_info

-----------------------------------------------------------------------------
math                                                    *python_math*

+ marks functions also in cmath for complex numbers

  + acos(x)         Inverse cosine 
  + acosh(x)        Inverse hyperbolic cosine
  + asin(x)         Inverse sine
  + asinh(x)        Inverse hyperbolic sine
  + atan(x)         Inverse tangent
  + atanh(x)        Inverse hyperbolic tangent
    atan2(y, x)     Inverse tangent & gets quadrant right; between -pi & pi
    ceil(x)         Smallest integer >= x
    copysign(x, y)  Return x with the sign of y
  + cos(x)          Cosine
  + cosh(x)         Hyperbolic cosine
    degrees(x)      Converts x in radians to degrees
  + e
    erf(x)          Error function:  normal CDF: 1 + erf(x/sqrt(2))/2
    erfc(x)         Complementary error function = 1 - erf(x)
  + exp(x)          e**x
    expm1(x)        e**x - 1 to full precision for small x
    fabs(x)         |x|
    factorial(x)    Must be integer >= 0
    floor(x)        Largest integer <= x
    fmod(x, y)      x - n*y for some integer n
    frexp(x)        (m, e) such that x = m*2**e exactly
    fsum(iterable)  Acurrately sum an iterable
    gamma(x)        Gamma function
    gcd(a, b)       Greatest common divisor
    hypot(x, y)     sqrt(x**2 + y**2)
    inf             Floating point positive infinity
  + isclose(a, b, *, rel_tol=1e-9, abs_tol=0.0)
  + isfinite(x)     True if x not infinity or NaN
  + isinf(x)        True if infinite
  + isnan(x)        True if NaN
    ldexp(x, i)     Return x*(2**i)  (inverse of frexp())
    lgamma(x)       ln(Gamma(abs(x)))
  + log(x[, base])  Logarithm to indicated base (e by default)
  + log10(x)        Logarithm to base 10
    log1p(x)        Natural logarithm of 1 + x (accurate for x near zero)
    log2(x)         Base 2 log of x (more accurate than log(x, 2))
    modf(x)         Return (fractional_part, integer_part); each floats
    nan             Floating point not a number == float('nan')
  + pi
    pow(x, y)       Raise x to the y power
    radians(x)      Converts x in degrees to radians
    remainder(x, y) x - n*y where n is the int closes to x/y (nearest even int)
  + sin(x)          Sine
  + sinh(x)         Hyperbolic sine
  + sqrt(x)         Square root
  + tan(x)          Tangent
  + tanh(x)         Hyperbolic tangent
    tau             2*pi
    trunc(x)        Truncate x to an integer

*python_cmath* also includes the following:
    infj                == complex(0, float('inf'))
    nanj                == complex(0, float('nan'))
    phase(x)            Arg(x)
    polar(x)            (r, theta) = (abs(x), phase(x))
    rect((r, theta)     Rectangular (x, y)

-----------------------------------------------------------------------------
pickle             *python_pickle*
------

The pickle module is used to persist objects to the file system.  I find
the module's documentation poor and I have had trouble getting object
instances to pickle using dump and load.  See the example, which uses dumps
and loads.

What can be pickled
    - Classes that are defined at the top level of a module 
    - None, True, and False
    - Numbers:  integers, long integers, floating point numbers,
      complex numbers 
    - Normal and Unicode strings 
    - tuples, lists, sets, and dictionaries containing only picklable
      objects 
    - Functions defined at the top level of a module 
    - Built-in functions defined at the top level of a module 
    - Instances of such classes whose __dict__ or __setstate__() is
      picklable.

Example

    This example shows how a class instance was pickled to disk.  Set X to
    True to write to disk, then to False to read it back.

        X = True

        class A:
            def __init__(self):
                self.me = "Hello "
                self.count = 89
            def __str__(self):
                return f"  A instance:  {self.me + str(self.count)!r}"
        a = A()
        print("Initial state:")
        print(a)
        if X:
            # Write out a modified instance
            a.me = "Goodbye "
            a.count = -33
            with open("aa", "wb") as f:
                pickle.dump(a, f))
            print("Modified instance that was pickled:")
            print(a)
        else:
            with open("aa", "rb") as f:
                a1 = pickle.load(f)
            print("Instance unpickled from file:")
            print(a1)

    When written, you should get
        Initial state:
          A instance:  'Hello 89'
        Modified instance that was pickled:
          A instance:  'Goodbye -33'
    When read back from disk, you should get
        Initial state:
          A instance:  'Hello 89'
        Instance unpickled from file:
          A instance:  'Goodbye -33'

-----------------------------------------------------------------------------
Threads             *python_threads*            Pg 177 Beazley
-------

Utility functions
    activeCount()        Number of active Thread objects
    currentThread()      Returns Thread object corresponding to caller's
                         thread of control
    enumerate()          Return list of all active thread objects

Thread objects
    Thread(group=None, target=None, name=None, args=(), kwargs={})
        Create a new thread instance.  target is a callable object invoked
        by the run() method when thread starts.  name is thread name.
        args is a tuple of arguments passed to the target function.
        kwargs is a dictionary of keyword arguments passed to target.

    t.start()           Start the thread.
    t.run()             This method is called when the thread starts.
                        YOU SHOULDN'T CALL run YOURSELF.
    t.join([timeout])   Wait until thread terminates or a timeout occurs.
                        timout is a float in seconds.
    t.getName()         Return the thread name.
    t.isAlive()         Returns 1 if thread is alive.  It's alive when
                        the start() method returns and until run()
                        terminates.

How to get atomic behavior:
    # main code here
    try:
        sys.setcheckinterval(sys.maxint)
        # Statements in this block run atomically
    finally:
        sys.setcheckinterval(100)
    # Rest of code here

    In python 2.5, you can use

        with other_threads_suspended():
            print(somevalue)

Example
        ''' This code demonstrates a main thread and a processing
        thread.  The two communicate/sequence their operations with
        two queues to avoid messing up prompting and output.
        '''
        from threading import Thread
        from Queue import Queue
        from sys import argv
        def ProcessStream(stream, outq, okq):
            while stream:
                line = stream.readline()
                if line == "": break
                if line != None: outq.put(line.strip())
                else:  break
                okq.get(block=True)
        class InteractiveStream(object):
            prompt = "+> "
            def __init__(self):
                self.closed = False
            def readline(self):
                if not self.closed:
                    s = raw_input(InteractiveStream.prompt)
                    if s == "q\n":
                        self.closed = True
                        return ""
                    else:
                        return s
        outq = Queue()
        okq = Queue()
        stream = InteractiveStream()
        t = Thread(name="process_stream",
                    target=ProcessStream,
                    args=(stream, outq, okq))
        t.start()
        while True:
            s = outq.get(block=True)
            if s == "q":
                break
            if s:
                print(s)
                s = ""
            okq.put("")
        stream.closed = True
        okq.put("")
        print("Got a quit")

Lock objects
    Lock()              Create a new lock, initially unlocked.
        l.acquire([blocking = 1])
            Acquire the lock, blocking until lock is released.  If blocking
            was 0, the call immediately returns with a value of 0 if the
            lock couldn't be acquired and 1 if it could.
        l.release()
            Release the lock.

    RLock()
        Similar to Lock(), but can be acquired multiple times by the same
        thread.

    Semaphore([value])  Create a new semaphore with given value.  value
                        defaults to 1.
        s.acquire([blocking = 1]
            If internal counter > 0, decrement it by 1 and return immediately.
            If internal counter == 0, block until another thread calls
            release().
        s.release()
            Release by incrementing the internal counter.  If the count is
            zero and another thread is waiting, the thread is awakened.

Events
    Used to communicate between threads.  One thread signals an event and
    the other threads wait for it.  An Event instance manages an internal
    flag that can be set to true with the set() method and set to false
    with the clear() method.  The wait() method blocks until the flag
    is true.

    Event()
        Creates a new instance with internal flag set to false.

    e.isSet()           Return true if internal flag is true.
    e.set()             Set internal flag to true.
    e.clear()           Set internal flag to false.
    e.wait([timeout])   Block until internal flag is true. If internal
                        flag is true, returns immediately.  timeout is
                        float in seconds; wait that long.

-----------------------------------------------------------------------------
Logging                                                 *python_logging*

Simple example:
    import logging

    logging.info("Starting...")
    logging.warn("Nothing to do!")
    logging.info("Done...")

When you run app.py, the results are:

2002-03-15 01:09:10,440 root                INFO  - Starting...
2002-03-15 01:09:10,440 root                WARN  - Nothing to do!
2002-03-15 01:09:10,440 root                INFO  - Done...

Another use:

    # --- mymodule.py -------------------
    import logging
    log = logging.getLogger("MyModule")

    def doIt():
        log.debug("doin' stuff")
        #do stuff...but suppose an error occurs?
        raise TypeError, "bogus type error for testing"

    # --- myapp.py ----------------------
    import logging, mymodule

    logging.basicConfig() # basic configuration - console output

    log = logging.getLogger("MyApp")

    log.info("start my app")
    try:
        mymodule.doIt()
    except Exception, e:
        log.exception("There was a problem doin' stuff.")
    log.info("end my app")

When you run myapp.py, the results are:

2002-03-14 23:40:49,299 MyApp               INFO  - start my app
2002-03-14 23:40:49,299 MyModule            DEBUG - doin' stuff
2002-03-14 23:40:49,299 MyApp               ERROR - There was a problem doin' stuff.
Traceback (innermost last):
  File "myapp.py", line 9, in ?
    mymodule.doIt()
  File "mymodule.py", line 7, in doIt
    raise TypeError, "bogus type error for testing"
TypeError: bogus type error for testing
2002-03-14 23:40:49,409 MyApp               INFO  - end my app

-----------------------------------------------------------------------------
wconio                                              *python_wconio*

wconio -- Windows console I/O for Python
http://newcenturycomputers.net/projects/wconio.html
	
Screen coordinates are based at 0, 0

WConio.error (aka _WConio.error) is thrown for exceptions special to
this module.

Module functions
----------------

cgets(length)       gets (and echos) a string up to length characters
                    long. Minimal editing (basically backspace).

clreol()            clears from the cursor position to the end of the
                    line.

clrscr()            clears the screen and homes the cursor.

cputs(string)       prints a string starting at the current cursor
                    position. Some control characters are handled, but
                    unlike the traditional version '\n' doesn't drop a
                    line in the same column, instead it acts like
                    '\r\n'.

delline()           remove a line at the current cursor position,
                    scrolling the lower part of the frame up.

getch()             retrieves a keystroke from the console, returning a
                    tuple of (number, string) containing the numeric
                    and character values for the key hit. getch() does
                    not echo, and delays until a key is available. If
                    the key hit has no character representation a null
                    string ('') is returned. Note that special keys
                    will arrive in two steps, either a null byte
                    followed by a scancode or 0340 followed by a scan
                    code for gray keys.

getche()            works exactly like getch(), but if the key read is
                    printable it is echoed.

getkey()            returns a single string value, with special names
                    for non-ascii keys. Valid keynames are:

        f1    altf1     ctrlf1    shiftf1   ins     altins    ctrlins
        f2    altf2     ctrlf2    shiftf2   del     altdel    ctrldel
        f3    altf3     ctrlf3    shiftf3   end     altend    ctrlend
        f4    altf4     ctrlf4    shiftf4   down    altdown   ctrldown
        f5    altf5     ctrlf5    shiftf5   pgdn    altpgdn   ctrlpgdn
        f6    altf6     ctrlf6    shiftf6   left    altleft   ctrlleft
        f7    altf7     ctrlf7    shiftf7   right   altright  ctrlright
        f8    altf8     ctrlf8    shiftf8   home    althome   ctrlhome
        f9    altf9     ctrlf9    shiftf9   up      altup     ctrlup
        f10   altf10    ctrlf10   shiftf10  pgup    altpgup   ctrlpgup

gettext(left, top, right, bottom)
                    copies characters and attributes from the screen
                    coordinates given and returns them in a string buffer.
                    Usually used with puttext() below. 
 
  !!! DO NOT PRINT THIS BUFFER TO THE SCREEN AS YOU WILL HANG THE SHELL. !!!

gettextinfo()       returns a tuple of display information:
                    (L, T, R, B, ta, na, vmode, H, W, x, y)
                     0  1  2  3  4   5   6      7  8  9  10

                    L, R = left, right window coordinates
                    T, B = top, bottom window coordinates
                    ta, na = textattr, normattr current attibutes
                        Note:  fg is in lower nybble, bg in upper
                        fg = ta & 0x0f
                        Bg = (ta & 0xf0) >> 4
                    vmode = current video mode
                    H, W = height, width: screen size
                    x, y = current cursor position

                    Some information is faked.

gotoxy(x, y)        positions the cursor at the given coordinates.

highvideo()         activates bold (bright) video mode.

insline()           inserts a blank line at the current position,
                    scrolling down the rest of the screen.

kbhit()             returns true if a keystroke is in the buffer, false
                    otherwise. If it returns true, getch()/getkey()
                    won't block.

lowvideo()          activates low intensity (dim) video mode.

movetext(left, top, right, bottom, x, y)
                    moves the given text region to the new x, y position.

normvideo()         activates normal intensity video mode.
                    Equal to lowvideo().

putch(ch)           expects either a numeric or single-character string
                    and prints it at the current position.

puttext(left, top, right, bottom, saved)
                    puts the given saved text block on the screen at
                    the given coordinates. The left, top, right,
                    bottom coordinates should *probably* match the
                    geometry of the similar coordinates used in the
                    gettext() call.

setcursortype(n)    changes the appearance of the text-mode
                    cursor. The values for n are 0 for no cursor, 1
                    for normal cursor, 2 for block cursor.

settitle(s)         sets the console title to the given string. The
                    string must not have any embedded null bytes.
                    (This is another of my contributions.)

textattr(attr)      changes the text attribute (color) for new text.
                    The data value is formatted with the foreground
                    color in the lower nibble, and the background
                    color in the upper. This differs from the
                    traditional version in that blinking is not
                    available, but high-intensity backgrounds are
                    available. See below for the color constants.

textbackground(color)
                    sets the background color without changing the
                    foreground. See below for the color constants.

textcolor(color)    sets the foreground color without changing the
                    background. See below for the color constants.

textmode()          resets default video mode, clears the screen, homes
                    the cursor, and puts the cursor shape back to normal.

ungetch(ch)         pushes a keystroke back into the keyboard buffer.
                    ch may be either an integer value or one-character
                    string. Only one byte can be pushed back this way;
                    that means that special keys can't be pushed,
                    since they involve a two-byte sequence.

wherex()            returns the current cursor x position.

wherey()            returns the current cursor y position.

WConio.File is a file-like object implementing both reading and
writing to the console. This is a handy shim when used with "plumbers
helper's" like NWayOutput.py and Logger.py; see my project home page
to download these.
    Use as:
        f = w.File
        f.write("hi there\n")

Color names defined in module:
    BLACK        RED          LIGHTGRAY    LIGHTGREEN   LIGHTMAGENTA
    BLUE         MAGENTA      DARKGRAY     LIGHTCYAN    YELLOW
    GREEN        BROWN        LIGHTBLUE    LIGHTRED     WHITE
    CYAN

Example:
    import wconio as w

    w.clrscr()
    ti = w.gettextinfo()
    height, width = ti[-4], ti[-3]

    for line in range(height):
        w.gotoxy(0, line)
        w.cputs("%d" % line)
    w.getch()

    f = w.File
    f.write("hi there\n")
    f.write("hi there\n")

-----------------------------------------------------------------------------
Exceptions                                              *python_exceptions*

To find out if something X is in the exception hierarchy, use
    issubclass(X, BaseException)

Exceptions 3.10.5 (see Library/Built-in Exceptions/Exception hierarchy)

BaseException
    - SystemExit
    - KeyboardInterrupt
    - GeneratorExit
    - Exception
        - StopIteration
        - StopAsyncIteration
        - ArithmeticError
            - FloatingPointError
            - OverflowError
            - ZeroDivisionError
        - AssertionError
        - AttributeError
        - BufferError
        - EOFError
        - ImportError
            - ModuleNotFoundError
        - LookupError
            - IndexError
            - KeyError
        - MemoryError
        - NameError
            - UnboundLocalError
        - OSError
            - BlockingIOError
            - ChildProcessError
            - ConnectionError
               - BrokenPipeError
               - ConnectionAbortedError
               - ConnectionRefusedError
               - ConnectionResetError
            - FileExistsError
            - FileNotFoundError
            - InterruptedError
            - IsADirectoryError
            - NotADirectoryError
            - PermissionError
            - ProcessLookupError
            - TimeoutError
        - ReferenceError
        - RuntimeError
            - NotImplementedError
            - RecursionError
        - SyntaxError
            - IndentationError
                - TabError
        - SystemError
        - TypeError
        - ValueError
            - UnicodeError
                - UnicodeDecodeError
                - UnicodeEncodeError
                - UnicodeTranslateError
        - Warning
            - DeprecationWarning
            - PendingDeprecationWarning
            - RuntimeWarning
            - SyntaxWarning
            - UserWarning
            - FutureWarning
            - ImportWarning
            - UnicodeWarning
            - BytesWarning
            - EncodingWarning
            - ResourceWarning

-----------------------------------------------------------------------------
Strings and the string module                        *python_string_stuff*

To read in text from a file and not have the newlines like happens
with readline, use:

    lines = open(name).read().splitlines()

String methods (see below for more details)
    capitalize()
    center(width[, fillchar])
    count(sub[, start[, end]])          Count nonoverlapping substrings
    decode([encoding[, errors]])
    encode([encoding[, errors]])
    endswith(suffix[, start[, end]])    Returns boolean
    expandtabs([tabsize])
    find(sub[, start[, end]])
    format(format_string, *args, **kwargs)
    index(sub[, start[, end]])      Like find, but raise ValueError if not found
 *  iaslnum()
 *  isalpha()
 *  isdigit()
 *  islower()
 *  isspace()
 *  istitle()
 *  isupper()
    join(iterable)
    ljust(width[, fillchar])
 *  lower()
    lstrip([chars])
    partition(sep)                  "a|b|c".partition("|") --> ("a", "|", "b|c")
    replace(old, new[, count])
    rfind(sub[, start[, end]])
    rindex(sub[, start[, end]])
    rjust(width[, fillchar])
    rpartition(sep)                 "a|b|c".partition("|") --> ("a|b", "|", "c")
    rsplit([sep[, maxsplit]])           Split from the right
    rstrip([chars])
    split([sep[, maxsplit]])
    splitlines([keepends])              Return list; break at newlines (not kept)
    startswith(prefix[, start[, end]])  Returns boolean
    strip([chars])
 *  swapcase()
 *  title()
    translate(table[, deletechars])     + See below
 *  upper()
    zfill(width)

* means locale dependent

+ Python 3:  see http://stackoverflow.com/questions/17020661/why-doesnt-str-translate-work-in-python-3
    The keys are the ordinals of the characters:
        'a'.translate({ord('a'): 'b'})
    It's better to use str.maketrans:
        'a'.translate(str.maketrans('a', 'b'))
    >>> help(str.translate)
      translate(...)
        S.translate(table) -> str

        Return a copy of the string S, where all characters have been mapped
        through the given translation table, which must be a mapping of
        Unicode ordinals to Unicode ordinals, strings, or None.  Unmapped
        characters are left untouched. Characters mapped to None are deleted.

    Here's an example:

        def remove(chars, d={}):
            '''Returns a function that will remove the indicated characters
            from a string.
            '''
            for i in set(chars):
                d[ord(i)] = None
            return lambda x: x.translate(d)

String constants (attributes)
    ascii_letters
    ascii_lowercase
    ascii_uppercase
    digits
    hexdigits
    letters             *
    lowercase           *
    octdigits
    punctuation
    printable
    uppercase           *
    whitespace

String formatting
    format(format_string, *args, **kwargs)

    Examples:

    "{hello} {there}".format(**locals())
    "Count to {0}".format(3)
    "Count to {a}".format(**{"a":3})
    "Weight is {0.weight}"
        Uses weight attribute of first positional object
    "Units destroyed:  {players[0]}"
        First element of keyword argument 'players'
    "Count to {0!s}".format(3)
        Calls str() on the argument first (!r calls repr())
    "A man with two {0:{1}}".format("noses", 10)
        Results in "A man with two noses      "

Format specifier grammar:
    format_spec ::= [[fill]align][sign][#][0][width][.precision][type]
    fill        ::= <a character other than '}'>
    align       ::= < | > | = | ^
    sign        ::= + | - | space_char
    width       ::= integer
    precision   ::= integer
    type        ::= b | c | d | e | E | f | F | g | G | n | o | x | X

    Alignment:
        <   Left aligned (default)
        >   Right aligned
        =   Pad after sign but before digits (e.g. +0000000120)
        ^   Center within available space

    # specifies 0b, 0o, or 0x for integers

    If width is preceded by 0, zero-padding is enabled

    Types for integers:
        b   Base 2 output
        c   Character
        d   Decimal integer
        o   Octal
        x   Hex in lowercase letters
        X   Hex in uppercase letters
        n   Number; same as d but uses locale to insert separators
        None is same as d
    Types for floating point:
        e   Exponent with 'e'
        E   Exponent with 'E'
        f   Fixed point
        F   Same as f
        g   Fixed point; switch to e if too large
        G   Same as g except use E
        n   Same as g except insert separators per locale
        %   Multiplies number by 100 and displays in f format followed by '%'

Formatted string literals (new in python 3.6)
    If 
        x = 3.4
    then a formatted string literal is
        print(f"The value is {x}.")
    This the same as 
        print("The value is {x}.".format(x))

    Note the portion inside the curly braces can be any expression and is
    effectively first surrounded by parentheses, allowing you to include
    newlines if desired.  The expression is evaluated at runtime.

    You can also have raw formatted string literals.

Template strings
        Note:  the feature of template strings are rarely used compared to
        the use of str.format().  If you can use >= python 3.6, you should
        use formatted string literals.

    Uses $identifier for string interpolation.  Use $$ for literal $.
    ${identifier} when followed by more identifier characters that
    shouldn't be included in identifier name.

    from string import Template
    s = Template("$who likes $what")
    print(s.substitute(who="tim", what="kung pao"))
        --> 'tim likes kung pao'
    d = dict(who='tim')
    Template("$who likes $what).safe_substitute(d)
        --> 'tim likes $what'

More details on methods (both 8 bit strings and Unicode objects support these)

capitalize()
    Return copy with character capitalized.

center(width[, fillchar])
    Return centered in a string of length width. Padding is done using
    the specified fillchar (default is a space). Changed in version
    2.4: Support for the fillchar argument.

count(sub[, start[, end]])
    Return the number of occurrences of substring sub in string
    S[start:end]. Optional arguments start and end are interpreted as
    in slice notation.

decode([encoding[, errors]])
    Decodes the string using the codec registered for encoding.
    encoding defaults to the default string encoding. errors may be
    given to set a different error handling scheme. The default is
    'strict', meaning that encoding errors raise UnicodeError. Other
    possible values are 'ignore', 'replace' and any other name
    registered via codecs.register_error. New in version 2.2. Changed
    in version 2.3: Support for other error handling schemes added.

encode([encoding[,errors]])
    Return an encoded version of the string. Default encoding is the
    current default string encoding. errors may be given to set a
    different error handling scheme. The default for errors is
    'strict', meaning that encoding errors raise a UnicodeError. Other
    possible values are 'ignore', 'replace', 'xmlcharrefreplace',
    'backslashreplace' and any other name registered via
    codecs.register_error. For a list of possible encodings, see
    section 4.9.2. New in version 2.0. Changed in version 2.3: Support
    for 'xmlcharrefreplace' and 'backslashreplace' and other error
    handling schemes added.

endswith(suffix[, start[, end]])
    Return True if the string ends with the specified suffix,
    otherwise return False. With optional start, test beginning at
    that position. With optional end, stop comparing at that position.

expandtabs([tabsize])
    Return a copy of the string where all tab characters are expanded
    using spaces. If tabsize is not given, a tab size of 8 characters
    is assumed.

find(sub[, start[, end]])
    Return the lowest index in the string where substring sub is
    found, such that sub is contained in the range [start, end).
    Optional arguments start and end are interpreted as in slice
    notation. Return -1 if sub is not found.

index(sub[, start[, end]])
    Like find(), but raise ValueError when the substring is not found.

isalnum()
    Return true if all characters in the string are alphanumeric and
    there is at least one character, false otherwise.

isalpha()
    Return true if all characters in the string are alphabetic and
    there is at least one character, false otherwise.

isdigit()
    Return true if all characters in the string are digits and there
    is at least one character, false otherwise.

islower()
    Return true if all cased characters in the string are lowercase
    and there is at least one cased character, false otherwise.

isspace()
    Return true if there are only whitespace characters in the string
    and there is at least one character, false otherwise.

istitle()
    Return true if the string is a titlecased string and there is at
    least one character, for example uppercase characters may only
    follow uncased characters and lowercase characters only cased
    ones. Return false otherwise.

isupper()
    Return true if all cased characters in the string are uppercase
    and there is at least one cased character, false otherwise.

join(seq)
    Return a string which is the concatenation of the strings in the
    sequence seq. The separator between elements is the string
    providing this method.

ljust(width[, fillchar])
    Return the string left justified in a string of length width.
    Padding is done using the specified fillchar (default is a space).
    The original string is returned if width is less than len(s).
    Changed in version 2.4: Support for the fillchar argument.

lower()
    Return a copy of the string converted to lowercase.

lstrip([chars])
    Return a copy of the string with leading characters removed. The
    chars argument is a string specifying the set of characters to be
    removed. If omitted or None, the chars argument defaults to
    removing whitespace. The chars argument is not a prefix; rather,
    all combinations of its values are stripped:

    >>> '   spacious   '.lstrip()
    'spacious   '
    >>> 'www.example.com'.lstrip('cmowz.')
    'example.com'

replace(old, new[, count])
    Return a copy of the string with all occurrences of substring old
    replaced by new. If the optional argument count is given, only the
    first count occurrences are replaced.

rfind(sub [,start [,end]])
    Return the highest index in the string where substring sub is
    found, such that sub is contained within s[start,end]. Optional
    arguments start and end are interpreted as in slice notation.
    Return -1 on failure.

rindex(sub[, start[, end]])
    Like rfind() but raises ValueError when the substring sub is not
    found.

rjust(width[, fillchar])
    Return the string right justified in a string of length width.
    Padding is done using the specified fillchar (default is a space).
    The original string is returned if width is less than len(s).
    Changed in version 2.4: Support for the fillchar argument.

rsplit([sep [,maxsplit]])
    Return a list of the words in the string, using sep as the
    delimiter string. If maxsplit is given, at most maxsplit splits
    are done, the rightmost ones. If sep is not specified or None, any
    whitespace string is a separator. Except for splitting from the
    right, rsplit() behaves like split() which is described in detail
    below. New in version 2.4.

rstrip([chars])
    Return a copy of the string with trailing characters removed. The
    chars argument is a string specifying the set of characters to be
    removed. If omitted or None, the chars argument defaults to
    removing whitespace. The chars argument is not a suffix; rather,
    all combinations of its values are stripped:

    >>> '   spacious   '.rstrip()
    '   spacious'
    >>> 'mississippi'.rstrip('ipz')
    'mississ'

split([sep [,maxsplit]])
    Return a list of the words in the string, using sep as the
    delimiter string. If maxsplit is given, at most maxsplit splits
    are done. (thus, the list will have at most maxsplit+1 elements).
    If maxsplit is not specified, then there is no limit on the number
    of splits (all possible splits are made). Consecutive delimiters
    are not grouped together and are deemed to delimit empty strings
    (for example, "'1,,2'.split(',')"returns "['1', '', '2']"). The
    sep argument may consist of multiple characters (for example, "'1,
    2, 3'.split(', ')" returns "['1', '2', '3']"). Splitting an empty
    string with a specified separator returns "['']".

    If sep is not specified or is None, a different splitting
    algorithm is applied. First, whitespace characters (spaces, tabs,
    newlines, returns, and formfeeds) are stripped from both ends.
    Then, words are separated by arbitrary length strings of
    whitespace characters. Consecutive whitespace delimiters are
    treated as a single delimiter ("'1 2 3'.split()" returns "['1',
    '2', '3']"). Splitting an empty string or a string consisting of
    just whitespace returns an empty list.

splitlines([keepends])
    Return a list of the lines in the string, breaking at line
    boundaries. Line breaks are not included in the resulting list
    unless keepends is given and true.

startswith(prefix[, start[, end]])
    Return True if string starts with the prefix, otherwise return
    False. With optional start, test string beginning at that
    position. With optional end, stop comparing string at that
    position.

strip([chars])
    Return a copy of the string with the leading and trailing
    characters removed. The chars argument is a string specifying the
    set of characters to be removed. If omitted or None, the chars
    argument defaults to removing whitespace. The chars argument is
    not a prefix or suffix; rather, all combinations of its values are
    stripped:

    >>> '   spacious   '.strip()
    'spacious'
    >>> 'www.example.com'.strip('cmowz.')
    'example'

swapcase()
    Return a copy of the string with uppercase characters converted to
    lowercase and vice versa.

title()
    Return a titlecased version of the string: words start with
    uppercase characters, all remaining cased characters are
    lowercase.

translate(table[, deletechars])
    Return a copy of the string where all characters occurring in the
    optional argument deletechars are removed, and the remaining
    characters have been mapped through the given translation table,
    which must be a string of length 256.

        'read this short text'.translate(None, 'aeiou')
    gives
        'rd ths shrt txt'

    For Unicode objects, the translate() method does not accept the
    optional deletechars argument. Instead, it returns a copy of the s
    where all characters have been mapped through the given
    translation table which must be a mapping of Unicode ordinals to
    Unicode ordinals, Unicode strings or None. Unmapped characters are
    left untouched. Characters mapped to None are deleted. Note, a
    more flexible approach is to create a custom character mapping
    codec using the codecs module (see encodings.cp1251 for an
    example).

upper()
    Return a copy of the string converted to uppercase.

zfill(width)
    Return the numeric string left filled with zeros in a string of
    length width. The original string is returned if width is less
    than len(s). New in version 2.2.2.

-----------------------------------------------------------------------------
Itertools                                           *python_itertools*

The itertools module provides many powerful and efficient constructs for
iteration.  See http://docs.python.org/dev/howto/functional.html for some
introductory material.  Also see:
    http://oakwinter.com/code/functional/index.html
    http://oakwinter.com/code/functional/documentation/cookbook.html

Infinite iterators
    count(start)            count(10) --> 10 11 12 13 14 ...
    cycle(p)                cycle('ABCD') --> A B C D A B C D ...
    repeat(elem[, n])       repeat(10, 3) --> 10 10 10

Iterators terminating on the shortest input sequence:
    chain('ABC', 'DEF') --> A B C D E F
    dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1
    takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4
    groupby(iterable[, keyfunc])
    ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9
    ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8
    islice('ABCDEFG', 2, None) --> C D E F G
    imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000
    starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000
    izip('ABCD', 'xy') --> Ax By
    izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
    tee(iterable, n) --> return n independent iterators  Note:  may require
        significant auxiliary storage; if one iterator consumes most of the
        data before another starts, use list() instead of tee().  Don't use
        original iterable, as tee'd items won't be notified of updates.

Combinatoric
    product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD
    permutations('ABCD', 2)   AB AC AD BA BC BD CA CB CD DA DB DC
    combinations('ABCD', 2)   AB AC AD BC BD CD

Note:  you may also want to utilize some of these tools with the functools
module's partial tool:

    partial(func[, *args][, **keywords])
        Return a new partial object which when called will behave
        like func called with the positional arguments args and keyword
        arguments keywords. If more arguments are supplied to the call,
        they are appended to args. If additional keyword arguments are
        supplied, they extend and override keywords.

    Example:
        >>> basetwo = partial(int, base=2)
        >>> basetwo.__doc__ = 'Convert base 2 string to an int.'
        >>> basetwo('10010')
        18


iter() built-in:
    Use it to create iterators that retain state info:
        a = range(10)
        L = iter(a)
        for i in L:
            if i > 4:
                break
            print(i)
        print("Picking up where we left off:")
        for i in L:
            print(i)

Examples
--------

1.  Grouping

    from itertools import groupby
    from operator import itemgetter

    def summary(data, key=itemgetter(0), value=itemgetter(1)):
        """Summarise the supplied data.

           Produce a summary of the data, grouped by the given key
           (default: the first item), and giving totals of the given value
           (default: the second item).

           The key and value arguments should be functions which, given a data
           record, return the relevant value.
        """

        for k, group in groupby(data, key):
            yield (k, sum(value(row) for row in group))

    if __name__ == "__main__":
        # Example: given a set of sales data for city within region,
        # produce a sales report by region
        sales = [('Scotland', 'Edinburgh', 20000),
                 ('Scotland', 'Glasgow', 12500),
                 ('Wales', 'Cardiff', 29700),
                 ('Wales', 'Bangor', 12800),
                 ('England', 'London', 90000),
                 ('England', 'Manchester', 45600),
                 ('England', 'Liverpool', 29700)]

        for region, total in summary(sales, key=itemgetter(0),
                                     value=itemgetter(2)):
            print("%10s: %d" % (region, total))

    Another example from http://docs.python.org/dev/howto/functional.html:

        city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),
                     ('Anchorage', 'AK'), ('Nome', 'AK'),
                     ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),
                     ...
                    ]

        def get_state ((city, state)):
            return state

        itertools.groupby(city_list, get_state) =>
          ('AL', iterator-1),
          ('AK', iterator-2),
          ('AZ', iterator-3), ...

        where
            iterator-1 =>
              ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')
            iterator-2 =>
              ('Anchorage', 'AK'), ('Nome', 'AK')
            iterator-3 =>
              ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')

    groupby() assumes that the underlying iterable's contents will already
    be sorted based on the key. Note that the returned iterators also use
    the underlying iterable, so you have to consume the results of
    iterator-1 before requesting iterator-2 and its corresponding key.

2.  Merging sorted sequences (http://code.activestate.com/recipes/141934/;
    note the last two don't work correctly)

    from heapq import heapify, heappop, heapreplace

    def merge(*ln):
        pqueue = []
        for i in map(iter, ln):
            try:
                pqueue.append((i.next(), i.next))
            except StopIteration:
                pass
        heapify(pqueue)
        while pqueue:
            val, it = pqueue[0]
            yield val
            try:
                heapreplace(pqueue, (it(), it))
            except StopIteration:
                heappop(pqueue)

3.  Grouping (http://code.activestate.com/recipes/439095/)

    def group(iterator, count):
        itr = iter(iterator)
        while True:
            yield tuple([itr.next() for i in range(count)])

    Example:
        print(list(group([0, 1, 2, 3, 4, 5, 6], 2)))
            --> [(0, 1), (2, 3), (4, 5)]

4.  Grouping a dictionary by values and showing sorted keys:

    from operator import itemgetter
    d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)
    di = sorted(d.iteritems(), key=itemgetter(1))
    for k, g in groupby(di, key=itemgetter(1)):
        print(k, map(itemgetter(0), g))
    -->
    1 ['a', 'c', 'e']
    2 ['b', 'd', 'f']
    3 ['g']

5.  An annoyance of ''.join() is that it requires the list argument to
    already contain strings.  Ideally, it would call str() on each item.
    Using the functional module, here's a way to do it:

        from functional import partial, compose
        join = compose("".join, partial(map, str))

    If you want to be able to vary the separator, put it into a function
    factory:
        def get_join(sep):
            return compose(sep.join, partial(map, str))

Recipes
-------

This section shows recipes for creating an extended toolset using the
existing itertools as building blocks.

The extended tools offer the same high performance as the underlying
toolset. The superior memory performance is kept by processing elements one
at a time rather than bringing the whole iterable into memory all at once.
Code volume is kept small by linking the tools together in a functional
style which helps eliminate temporary variables. High speed is retained by
preferring "vectorized" building blocks over the use of for-loops and
generators which incur interpreter overhead.

def take(n, iterable):
    "Return first n items of the iterable as a list"
    return list(islice(iterable, n))

def enumerate(iterable, start=0):
    return izip(count(start), iterable)

def tabulate(function, start=0):
    "Return function(0), function(1), ..."
    return imap(function, count(start))

def consume(iterator, n):
    "Advance the iterator n-steps ahead. If n is none, consume entirely."
    collections.deque(islice(iterator, n), maxlen=0)

def nth(iterable, n, default=None):
    "Returns the nth item or a default value"
    return next(islice(iterable, n, None), default)

def quantify(iterable, pred=bool):
    "Count how many times the predicate is true"
    return sum(imap(pred, iterable))

def padnone(iterable):
    """Returns the sequence elements and then returns None indefinitely.

    Useful for emulating the behavior of the built-in map() function.
    """
    return chain(iterable, repeat(None))

def ncycles(iterable, n):
    "Returns the sequence elements n times"
    return chain.from_iterable(repeat(iterable, n))

def dotproduct(vec1, vec2):
    return sum(imap(operator.mul, vec1, vec2))

def flatten(listOfLists):
    "Only works for one level of nesting"
    return list(chain.from_iterable(listOfLists))

def repeatfunc(func, times=None, *args):
    """Repeat calls to func with specified arguments.

    Example:  repeatfunc(random.random)
    """
    if times is None:
        return starmap(func, repeat(args))
    return starmap(func, repeat(args, times))

def pairwise(iterable):
    "s -> (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)

def grouper(n, iterable, fillvalue=None):
    "grouper(3, 'ABCDEFG', 'x') --> ABC DEF Gxx"
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --> A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def compress(data, selectors):
    "compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F"
    return (d for d, s in izip(data, selectors) if s)

def combinations_with_replacement(iterable, r):
    "combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC"
    # number items returned:  (n+r-1)! / r! / (n-1)!
    pool = tuple(iterable)
    n = len(pool)
    if not n and r:
        return
    indices = [0] * r
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != n - 1:
                break
        else:
            return
        indices[i:] = [indices[i] + 1] * (r - i)
        yield tuple(pool[i] for i in indices)

def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --> A B C D
    # unique_everseen('ABBCcAD', str.lower) --> A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in iterable:
            if element not in seen:
                seen_add(element)
                yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element

def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --> A B C A D
    return imap(next, imap(itemgetter(1), groupby(iterable, key)))

def weave(*iterables):
    "Intersperse several iterables, until all are exhausted"
    iterables = map(iter, iterables)
    while iterables:
        for i, it in enumerate(iterables):
            try:
                yield it.next()
            except StopIteration:
                del iterables[i]

    -----------------------------------------------------------
    Example output of weave:
    for x in weave('abc', range(4), [10,11,12,13,14]):
       print(x, end="")

    --> a 0 10 b 1 11 c 2 12 13 3 14

-----------------------------------------------------------------------------
Object methods                                      *python_object_methods*

New style classes:
    class A(object)

Benefits:  unified object model, subclass built-in types, equivalent to a
user-defined type.

Basic

    __new__(cls[,...])
        Customize object creation.  This function is called before object
        creation and its responsibility is to create the object.  A major
        purpose of __new__ is to allow classes to inherit from immutable
        objects and add custom behavior.  Another use is to allow you to
        compute the actual class to be used.  Here's a simple example of a
        class that extends float to have a unit attribute:

            class P(float):
                def __new__(cls, myvalue, myunit):
                    # Create a new P instance and initialize the immutable 
                    # float component.
                    instance = float.__new__(cls, myvalue)
                    instance.unit = myunit
                    return instance
                def __str__(self):
                    return (str(float(self)) + " " + self.unit).strip()

            a = P(2.3, "lb")
            print(a)

        When run, it prints the string '2.3 lb'.

        If __new__ returns a cls instance, then __init__ is called with the
        same parameters as __new__.  This means, for example, thatt the above
        code could be perhaps more clearly written as 

            class P(float):
                def __new__(cls, myvalue, myunit):
                    return float.__new__(cls, myvalue)
                def __init__(self, myvalue, myunit):
                    print("In init")
                    self.unit = myunit
                def __str__(self):
                    return (str(float(self)) + " " + self.unit).strip()

    __init__(self[,...])
        Called when instance is created.  If the base class has an __init__
        method, the derived class' __init__ must explicitly call it.

    __del__(self)
        Destructor:  called when instance is about to be destroyed.  If the
        base class has a __del__ method, the derived class' __del__ must
        explicitly call it.

        Note that 'del x' doesn't call __del__ directly; it just decrements
        the reference count.

    __repr(self)
        Create the "official" string representation of an object.  Should
        return, if possible, something that could be used to reproduce the
        object via an expression.

    __str__(self)
        Create the "informal" string representation of an object.

    __lt__(self, other)
        Define this to be able to sort custom objects.
    __le__(self, other)
    __eq__(self, other)
    __ne__(self, other)
    __gt__(self, other)
    __ge__(self, other)
        Comparison operators.  Can return anything, but they are typically
        used in a Boolean context.

    __cmp__(self, other)
        Called by comparison operations if __lt__ etc. are not defined.
        Returns negative integer if self < other, 0 if self == other, and
        positive integer if self > other.

    __hash__(self)
        Returns an integer hash.  Do not define __hash__() without defining
        __cmp__ or __eq__.

    __nonzero__(self)
        Returns Boolean; if not defined, returns True.

    __unicode__(self)
        Returns a Unicode object.

Attribute access

    __getattr__(self, name)
    __setattr__(self, name, value)
    __delattr__(self, name)

    These three apply to old-style classes too.  For new style classes:

    __getattribute__(self, name)

Implementing descriptors

    __get__(self, instance, owner)
    __set__(self, instance, value)
    __delete__(self, instance)

__slots__
    By default, objects use dictionaries for attribute storage.  This is
    wasteful for objects with few instance variables (e.g. when creating
    lots of instances).

    Define the __slots__ variable as an iterable that returns string names
    of the attributes.  This reserves space for the attributes and prevents
    an attribute dict from being created.

Emulating callable objects

    __call__(self[, args...])
        Called when the instance is "called" as a function.  x(a, b) is a
        shorthand for x.__call__(a, b).

Emulating container types

    __len__(self)
        Returns an integer >= 0.

    __getitem__(self, key)
        Implements self[key].  Raise IndexError for inappropriate key.
        Raise TypeError for inappropriate key type.  If object is a mapping
        type, raise KeyError for key not in container.

    __setitem__(self, key, value)
        self[key] = value

    __delitem__(self, key)

    __iter__(self)
        Called when an iterator is required for a container.

    __reversed__(self)
        Called by reversed() built-in to implement reverse iteration.

    __contains__(self, item)
        Return True if item in container.  Normally, the 'in' and 'not in'
        membership test operators use iteration through the sequence.
        However, you can define __contains__ to make a more efficient
        implementation.

    __getslice__(self, i, j)
        Deprecated.  Implements evaluation of self[i,j].

    __setslice__(self, i, j, sequence)
        Implements assignment to self[i,j].

    __delslice__(self, i, j)
        Implements deletion of self[i,j].

Emulating numeric types (from 3.10.5 docs)

    Binary arithmetic to support:
        +          __add__(self, other)
        -          __sub__(self, other)
        *          __mul__(self, other)
        @          __matmul__(self, other)
        /          __truediv__(self, other)
        //         __floordiv__(self, other)
        %          __mod__(self, other)
        divmod()   __divmod__(self, other)
        pow(), **  __pow__(self, other[, modulo])
        <<         __lshift__(self, other)¶
        >>         __rshift__(self, other)
        &          __and__(self, other)
        ^          __xor__(self, other)
        |          __or__(self, other)

    Binary arithmetic with reflected (swapped) operands
        __radd__(self, other)
        __rsub__(self, other)
        __rmul__(self, other)
        __rmatmul__(self, other)
        __rtruediv__(self, other)
        __rfloordiv__(self, other)
        __rmod__(self, other)
        __rdivmod__(self, other)
        __rpow__(self, other[, modulo])
        __rlshift__(self, other)
        __rrshift__(self, other)
        __rand__(self, other)
        __rxor__(self, other)
        __ror__(self, other)

    Augmented (e.g. x *= 3) arithmetic assignments
        __iadd__(self, other)
        __isub__(self, other)
        __imul__(self, other)
        __imatmul__(self, other)
        __itruediv__(self, other)
        __ifloordiv__(self, other)
        __imod__(self, other)
        __ipow__(self, other[, modulo])
        __ilshift__(self, other)
        __irshift__(self, other)
        __iand__(self, other)
        __ixor__(self, other)
        __ior__(self, other)

    Unary operations
        __neg__(self) 
        __pos__(self) 
        __abs__(self) 
        __invert__(self) 

    Built-ins complex(), int(), and float()
        __complex__(self) 
        __int__(self) 
        __float__(self) 

    object.__index__(self)  
        Called to implement operator.index(), and whenever Python needs to
        losslessly convert the numeric object to an integer object (such as
        in slicing, or in the built-in bin(), hex() and oct() functions).
        Presence of this method indicates that the numeric object is an
        integer type. Must return an integer.

    object.__round__(self[, ndigits])
    object.__trunc__(self)
    object.__floor__(self)
    object.__ceil__(self)

        Called to implement the built-in function round() and math
        functions trunc(), floor() and ceil(). Unless ndigits is passed to
        __round__() all these methods should return the value of the object
        truncated to an Integral (typically an int).

Context manager types
    For use with the 'with' statement.

    __enter__(self)
    __exit__(self, exc_type, exc_value, traceback)

-----------------------------------------------------------------------------
unittest                                       *python_unittest*

Note:  I don't care for the use of the unittest module because it is
unfriendly to the develop/test/debug pattern.  This is because unittest
intercepts the standard streams so you cannot insert debugging statements or
drop into the debugger on an error (you can, but you have to modify the file
you're working on).  This is the major reason I wrote the lwtest.py module.

Typical pattern:

    class MyTests(unittest.TestCase):
        def __init__(self, methodName="my_tests"):
            unittest.TestCase.__init__(self, methodName)

        def testFeature(self):
            # Any method beginning with "test" is run as a test case.
            # Use methods such as:
            self.assertTrue(condition)
            self.assertFalse(condition)
            self.assertEqual(item1, item2)
            self.assertRaises(ValueError, function_to_call, arg1, ...)

    if __name__ == "__main__":
        suite = unittest.TestSuite()
        suite.addTest(unittest.makeSuite(MyTests))
        unittest.main()

unittest.TestCase methods (preferred forms are first):
 
    fail(msg=None) 
        Fail immediately.

    assertFalse(expr, msg=None)
    failIf(expr, msg=None)
        Fail the test if the expression is true.

    assertTrue(expr, msg=None)
    failUnless(expr, msg=None)
    assert_(expr, msg=None)
        Fail the test unless the expression is true.

    assertRaises(excClass, callableObj, *args, **kwargs)
    failUnlessRaises(excClass, callableObj, *args, **kwargs)
        Fail unless an exception of class excClass is thrown by
        callableObj when invoked with arguments args and keyword
        arguments kwargs. If a different type of exception is thrown,
        it will not be caught, and the test case will be deemed to
        have suffered an error, exactly as for an unexpected
        exception.
 
    assertEqual(first, second, msg=None)
    assertEquals(first, second, msg=None)
    failUnlessEqual(first, second, msg=None)
        Fail if the two objects are unequal as determined by the '=='
        operator.

    assertNotEqual(first, second, msg=None)
    assertNotEquals(first, second, msg=None)
    failIfEqual(first, second, msg=None)
        Fail if the two objects are equal as determined by the '=='
           operator.

    assertAlmostEqual(first, second, places=7, msg=None)
    assertAlmostEquals(first, second, places=7, msg=None)
    failUnlessAlmostEqual(first, second, places=7, msg=None)
        Fail if the two objects are unequal as determined by their
        difference rounded to the given number of decimal places
        (default 7) and comparing to zero.

        Note that decimal places (from zero) are usually not the same
        as significant digits (measured from the most signficant
        digit).

    assertNotAlmostEqual(first, second, places=7, msg=None)
    assertNotAlmostEquals(first, second, places=7, msg=None)
    failIfAlmostEqual(first, second, places=7, msg=None)
        Fail if the two objects are equal as determined by their
        difference rounded to the given number of decimal places
        (default 7) and comparing to zero.

        Note that decimal places (from zero) are usually not the same
        as significant digits (measured from the most signficant
        digit).

---------------------------------------------------------------------------
Uncertainties package                   *python_uncertainties*

from uncertainties import ufloat, UFloat
from uncertainties.umath import sin, cos, etc.

In the following, x = 0.20 +/- 0.01 can be expressed as

    x = ufloat((0.2, 0.01))
    x = ufloat("0.20+/-0.01")
    x = ufloat("0.20(1)")
    x = ufloat("20(1)e-2")
    x = ufloat("0.20")  # Automatic +/-1 on last digit

    isinstance(x, UFloat) is true if x contains uncertainty

    x.nominal_value == 0.2  == x.n (abbrev)
    x.std_dev       == 0.01 == x.s (abbrev)

String interpolation
    print(f"{x:+.1uS}")     # 1 digit, shorthand with sign
        +0.20(1)
            Parse back to ufloat with 
                uncertainties.ufloat_fromstr("+0.20(1)")
    print(f"{x*1e7:.2eP}")  # Pretty printing using Unicode
        (2.00±0.10)×10⁶

    print(sin(2*x))         # Default form, 2 fig for unc
        0.389+/-0.018
    print(f"{x:.2f}")
        0.20+/-0.01
    print(f"{x:.1u}")       # 1 digit for unc
        0.20+/-0.01
    print(f"{x:.3u}")       # 3 digits for unc
        0.2000+/-0.0100
    print(f"{x:.1ue}")      # 1 digit for unc in sci
        (2.0+/-0.1)e-01
    print(f"{x:.1u%}")      # 1 digit, percentage
        (20+/-1)%
    print(x*1e7)
        (2.00+/-0.10)e+06
    print(f"{x*1e7:L}")     # LaTeX form
        \left(2.00 \pm 0.10\right) \times 10^{6}

print(x - x)
    0
Note this is correct because x is 100% correlated with x.

You can put uncertain numbers in numpy arrays:
    arr = numpy.array([ufloat((1, 0.01)), ufloat((2, 0.1))])
    2*arr
        [2.0+/-0.02 4.0+/-0.2]
    print(arr.sum())
        3.0+/-0.100498756211
    Look at uncertainties.unumpy module for more stuff.  In
    particular, unumpy.matrix is used because it allows matrix
    inverses to be gotten when the matrix contains ufloats (regular
    numpy doesn't allow this).  Also, unumpy.cos(arr) etc. can be used
    for the elementary functions (they use numpy's naming scheme, not
    the math module's).

    unumpy.linalg.inv(array)

Attributes of a ufloat x:
    x.nominal_value
    x.std_dev

    x.position_in_sigmas(y)
        gives number of sigmas of x in y

Covariance matrix
    sum_value = u + 2*v
    cov_matrix = uncertainties.covariance_matrix([u, v, sum_value])

Correlated variables
    You can create correlated variables if numpy is available:

    u2, v2, sum2 = uncertainties.correlated_values([1, 10, 21], cov_matrix)

    given the covariance matrix.

Wrapping functions
    You can wrap functions so that they work on arguments that contain
    uncertainties.  Suppose f takes an arbitrary number of floats and
    returns a float.  Then 

        wrapped_f = uncertainties.wrap(f)

    can be used to call f with uncertainty arguments.

Derivatives
    Fast derivatives can be gotten:

    u = ufloat((1, 0.1))
    v = ufloat((10, 0.1))
    s = u + 2*v
    s.derivatives[u]
        gives 1.0
    s.derivatives[v]
        gives 2.0

---------------------------------------------------------------------------
Windows Printing                        *python_windows_printing*

Windows Printing Via Python
 
NEW!!! Don't want to roll your own? If you are using Windows
2K/XP/2003, you can just install and use my MSWinPrint.py module. Get
it here: MSWinPrint page.

Revised October 5, 2006

Note: The following instructions are supplied without warranty. If you
use them, you are accepting responsiblity for anything that might go
wrong. Also note that the instructions below have been tested on
Python 2.4 on Windows XP only (using pywin32 build 205 and later).

So you want to produce some output? On the surface it sounds pretty
simple:

    # create a dc (Device Context) object (actually a PyCDC)
    dc = win32ui.CreateDC()

    # convert the dc into a "printer dc"

    # leave out the printername to get the default printer
    # automatically
    dc.CreatePrinterDC(printername)

    # you need to set the map mode mainly so you know how
    # to scale your output.  I do everything in points, so setting 
    # the map mode as "twips" works for me.
    dc.SetMapMode(win32con.MM_TWIPS) # 1440 per inch

    # here's that scaling I mentioned:
    scale_factor = 20 # i.e. 20 twips to the point

    # start the document.  the description variable is a string
    # which will appear in the print queue to identify the job.
    dc.StartDoc(description)

    # to draw anything (other than text) you need a pen.
    # the variables are pen style, pen width and pen color.
    pen = win32ui.CreatePen(0, int(scale_factor), 0L)

    # SelectObject is used to apply a pen or font object to a dc.
    dc.SelectObject(pen)

    # how about a font?  Lucida Console 10 point.
    # I'm unsure how to tell if this failed.
    font = win32ui.CreateFont({
        "name": "Lucida Console",
        "height": int(scale_factor * 10),
        "weight": 400,
    })

    # again with the SelectObject call.
    dc.SelectObject(font)

    # okay, now let's print something.
    # TextOut takes x, y, and text values.
    # the map mode determines whether y increases in an
    # upward or downward direction; in MM_TWIPS mode, it
    # advances up, so negative numbers are required to 
    # go down the page.  If anyone knows why this is a
    # "good idea" please email me; as far as I'm concerned
    # it's garbage.
    dc.TextOut(scale_factor * 72,
        -1 * scale_factor * 72,
        "Testing...")

    # for completeness, I'll draw a line.
    # from x = 1", y = 1"
    dc.MoveTo((scale_factor * 72, scale_factor * -72))
    # to x = 6", y = 3"
    dc.LineTo((scale_factor * 6 * 72, scale_factor * 3 * -72))

    # must not forget to tell Windows we're done.
    dc.EndDoc()

So far, so good. Doing it this way gives you decent output, but you
can't change the paper size or orientation (or a bunch of other
things).

It turns out that both win32ui and win32gui have a CreateDC function,
but they are NOT equivalent. win32ui.CreateDC gives you a PyCDC object
(wrapping an hDC and various methods for manipulating it), but
win32gui.CreateDC gives you an integer hDC value. BUT...
win32ui.CreateDC doesn't allow you full access to configure the hDC
(or if it does, I couldn't figure out how to use it). So you can't
make those changes you'd like to make if you get the DC the way I did
above.

SO... here's another version. This is just the beginning of the text
above; the whole procedure involves opening the printer, configuring
it, getting an integer hDC for the configured printer, and making a
PyCDC out of it:

    # if you just want to use the default printer, you need
    # to retrieve its name.
    printer = win32print.GetDefaultPrinter()

    # open the printer.
    hprinter = win32print.OpenPrinter(printer)

    # retrieve default settings.  this code does not work on
    # win95/98, as GetPrinter does not accept two 
    devmode = win32print.GetPrinter(hprinter, 2)["pDevMode"]

    # change paper size and orientation
    # constants are available here:
    # http://msdn.microsoft.com/library/default.asp?
    #      url=/library/en-us/intl/nls_Paper_Sizes.asp
    # number 10 envelope is 20
    devmode.PaperSize = 20
    # 1 = portrait, 2 = landscape
    devmode.Orientation = 2

    # create dc using new settings.
    # first get the integer hDC value.  note that we need the name.
    hdc = win32gui.CreateDC("WINSPOOL", printer, devmode)
    # next create a PyCDC from the hDC.
    dc = win32ui.CreateDCFromHandle(hdc)

    # now you can set the map mode, etc. and actually print.

Hopefully this helps someone else. If this page has been of any use to
you at all, please drop me an email:

chris@newcenturycomputers.net 

---------------------------------------------------------------------------
time module                             *python_time*


time.accept2dyear 
    Boolean value indicating whether two-digit year values will be
    accepted. This is true by default, but will be set to false if the
    environment variable PYTHONY2K has been set to a non-empty string.
    It may also be modified at run time.

time.altzone 
    The offset of the local DST timezone, in seconds west of UTC, if
    one is defined. This is negative if the local DST timezone is east
    of UTC (as in Western Europe, including the UK). Only use this if
    daylight is nonzero.

time.asctime([t]) 
    Convert a tuple or struct_time representing a time as returned by
    gmtime() or localtime() to a 24-character string of the following
    form: 'Sun Jun 20 23:21:05 1993'. If t is not provided, the
    current time as returned by localtime() is used. Locale
    information is not used by asctime().

time.clock() 
    On Unix, return the current processor time as a floating point
    number expressed in seconds. The precision, and in fact the very
    definition of the meaning of "processor time", depends on that of
    the C function of the same name, but in any case, this is the
    function to use for benchmarking Python or timing algorithms.

    On Windows, this function returns wall-clock seconds elapsed since
    the first call to this function, as a floating point number, based
    on the Win32 function QueryPerformanceCounter(). The resolution is
    typically better than one microsecond.

time.ctime([secs]) 
    Convert a time expressed in seconds since the epoch to a string
    representing local time. If secs is not provided or None, the
    current time as returned by time() is used. ctime(secs) is
    equivalent to asctime(localtime(secs)). Locale information is not
    used by ctime().

time.daylight 
    Nonzero if a DST timezone is defined.

time.gmtime([secs]) 
    Convert a time expressed in seconds since the epoch to a
    struct_time in UTC in which the dst flag is always zero. If secs
    is not provided or None, the current time as returned by time() is
    used. Fractions of a second are ignored. See above for a
    description of the struct_time object. See calendar.timegm() for
    the inverse of this function.

time.localtime([secs]) 
    Like gmtime() but converts to local time. If secs is not provided
    or None, the current time as returned by time() is used. The dst
    flag is set to 1 when DST applies to the given time.

time.mktime(t) 
    This is the inverse function of localtime(). Its argument is the
    struct_time or full 9-tuple (since the dst flag is needed; use -1
    as the dst flag if it is unknown) which expresses the time in
    local time, not UTC. It returns a floating point number, for
    compatibility with time(). If the input value cannot be
    represented as a valid time, either OverflowError or ValueError
    will be raised (which depends on whether the invalid value is
    caught by Python or the underlying C libraries). The earliest date
    for which it can generate a time is platform-dependent.

time.sleep(secs) 
    Suspend execution for the given number of seconds. The argument
    may be a floating point number to indicate a more precise sleep
    time. The actual suspension time may be less than that requested
    because any caught signal will terminate the sleep() following
    execution of that signal's catching routine. Also, the suspension
    time may be longer than requested by an arbitrary amount because
    of the scheduling of other activity in the system.

time.strftime(format[, t]) 
    Convert a tuple or struct_time representing a time as returned by
    gmtime() or localtime() to a string as specified by the format
    argument. If t is not provided, the current time as returned by
    localtime() is used. format must be a string. ValueError is raised
    if any field in t is outside of the allowed range.

The following directives can be embedded in the format string. They are shown
without the optional field width and precision specification, and are
replaced by the indicated characters in the strftime() result:

    %a Locale's abbreviated weekday name. 
    %A Locale's full weekday name. 
    %b Locale's abbreviated month name. 
    %B Locale's full month name. 
    %c Locale's appropriate date and time representation. 
    %d Day of the month as a decimal number [01,31]. 
    %H Hour (24-hour clock) as a decimal number [00,23]. 
    %I Hour (12-hour clock) as a decimal number [01,12]. 
    %j Day of the year as a decimal number [001,366]. 
    %m Month as a decimal number [01,12]. 
    %M Minute as a decimal number [00,59]. 
    %p Locale's equivalent of either AM or PM. (1) 
    %S Second as a decimal number [00,61]. (2) 
    %U Week number of the year (Sunday as the first day of the week)
       as a decimal number [00,53]. All days in a new year preceding the
       first Sunday are considered to be in week 0. (3) 
    %w Weekday as a decimal number [0(Sunday),6]. 
    %W Week number of the year (Monday as the first day of the week)
       as a decimal number [00,53]. All days in a new year preceding the
       first Monday are considered to be in week 0. (3) 
    %x Locale's appropriate date representation. 
    %X Locale's appropriate time representation. 
    %y Year without century as a decimal number [00,99]. 
    %Y Year with century as a decimal number. 
    %Z Time zone name (no characters if no time zone exists). 
    %% A literal '%' character. 

    Notes:

    When used with the strptime() function, the %p directive only
    affects the output hour field if the %I directive is used to parse
    the hour.  The range really is 0 to 61; this accounts for leap
    seconds and the (very rare) double leap seconds.  When used with
    the strptime() function, %U and %W are only used in calculations
    when the day of the week and the year are specified.  Here is an
    example, a format for dates compatible with that specified in the
    RFC 2822 Internet email standard. [1]

    >>> from time import gmtime, strftime
    >>> strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
    'Thu, 28 Jun 2001 14:17:15 +0000'

    Additional directives may be supported on certain platforms, but
    only the ones listed here have a meaning standardized by ANSI C.

    On some platforms, an optional field width and precision
    specification can immediately follow the initial '%' of a
    directive in the following order; this is also not portable. The
    field width is normally 2 except for %j where it is 3.

time.strptime(string[, format]) 
    Parse a string representing a time according to a format. The
    return value is a struct_time as returned by gmtime() or
    localtime().

    The format parameter uses the same directives as those used by
    strftime(); it defaults to "%a %b %d %H:%M:%S %Y" which matches
    the formatting returned by ctime(). If string cannot be parsed
    according to format, or if it has excess data after parsing,
    ValueError is raised. The default values used to fill in any
    missing data when more accurate values cannot be inferred are
    (1900, 1, 1, 0, 0, 0, 0, 1, -1).

    For example:

    >>> import time
    >>> time.strptime("30 Nov 00", "%d %b %y")   # doctest: +NORMALIZE_WHITESPACE
    time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0,
                     tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)

    Support for the %Z directive is based on the values contained in
    tzname and whether daylight is true. Because of this, it is
    platform-specific except for recognizing UTC and GMT which are
    always known (and are considered to be non-daylight savings
    timezones).

    Only the directives specified in the documentation are supported.
    Because strftime() is implemented per platform it can sometimes
    offer more directives than those listed. But strptime() is
    independent of any platform and thus does not necessarily support
    all directives available that are not documented as supported.

time.struct_time 
    The type of the time value sequence returned by gmtime(),
    localtime(), and strptime().

time.time() 
    Return the time as a floating point number expressed in seconds
    since the epoch, in UTC. Note that even though the time is always
    returned as a floating point number, not all systems provide time
    with a better precision than 1 second. While this function
    normally returns non-decreasing values, it can return a lower
    value than a previous call if the system clock has been set back
    between the two calls.

time.timezone 
    The offset of the local (non-DST) timezone, in seconds west of UTC
    (negative in most of Western Europe, positive in the US, zero in
    the UK).

time.tzname 
    A tuple of two strings: the first is the name of the local non-DST
    timezone, the second is the name of the local DST timezone. If no
    DST timezone is defined, the second string should not be used.

time.tzset() 
    Resets the time conversion rules used by the library routines. The
    environment variable TZ specifies how this is done.

----------------------------------------------------------------------
Inspect module                                      *python_inspect*

Used to inspect objects

getargspec(func)
    Returns a tuple (arg_names, var_args, kw_args, arg_defaults) for a
    function object.
formatargspec(*getargspec(func))
    Returns a formatted string that looks like the function's call.
getargvalues(frame_obj)
    Returns (arg_names, extra_args, extra_kw, locals) in a stack
    frame.
formatargvalues(*getargvalues(frame_obj))
    Returns a formatted string for getargvalues.
currentframe()
    Returns frame_obj for current frame.  Use
    formatargvalues(*getargvalues(currentframe())) to show the actual
    arguments of the calling function.
getdoc(obj)
    Returns docstring.
getfile(obj), getsourcefile(obj)
    Returns name of file that defined obj.
getmembers(obj, filter=None)
    Returns obj's attributes, a sorted list of (name, value) pairs.
    If filter is not None, then it's a predicate to get only the True
    values:  [(n, v) for n, v in getmembers(obj) if filter(v)]
getmodule(obj)
    Returns module object that defined obj or None.
getmro(cls)
    Returns tuple of base classes of cls in method resolution order.
getsource(obj)
    Returns a multiline string of the source for object obj.
getsourcelines(obj)
    Returns (lines sequence, linenum of first line) for source of
    object obj.

Booleans:

    isbuiltin(obj)      C-coded object
    isclass(obj)        Class object
    iscode(obj)         Code object (from compile())
    isframe(obj)        Stack frame object
    isfunction(obj)     Function object (coded in python)
    ismethod(obj)       Object method
    ismodule(obj)       Is a module
    isroutine(obj)      Any method/function (C or python)
stack(context=1)
    Returns a six-item tuple; context is the number of context lines
    around the current line.  Each tuple's contents:
        Stack frame object
        Filename
        Line number
        Function name
        List of context source lines
        Index of current line within list

Here's an example of some of these functions:
    from inspect import *
    def f(s, a=3):
        print("+", s)
        print(formatargvalues(*getargvalues(currentframe())))
        print()
        for i, s in enumerate(stack(context=3)):
            print(i)
            for j in s:
                print("  ", j)
    f("hi")

produces
    + hi
    (s='hi', a=3)

    0
       <frame object at 0x00B5F6A0>
       b.py
       8
       f
       ['    print()\n', '    for i, s in enumerate(stack(context=3)):\n',
    '        print(i)\n']
       1
    1
       <frame object at 0x00B4D730>
       b.py
       13
       <module>
       ['            print("  ", j)\n', '\n', 'f("hi")\n']
       2

----------------------------------------------------------------------
StringIO                                        *python_StringIO*

Read and write strings as files.

NOTE:  a StringIO object is a file object, so you can use the
following file methods on it:

    read()
    readline()
    readlines()
    seek()              Seek to desired position
    tell()              Show current position
    truncate()          Use to empty:  truncate(0)
    write()
    writelines()        Write sequence; no newlines added
    Iterate:  each iteration returns a line with the newline

Init
    from io import StringIO
    StringIO([buffer]) 

    Can use 8-bit or Unicode strings; mixing them requires care.  If
    both are used, 8-bit strings that are not 7-bit ASCII will cause
    a UnicodeError when getvalue() is called.

    For speed, use cStringIO objects.  Cannot accept Unicode strings
    that cannot be encoded as plain ASCII.  Also, calling it with a
    string buffer creates a read-only object.

Methods

    getvalue()  Retrieve contents before close() called.
    close()     Free the memory buffer.

Example usage:

    Create and write to:
        output = StringIO.StringIO()
        output.write("First line.\n")

    Retrieve contents:
        print(output.getvalue())

Demo:
    from io import StringIO

    sio = StringIO

    s = sio('''
    Hello, this is the first line.
    Second line
    ''')
    for i, l in enumerate(s):
        print(i, repr(l))
    s.seek(10)
    print("tell", s.tell())
    n = 8
    print("Read %d bytes" % n, repr(s.read(n)))
    print("Position now", s.tell())
    n = 4
    print("truncate to %d chars:" % n)
    s.truncate(n)
    print("  ", repr(s.getvalue()))
    print("Use truncate to empty file:  ", end="")
    s.truncate(0)
    print(repr(s.getvalue()))
    print("Put in the two characters 'ab':  ", end="")
    s.write("ab")
    print(repr(s.getvalue()))

produces
    0 '\n'
    1 'Hello, this is the first line.\n'
    2 'Second line\n'
    tell 10
    Read 8 bytes 'is is th'
    Position now 18
    truncate to 4 chars:
       '\nHel'
    Use truncate to empty file:  ''
    Put in the two characters 'ab':  'ab'

----------------------------------------------------------------------
Python temporary files & directories        *python_tmp_stuff*

Creating a temporary directory and unpacking a zipfile (from the
get-pip.py script):

    tmpdir = None
    try:
        # Create a temporary working directory
        tmpdir = tempfile.mkdtemp()

        # Unpack the zipfile into the temporary directory
        pip_zip = os.path.join(tmpdir, "pip.zip")
        with open(pip_zip, "wb") as fp:
            fp.write(base64.decodestring(ZIPFILE))

        # Add the zipfile to sys.path so that we can import it
        sys.path = [pip_zip] + sys.path

        # Run the bootstrap
        bootstrap(tmpdir=tmpdir)
    finally:
        # Clean up our temporary working directory
        if tmpdir:
            shutil.rmtree(tmpdir, ignore_errors=True)

----------------------------------------------------------------------
Python precedence                           *python_precedence*

Highest to lowest, left-to-right associativity

Operator                            Description
---------------------------------   --------------------------------------
(expressions...), [expressions...], Binding or tuple display,, list display,
                                    dictionary display, set display

x[index], x[index:index],           Subscripting, slicing, call,
x(arguments...), x.attribute        attribute reference

await x                             Await expression

**                                  Exponentiation [6]

+x, -x, ~x                          Positive, negative, bitwise NOT

*, @, /, //, %                      Mult, matrix mult, division, remainder [5]

+, -                                Addition and subtraction

<<, >>                              Shifts

&                                   Bitwise AND

^                                   Bitwise XOR

|                                   Bitwise OR

in, not in, is, is not,             Comparisons, including membership
<, <=, >, >=, !=, ==                and identity tests

not x                               Boolean NOT

and                                 Boolean AND

or                                  Boolean OR

if ? else                           Conditional expression

lambda                              Lambda expression

[1] While abs(x%y) < abs(y) is true mathematically, for floats it may 
    not be true numerically due to roundoff. For example, and assuming
    a platform on which a Python float is an IEEE 754 double-precision
    number, in order that -1e-100 % 1e100 have the same sign as 1e100,
    the computed result is -1e-100 + 1e100, which is numerically
    exactly equal to 1e100. The function math.fmod() returns a result
    whose sign matches the sign of the first argument instead, and so
    returns -1e-100 in this case. Which approach is more appropriate
    depends on the application.

[2] If x is very close to an exact integer multiple of y, it's possible
    for x//y to be one larger than (x-x%y)//y due to rounding. In such
    cases, Python returns the latter result, in order to preserve that
    divmod(x,y)[0] * y + x % y be very close to x.

[3] While comparisons between strings make sense at the byte level, they 
    may be counter-intuitive to users. For example, the strings
    "\u00C7" and "\u0327\u0043" compare differently, even though they
    both represent the same unicode character (LATIN CAPITAL LETTER C
    WITH CEDILLA). To compare strings in a human recognizable way,
    compare using unicodedata.normalize().

[4] Due to automatic garbage-collection, free lists, and the dynamic 
    nature of descriptors, you may notice seemingly unusual behaviour
    in certain uses of the is operator, like those involving
    comparisons between instance methods, or constants. Check their
    documentation for more info.

[5] The % operator is also used for string formatting; the same 
    precedence applies.

[6] The power operator ** binds less tightly than an arithmetic or 
    bitwise unary operator on its right, that is, 2**-1 is 0.5.

----------------------------------------------------------------------
String formatting using "".format()           *python_string_formatting*

Commas in integers
    n = 12
    f"{int(a):>{n},d}

f-strings (3.6+)
    f"{x}" form uses format() syntax directly
Variable names gotten from keyword arguments
    name = sys.argv[0]
    other = [1, 2]
    "Usage:  {name}".format(**locals())
    "{other[0]}".format(**locals())
Positional parameters
    "Usage:  {} {}".format("myname", "oops")
    "Usage:  {0} {1}".format("myname", "oops")
    "Usage:  {0} {1}".format(*seq)
    "{myname}".format(myname=42)
    d={"myname":42}; "{myname}".format(**d)
    "{0.real} {0.imag}".format(1+3j)
    "{0.weight} ".format(an_object) # weight attribute of an_object
    "{0[0]}.format(["item1", "item2"])
Conversions:
    {0!s} calls str() first on 0th arg
    {0!r} calls repr() first on 0th arg
Field width from another variable:
    {0:{1}}
Grammar (some double quotes deleted)
    basic       ::=  {[fld_name] [!conv] [:fmt_spec]}
    fld_name    ::=  arg (.attr | [elem_index])*
    arg         ::=  [identifier | integer]
    attr        ::=  identifier
    elem_index  ::=  integer | idx_str
    idx_str     ::=  <any source character except "]"> +
    conv        ::=  One of rsa   (i.e., repr, str, ascii)

Format specs:
    fmt_spec    ::=  [[fill]align][sign][#][0][width][,][.precision][type]
    fill        ::=  <a character other than "}">
    align       ::=  <  Left justified
                     >  Right justified
                     =  Padding after sign but before digits
                     ^  Centered
    sign        ::=  + | - | " "
    width       ::=  integer (precede with '0' for zero padding)
    precision   ::=  integer
    type        ::=  One of bcdoxXn(int) eEfgGn%(float) or None

    '#' means to use an alternate form (applies to int, float,
    complex, and Decimal).  For integers, adds 0b for binary, 0x
    for hex, etc.  For floats and Decimals, the output will always
    contain a decimal point.  For g and G, trailing zeros are not
    removed.

    The sign is only allowed for numbers; + means show it always, - means
    only show negative sign, and " " means allow a space for it, but only
    show -.

    The ',' forces a comma as a thousands separator.  For a
    locale-aware separator, use n instead.

    Integers
        b   Binary  f"{14:#b}", f"{14:b}" --> "0b1110", "1110"
        c   Character (converts to unicode character)
        d   Decimal
        o   Octal
        x   Hex lowercase
        X   Hex uppercase
        n   Number (== d except uses locale for separators)

    Floating point
        e   Exponential lowercase
        E   Exponential uppercase
        f   Fixed point
        g   General format
        G   General format but e is changed to E
        n   Number (== g except uses locale for separators)
        %   Multiplies number by 100 and displays in f followed by %
        None    Defaults to g format

Examples:
    0.  s = "word\n"
        Print escaped control codes (i.e., calls repr() on argument):
        print("s = {s!r}".format(**locals()))
        will output
            'word\n'

    1.  mean = 1/7
        {mean:.4f} gives 0.1429

    2.  "{:*^30}".format("centered")
        ***********centered***********

    3.  "{:,}".format(1234567890)
        1,234,567,890

    4.  "{:.0%}".format(1/8)
        12%

    5.  Type-specific formatting
        import datetime
        d = datetime.datetime(2010, 7, 4, 12, 15, 58)
        '{:%Y-%m-%d %H:%M:%S}'.format(d)
        2010-07-04 12:15:58

    6.  width = 5
        for num in range(5,12): 
            for base in 'dXob':
                print('{0:{width}{base}}'.format(num, base=base, 
                            width=width), end=' ')
            print()

            5     5     5   101
            6     6     6   110
            7     7     7   111
            8     8    10  1000
            9     9    11  1001
           10     A    12  1010
           11     B    13  1011

----------------------------------------------------------------------
python_bitarray                                        *python_bitarray*

This is an optional C-based bit array module; these items act as lists.  
    https://pypi.org/project/bitarray/
    https://github.com/ilanschnell/bitarray

Run tests:  python -c 'import bitarray; bitarray.test()'

Bitarray objects act like lists.
    a = bitarray()      # Empty
    a.append(True)
    a.extend([False, True, True])
    print(a)
        >>> bitarray('1011')

Instantiation
    bitarray(n)             # Length n
    bitarray('1001011')     # From a string
    iterable = [0, 1, True, False, "", "a", set([]), set([1])]
    a = bitarray(iterable)
    print(a)
        >>> bitarray('01100101')
    # Effectively applies bool() to each element

Support slicing:
    a = bitarray(50)
    a.setall(False)
    a[11:37:3] = 9*bitarray([True])
    print(a)
        >>> bitarray('00000000000100100100100100100100100100000000000000')

    also:

    a = 20*bitarray('0')
    a[1:15:3] = True
    print(a)
        >>> bitarray('01001001001001000000')

Endianness
    a = bitarray(endian="big")
    a.frombytes(b"A")
    print(a)
        >>> bitarray('01000001')
    a = bitarray(endian="little")
    a.frombytes(b"A")
    print(a)
        >>> bitarray('10000010')

    a = bitarray('11100000', endian='little')
    print(a)
        >>> bitarray('11100000')
    b = bitarray(a, endian='big')   # Copies a's bytes
    print(b)
        >>> bitarray('00000111')
    a == b
        >>> False
    a.tobytes() == b.tobytes()
        >>> True

    To avoid endianness issues, use the tobytes, frombytes, tofile, and
    fromfile methods.

Bitwise operations:  &, |, ^, &=, |=, ^=, ~
    These are done in C; be careful about using bitarrays with different
    endianness.

Buffer protocol in python 2.7
    a = bitarray('01000001' '01000010' '01000011', endian='big')
    v = memoryview(a)
    print(a)
        >>> bitarray('010000010100001001000011')

Encoding
    d = {'H':bitarray('111'), 'e':bitarray('0'),
         'l':bitarray('110'), 'o':bitarray('10')}
    a = bitarray()
    a.encoded(d, "Hello")
    print(a)
        >>> bitarray('111011011010')

    Note symbols are not limited to characters; any immutable Python object
    can be a symbol.  Decoding:

    print(a.decode(d))
        >>> ['H', 'e', 'l', 'l', 'o']
    ''.join(a.decode(d))
        >>> "Hello"

Reference
    Class initialization
        bitarray([initial], [endian=string])
        Initial types:
            int, long:  defines the length
        string
        iterable    Convert bits using bool
        bitarray    Copy memory; fast
        endian = {"big" | "little"}

    Methods
        all() -> bool
            Returns True when all bits in the array are True.
        any() -> bool
            Returns True when any bit in the array is True.
        append(item)
            Append the value bool(item) to the end of the bitarray.
        buffer_info() -> tuple
            Return a tuple (address, size, endianness, unused, allocated)
            giving the current memory address, the size (in bytes) used to
            hold the bitarray's contents, the bit endianness as a string, the
            number of unused bits (e.g. a bitarray of length 11 will have a
            buffer size of 2 bytes and 5 unused bits), and the size (in
            bytes) of the allocated memory.
        bytereverse()
            For all bytes representing the bitarray, reverse the bit order
            (in-place). Note: This method changes the actual machine values
            representing the bitarray; it does not change the endianness of
            the bitarray object.
        copy() -> bitarray
            Return a copy of the bitarray.
        count([value]) -> int
            Return number of occurrences of value (defaults to True) in the
            bitarray.
        decode(code) -> list
            Given a prefix code (a dict mapping symbols to bitarrays), decode
            the content of the bitarray and return the list of symbols.
        encode(code, iterable)
            Given a prefix code (a dict mapping symbols to bitarrays),
            iterates over iterable object with symbols, and extends the
            bitarray with the corresponding bitarray for each symbols.
        endian() -> string
            Return the bit endianness as a string (either 'little' or 'big').
        extend(object)
            Append bits to the end of the bitarray. The objects which can be
            passed to this method are the same iterable objects which can
            given to a bitarray object upon initialization.
        fill() -> int
            Adds zeros to the end of the bitarray, such that the length of
            the bitarray is not a multiple of 8. Returns the number of bits
            added (0..7).
        frombytes(bytes)
            Append from a byte string, interpreted as machine values.
        fromfile(f, [n])
            Read n bytes from the file object f and append them to the
            bitarray interpreted as machine values. When n is omitted, as
            many bytes are read until EOF is reached.
        fromstring(string)
            Append from a string, interpreting the string as machine values.
            Deprecated since version 0.4.0, use frombytes() instead.
        index(value, [start, [stop]]) -> int
            Return index of the first occurrence of bool(value) in the
            bitarray.  Raises ValueError if the value is not present.
        insert(i, item)
            Insert bool(item) into the bitarray before position i.
        invert()
            Invert all bits in the array (in-place), i.e. convert each 1-bit
            into a 0-bit and vice versa.
        iterdecode(code) -> iterator
            Given a prefix code (a dict mapping symbols to bitarrays), decode
            the content of the bitarray and iterate over the symbols.
        itersearch(bitarray) -> iterator
            Searches for the given a bitarray in self, and return an iterator
            over the start positions where bitarray matches self.
        length() -> int
            Return the length, i.e. number of bits stored in the bitarray.
            This method is preferred over __len__ (used when typing len(a)),
            since __len__ will fail for a bitarray object with 2^31 or more
            elements on a 32bit machine, whereas this method will return the
            correct value, on 32bit and 64bit machines.
        pack(bytes)
            Extend the bitarray from a byte string, where each characters
            corresponds to a single bit. The character b'x00' maps to bit 0
            and all other characters map to bit 1. This method, as well as
            the unpack method, are meant for efficient transfer of data
            between bitarray objects to other python objects (for example
            NumPy's ndarray object) which have a different view of memory.
        pop([i]) -> item
            Return the i-th (default last) element and delete it from the
            bitarray.  Raises IndexError if bitarray is empty or index is out
            of range.
        remove(item)
            Remove the first occurrence of bool(item) in the bitarray. Raises
            ValueError if item is not present.
        reverse()
            Reverse the order of bits in the array (in-place).
        search(bitarray, [limit]) -> list
            Searches for the given a bitarray in self, and returns the start
            positions where bitarray matches self as a list. The optional
            argument limits the number of search results to the integer
            specified. By default, all search results are returned.
        setall(value)
            Set all bits in the bitarray to bool(value).
        sort(reverse=False)
            Sort the bits in the array (in-place).
        to01() -> string
            Return a string containing '0's and '1's, representing the bits
            in the bitarray object. Note: To extend a bitarray from a string
            containing '0's and '1's, use the extend method.
        tobytes() -> bytes
            Return the byte representation of the bitarray. When the length
            of the bitarray is not a multiple of 8, the few remaining bits
            (1..7) are set to 0.
        tofile(f)
            Write all bits (as machine values) to the file object f. When the
            length of the bitarray is not a multiple of 8, the remaining bits
            (1..7) are set to 0.
        tolist() -> list
            Return an ordinary list with the items in the bitarray. Note that
            the list object being created will require 32 or 64 times more
            memory than the bitarray object, which may cause a memory error
            if the bitarray is very large. Also note that to extend a
            bitarray with elements from a list, use the extend method.
        tostring() -> string
            Return the string representing (machine values) of the bitarray.
            When the length of the bitarray is not a multiple of 8, the few
            remaining bits (1..7) are set to 0. Deprecated since version
            0.4.0, use tobytes() instead.
        unpack(zero=b'\x00', one=b'\xff') -> bytes
            Return a byte string containing one character for each bit in the
            bitarray, using the specified mapping. See also the pack method. 

    Functions
        test(verbosity=1, repeat=1) -> TextTestResult
            Run self-test, and return unittest.runner.TextTestResult object.
        bitdiff(a, b) -> int
            Return the difference between two bitarrays a and b. This is
            function does the same as (a ^ b).count(), but is more memory
            efficient, as no intermediate bitarray object gets created
        bits2bytes(n) -> int
                Return the number of bytes necessary to store n bits. 

----------------------------------------------------------------------
python_toolz                                        *python_toolz*

This is a library that provides a number of functional programming tools that
extend the functools and itertools modules in the standard library.

The submodules are Itertoolz, Functoolz, Dicttoolz, and Sandbox.

The docstrings provide examples and help; for example, try 
'pd toolz.itertools'.

Itertoolz
    accumulate(binop, seq, initial=no_default) -->seq
        Repeatedly apply binary function to a sequence, accumulating results
    concat(seqs) --> seq
        Concatenate zero or more iterables, any of which may be infinite.
    concatv(*seqs) --> seq
        Variadic version of concat
    cons(el, seq) --> seq
        Add el to beginning of (possibly infinite) sequence seq.
    count(seq) --> int
        Count the number of items in seq
    countby(key, collection) --> dict
        Count elements of a collection by a key function
    diff(*seqs, **kwargs) --> seq
        Return those items that differ between sequences
        default kw sets padding value.
        key kw function is applied to each item before comparison.
    drop(n, seq)
        The sequence following the first n elements
    excepts(exc, func, handler=<function return_none>)
        A wrapper around a function to catch exceptions and dispatch to a
        handler.  Example:
            excepting = excepts(
                ValueError,
                lambda a: [1, 2].index(a),
                lambda _: -1,
            )
            excepting(1) --> 0
            excepting(3) --> -1

    first(seq) --> element
        The first element in a sequence
    flip
        Call function with arguments flipped.  Example:
            def div(a, b):  return a//b
            flip(div, 2, 6) --> 3
            div_by_two = flip(div, 2)
            div_by_two(4) --> 2
        isinstance example:
            data = [1, 'a', 'b', 2, 1.5, object(), 3]
            list(filter(flip(isinstance, int), data)) --> [1, 2, 3]
    frequencies(seq) --> dict
        Find number of occurrences of each value in seq
    get(ind, seq, default=no_default) --> element
        Get element in a sequence or dict.  ind can be a sequence.
    groupby(key, seq) --> dict
        Group a collection by a key function
    interleave(seqs) --> seq
        Interleave a sequence of sequences
    interpose(el, seq) --> seq
        Introduce element between each pair of elements in seq
    isdistinct(seq) --> bool
        All values in sequence are distinct
    isiterable(x) --> bool
        Is x iterable?
    iterate(func, x) --> x, func(x), func(func(x)), ...
        Repeatedly apply a function func onto an original input
    join(leftkey, leftseq, rightkey, rightseq, default=no_default) --> seq
        Join two sequences on common attributes
    last(seq) --> element
        The last element in a sequence
    mapcat(func, seqs) --> seq
        Apply func to each sequence in seqs, concatenating results.
    merge_sorted(*seqs, **kwargs) --> seq
        Merge and sort a collection of sorted collections
    nth(n, seq) --> element
        The nth element in a sequence
    partition(n, seq[, pad]) --> seq
        Partition sequence into tuples of length n
    partition_all(n, seq) --> seq
        Partition all elements of sequence into tuples of length at most n
    partitionby(func, seq) --> seq of sequences
        Partition a sequence according to a function
    peek(seq)  -> first, seq1 (seq1 is equivalent to seq)
        Retrieve the next element of a sequence
    pluck(ind, seqs, default=no_default) --> seq
        Plucks an element or several elements from each item in a sequence.
    random_sample(prob, seq, random_state=None) --> seq (lazy iterator)
        Return items independently and without replacement. If random_state
        is an integer, it's used as a seed; it can also be used with a method
        that returns a number on [0, 1).  Note successive returned sequences
        can be different sizes.
    reduceby(key, binop, seq, init=no_default) --> dict
        Perform a simultaneous groupby and reduction
    remove(predicate, seq) --> seq
        Return those items of sequence for which predicate(item) is False
    second(seq) --> element
        The second element in a sequence
    sliding_window(n, seq) --> seq
        A sequence of overlapping subsequences of length n
    take(n, seq) --> seq
        The first n elements of a sequence
    tail(n, seq) --> seq
        The last n elements of a sequence
    take_nth(n, seq) --> seq
        Every nth item in seq
    topk(k, seq[, key]) --> seq
        Find the k largest elements of a sequence
    unique(seq, key=None) --> seq
        Return only unique elements of a sequence

Functoolz
    complement(func) --> func
        Converts a predicate function to its logical complement.
    compose(*funcs) --> func
        Returns a function that applies other functions in sequence.  
        compose(f, g, h)(x, y) == f(g(h(x, y))).  No arguments implies identity.
    curry(*args, **kw) --> a func
        Enables partial application of arguments.  Example: 
        MUL = lambda x, y: x*y.  mul = curry(MUL).  double = mul(2).  Then
        double(10) returns 20.  Also supports keyword arguments:
            @curry
            def f(x, y, a=10)
                return a*(x + y)
            add = f(a=2)
            add(2, 3) --> 10
    do(func, x) --> x
        Runs func(x), returns x.  Only side effects of func are relevant.
    identity(x) --> x
        Identity function
    juxt(*funcs) --> func
        Creates a function that calls several functions with the same
        arguments.  Example:  inc = lambda x: x + 1, D = lambda x: 2*x.
        juxt(inc, D)(10) --> (11, 20).  Also works as juxt([inc, D])(10).
    memoize(func, cache=None, key=None)
        Cache a function's result for speedy future evaluation.  Can also use
        as a decorator.  key(*args, **kw) calculates cache keys which gets an
        args tuple and kw dict and must return a hashable value.
    pipe(data, *funcs)
        Pipe a value through a sequence of functions.  pipe(data, f, g, h) is
        equivalent to h(g(f(data))).
    thread_first(val, *forms)
        Thread val through a sequence of functions/forms.  Example:
        thread_first(x, f, (g, y, z)) --> g(f(x), y, z)
    thread_last(val, *forms)
        thread_last(x, f, (g, y, z)) --> g(y, z, f(x))

Dicttoolz
    assoc(d, key, value, factory=<type dict>) --> dict
        Return a new dict with new key value pair
    dissoc(d, *keys) --> dict
        Return a new dict with the given key(s) removed.
    assoc_in(d, keys, value, factory=<type dict>) --> dict
        Return a new dict with new, potentially nested, key value pair
    get_in(keys, coll[, default, no_default])
        Returns coll[i0][i1]...[iX] where [i0, i1, ..., iX]==keys.
        Generalization of operator.getitem for nested data structures such as
        dictionaries and lists.
    keyfilter(predicate, d, factory=<type dict>) --> dict
        Filter items in dictionary by key
    keymap(func, d, factory=<type dict>) --> dict
        Apply function to keys of dictionary
    itemfilter(predicate, d[, factory]) --> dict
        Filter items in dictionary by item
    itemmap(func, d, factory=<type dict>) --> dict
        Apply function to items of dictionary
    merge(*dicts, **kw) --> dict
        Merge a collection of dictionaries.  Later dicts have precedence.
    merge_with(func, *dicts, **kw) --> dict
        Merge dictionaries and apply function to combined values
    update_in(d, keys, func, default=None, factory=<type dict>) --> dict
        Update value in a (potentially) nested dictionary
    valfilter(predicate, d, factory=<type dict>) --> dict
        Filter items in dictionary by value
    valmap(func, d, factory=<type dict>)
        Apply function to values of dictionary

Sandbox
    parallel.fold(binop, seq, default=no_default, map=<itertools.imap>, 
                chunksize=128, combine=None)
        Reduce without guarantee of ordered reduction.
    core.EqualityHashKey(key, item)
        Create a hash key that uses equality comparisons between items.
    core.unzip(seq)
        Inverse of zip

----------------------------------------------------------------------
dataclasses                                 *python_dataclasses*

Added in 3.7

  The decorator causes an __init__ method to be added that has the variables
  indicated.  For example, for the following example, the implied __init__ is

  def __init__(self, name: str, lon: float=0.0, lat: float=0.0):

    # https://realpython.com/python-data-classes/
    from dataclasses import dataclass
    from math import asin, cos, radians, sin, sqrt

    @dataclass
    class Position:
        name: str
        lon: float = 0.0
        lat: float = 0.0

        def distance_to(self, other):
            r = 6371  # Earth radius in kilometers
            lam_1, lam_2 = radians(self.lon), radians(other.lon)
            phi_1, phi_2 = radians(self.lat), radians(other.lat)
            h = (sin((phi_2 - phi_1) / 2)**2
                 + cos(phi_1) * cos(phi_2) * sin((lam_2 - lam_1) / 2)**2)
            return 2 * r * asin(sqrt(h))

    oslo = Position('Oslo', 10.8, 59.9)
    vancouver = Position('Vancouver', -123.1, 49.3)
    print(oslo.distance_to(vancouver))

----------------------------------------------------------------------
pathlib                                     *python_pathlib*

PurePath for path manipulations (see purepath.py)
  import pathlib as P
  p = P.PurePath("/home/Don") --> '/home/Don'
  p/"work/me.tar.gz" --> '/home/Don/work/me.tar.gz'  # How to append
  p.parts --> '('/', 'home', 'Don', 'work', 'me.tar.gz')'     [tuple]
  p.drive --> ''     [str]
  p.root --> '/'     [str]
  p.anchor --> '/'     [str]
  p.parents --> '<PurePosixPath.parents>'     [pathlib._PathParents]
  p.parent --> '/home/Don/work'     [pathlib.PurePosixPath]
  p.name --> 'me.tar.gz'     [str]
  p.suffix --> '.gz'     [str]
  p.suffixes --> '['.tar', '.gz']'     [list]
  p.stem --> 'me.tar'     [str]

  drive is only for WindowsPath.
  anchor is concatenation of drive and root.
  parents:
    q = P.PureWindowsPath("c:/foo/bar/setup.py")
    str(q.parents[0])  --> c:\foo\bar
    repr(q.parents[0]) --> PureWindowsPath('c:/foo/bar')
    str(q.parents[1])  --> c:\foo
    repr(q.parents[1]) --> PureWindowsPath('c:/foo')
    etc.
  is_absolute()
  is_reserved()   Only relevant under Windows
  joinpath(*other)
    p = /home/Don/work/me.tar.gz
    r = P.Path(p.stem).stem --> me
    p.parent.joinpath(r, "other") --> /home/Don/work/me/other
  match(glob_pattern)
  relative_to(*other)
    p = /home/Don/work/me.tar.gz
    p.relative_to("/home") --> Don/work/me.tar.gz
  with_name(name)
    p = /home/Don/work/me.tar.gz
    p.with_name("lib.zip") --> /home/Don/work/lib.zip
  with_suffix(suffix)      Remove original if suffix is ''
    p = /home/Don/work/me.tar.gz
    p.with_suffix(".bz2") --> /home/Don/work/me.tar.bz2
    p.with_suffix("") --> /home/Don/work/me.tar

Class hierarchy
    PurePath = base class
    PurePosixPath(PurePath)
    PureWindowsPath(PurePath)
    Path(PurePath)
    PosixPath(PurePosixPath, Path)
    WindowsPath(PureWindowsPath, Path)

Handy usages:
    p = pathlib.Path("/home/Don/.vimrc")
    s = p.read_text(encoding=None, errors=None)
        read_text()'s options are the same as open()
    b = p.read_bytes()
    s = p.write_text(data, encoding=None, errors=None)
    b = p.write_bytes(data)

    List of files and directories:
        files, dirs = [], []
        for p in os.scandir(pathlib.Path("."):
            if p.is_file():
                files.append(p)
            elif p.is_dir():
                dirs.append(p)
    File size
        p.stat().st_size

Path objects access the file system.  PurePath objects can manipulate paths
without accessing the file system.

    as_posix()      Return with forward slashes
    as_uri()      
    chmod()
    cwd()           Current directory
    exists()
    expanduser()    Expand with ~ and ~user constructs
    glob()          **/* finds everything recursively     See rglob
    group()
    home()          User's home directory
    is_absolute()
    is_block_device()
    is_char_device()
    is_dir()
    is_fifo()
    is_file()
    is_mount()
    is_reserved()   Only relevant under Windows
    is_socket()
    is_symlink()
    iterdir()       Generator to iterate on directory's contents
    joinpath(*other)
    lchmod()
    lstat()
    match(pattern)  Match against glob-style pattern; return bool
    mkdir()
    open()
    owner()
    read_bytes()
    read_text(encoding=None, errors=None)
    relative_to(*other)
    rename(target)
    replace(target)
    resolve()       Make absolute; resolve symlinks and '..'
    rglob()         Recursive glob (like glob("**/" + pattern))
    rmdir()
    samefile()
    stat()
    symlink_to(target, target_is_directory=False)   Make a symlink
    touch(mode=0o666, exist_ok=True)
    unlink()
    with_name(name)         Change the name
    with_suffix(suffix)     Change the suffix
    write_bytes(data)
    write_text(data, encoding=None, errors=None)

os to pathlib correspondence
  os.path.abspath()           Path.resolve()
  os.chmod()                  Path.chmod()
  os.mkdir()                  Path.mkdir()
  os.rename()                 Path.rename()
  os.replace()                Path.replace()
  os.rmdir()                  Path.rmdir()
  os.remove(), os.unlink()    Path.unlink()
  os.getcwd()                 Path.cwd()
  os.path.exists()            Path.exists()
  os.path.expanduser()        Path.expanduser(), Path.home()
  os.path.isdir()             Path.is_dir()
  os.path.isfile()            Path.is_file()
  os.path.islink()            Path.is_symlink()
  os.stat()                   Path.stat(), Path.owner(), Path.group()
  os.path.isabs()             PurePath.is_absolute()
  os.path.join()              PurePath.joinpath()
  os.path.basename()          PurePath.name
  os.path.dirname()           PurePath.parent
  os.path.samefile()          Path.samefile()
  os.path.splitext()          PurePath.suffix

Examples:
    >>> p = pathlib.Path("/math/ProcessAnalyzer/new_pqs/pqs.py")
    >>> p.exists():
    True
    >>> p.parent
    PosixPath('/math/ProcessAnalyzer/new_pqs')
    >>> p.parts
    ('/', 'math', 'ProcessAnalyzer', 'new_pqs', 'pqs.py')
    >>> p.with_name("xx")
    PosixPath('/math/ProcessAnalyzer/new_pqs/xx')
    >>> p.with_suffix(".xx")
    PosixPath('/math/ProcessAnalyzer/new_pqs/pqs.xx')
    >>> p.name
    'pqs.py'
    >>> p.suffix
    '.py'
    >>> p.stem
    'pqs'
    >>> p.as_posix()
    '/math/ProcessAnalyzer/new_pqs/pqs.py'
    >>> p.as_uri()
    'file:///math/ProcessAnalyzer/new_pqs/pqs.py'

    # List subdirectories
    p = pathlib.Path(".")
    [x for x in p.iterdir() if x.is_dir()]

    # List python source files in this tree
    list(p.glob('**/*.py'))

    # Navigation in a tree
    p = pathlib.Path("/etc")
    q = p/"init.d"/"reboot"
    q is now PosixPath('/etc/init.d/reboot')
    q.resolve() is PosixPath('/etc/rc.d/init.d/halt')
    q.exists() returns True
    q.is_dir() returns False

    Opening a file
    with q.open() as f:
        f.readline()

----------------------------------------------------------------------
Enums                                               *python_enums*

import enum

@enum.unique    # Assures unique enumeration values
class color(enum.Enum):
    red = 1
    green = 6
    blue = 3

    print(color.red) --> color.red
    print(color) --> <enum 'color'>
    print(list(color)) --> [<color.red: 1>, <color.green: 6>, <color.blue: 3>]

Auto numbering:
    class Shape(enum.Enum):
        round = enum.auto()
        square = enum.auto()

IntEnum
    This is provided to cover the use case where you want enums to
    behave like integers; they can be compared to each other and other
    integer types.  It breaks some semantic promises of an enumeration
    (by being comparable to integers, and thus by transitivity to
    other unrelated enumerations). It should be used only in special
    cases where there's no other choice; for example, when integer
    constants are replaced with enumerations and backwards
    compatibility is required with code that still expects integers.

        class IntEnum(int, Enum):
            pass

    This lets you see how other derived enumerations can be defined.

You can derive from the Enum class:

    class planet(enum.Enum):
        mercury = (3.303e+23, 2.4397e6)
        venus   = (4.869e+24, 6.0518e6)
        earth   = (5.976e+24, 6.37814e6)
        def __init__(self, mass, radius):
            self.mass = mass       # in kilograms
            self.radius = radius   # in meters
        @property
        def surface_gravity(self):
            # universal gravitational constant  (m3 kg-1 s-2)
            G = 6.67300E-11
            return G * self.mass / (self.radius * self.radius)

    Then
        print(planet.earth.value)
        print(planet.earth.surface_gravity)
    gives
        (5.976e+24, 6378140.0)
        9.802652743337129

----------------------------------------------------------------------
string module                                    *python_string*

Constants
    string.ascii_letters
    string.ascii_lowercase
    string.ascii_uppercase
    string.digits
    string.hexdigits
    string.octdigits
    string.punctuation
    string.printable
    string.whitespace

----------------------------------------------------------------------
Strings                                          *python_strings*

All strings are Unicode.  Default encoding is UTF-8.

str(object=b'', encoding="utf-8", errors='strict')

    If encoding and errors are given, returns object.__str__() (or
    uses repr(object) if __str__ not available).

    If encoding or errors is given, object must be a bytes-like object
    (bytes or bytearray).

string module constants
    string.ascii_letters
    string.ascii_lowercase
    string.ascii_uppercase
    string.digits
    string.hexdigits
    string.octdigits
    string.punctuation
    string.printable
    string.whitespace

Methods
-------
    capitalize()
    casefold()
    center(width[, fillchar])
    count(sub[, start[, end]])
    encode(encoding="utf-8", errors="strict")
    endswith(suffix[, start[, end]])
    expandtabs(tabsize=8)
    find(sub[, start[, end]])
    format(*args, **kwargs)
    format_map(mapping)
    index(sub[, start[, end]])
    isalnum()
    isalpha()
    isdecimal()
    isdigit()
    isidentifier()
    islower()
    isnumeric()
    isprintable()
    isspace()
    istitle()
    isupper()
    join(iterable)
    ljust(width[, fillchar])
    lower()
    lstrip([chars])
    static str.maketrans(x[, y[, z]])
    partition(sep)
    replace(old, new[, count])
    rfind(sub[, start[, end]])
    rindex(sub[, start[, end]])
    rjust(width[, fillchar])
    rpartition(sep)
    rsplit(sep=None, maxsplit=-1)
    rstrip([chars])
    split(sep=None, maxsplit=-1)
    splitlines([keepends])
    startswith(prefix[, start[, end]])
    strip([chars])
    swapcase()
    title()
    translate(map)
    upper()
    zfill(width)
 
tr.capitalize()

    Return a copy of the string with its first character capitalized
    and the rest lowercased.

str.casefold()

    Return a casefolded copy of the string. Casefolded strings may be
    used for caseless matching.

    Casefolding is similar to lowercasing but more aggressive because
    it is intended to remove all case distinctions in a string. For
    example, the German lowercase letter 'á' is equivalent to "ss".
    Since it is already lowercase, lower() would do nothing to 'á'
    casefold() converts it to "ss".

    The casefolding algorithm is described in section 3.13 of the
    Unicode Standard.

    New in version 3.3.

str.center(width[, fillchar])

    Return centered in a string of length width. Padding is done using
    the specified fillchar (default is a space).

str.count(sub[, start[, end]])

    Return the number of non-overlapping occurrences of substring sub
    in the range [start, end]. Optional arguments start and end are
    interpreted as in slice notation.

str.encode(encoding="utf-8", errors="strict")

    Return an encoded version of the string as a bytes object. Default
    encoding is 'utf-8'. errors may be given to set a different error
    handling scheme. The default for errors is 'strict', meaning that
    encoding errors raise a UnicodeError. Other possible values are
    'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and
    any other name registered via codecs.register_error(), see section
    Codec Base Classes. For a list of possible encodings, see section
    Standard Encodings.

    Changed in version 3.1: Support for keyword arguments added.

str.endswith(suffix[, start[, end]])

    Return True if the string ends with the specified suffix,
    otherwise return False. suffix can also be a tuple of suffixes to
    look for. With optional start, test beginning at that position.
    With optional end, stop comparing at that position.

str.expandtabs(tabsize=8)

    Return a copy of the string where all tab characters are replaced
    by one or more spaces, depending on the current column and the
    given tab size. Tab positions occur every tabsize characters
    (default is 8, giving tab positions at columns 0, 8, 16 and so
    on). To expand the string, the current column is set to zero and
    the string is examined character by character. If the character is
    a tab (\t), one or more space characters are inserted in the
    result until the current column is equal to the next tab position.
    (The tab character itself is not copied.) If the character is a
    newline (\n) or return (\r), it is copied and the current column
    is reset to zero. Any other character is copied unchanged and the
    current column is incremented by one regardless of how the
    character is represented when printed.
    >>>

    >>> '01\t012\t0123\t01234'.expandtabs()
    '01      012     0123    01234'
    >>> '01\t012\t0123\t01234'.expandtabs(4)
    '01  012 0123    01234'

str.find(sub[, start[, end]])

    Return the lowest index in the string where substring sub is
    found, such that sub is contained in the slice s[start:end].
    Optional arguments start and end are interpreted as in slice
    notation. Return -1 if sub is not found.

    Note

    The find() method should be used only if you need to know the
    position of sub. To check if sub is a substring or not, use the in
    operator:
    >>>

    >>> 'Py' in 'Python'
    True

str.format(*args, **kwargs)

    Perform a string formatting operation. The string on which this
    method is called can contain literal text or replacement fields
    delimited by braces {}. Each replacement field contains either the
    numeric index of a positional argument, or the name of a keyword
    argument. Returns a copy of the string where each replacement
    field is replaced with the string value of the corresponding
    argument.
    >>>

    >>> "The sum of 1 + 2 is {0}".format(1+2)
    'The sum of 1 + 2 is 3'

    See Format String Syntax for a description of the various
    formatting options that can be specified in format strings.

str.format_map(mapping)

    Similar to str.format(**mapping), except that mapping is used
    directly and not copied to a dict. This is useful if for example
    mapping is a dict subclass:
    >>>

    >>> class Default(dict):
    ...     def __missing__(self, key): ...         return key ...
    >>> '{name} was born in
    >>> {country}'.format_map(Default(name='Guido'))
    'Guido was born in country'

    New in version 3.2.

str.index(sub[, start[, end]])

    Like find(), but raise ValueError when the substring is not found.

str.isalnum()

    Return true if all characters in the string are alphanumeric and
    there is at least one character, false otherwise. A character c is
    alphanumeric if one of the following returns True: c.isalpha(),
    c.isdecimal(), c.isdigit(), or c.isnumeric().

str.isalpha()

    Return true if all characters in the string are alphabetic and
    there is at least one character, false otherwise. Alphabetic
    characters are those characters defined in the Unicode character
    database as ?Letter?, i.e., those with general category property
    being one of ?Lm?, ?Lt?, ?Lu?, ?Ll?, or ?Lo?. Note that this is
    different from the ?Alphabetic? property defined in the Unicode
    Standard.

str.isdecimal()

    Return true if all characters in the string are decimal characters
    and there is at least one character, false otherwise. Decimal
    characters are those from general category ?Nd?. This category
    includes digit characters, and all characters that can be used to
    form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO.

str.isdigit()

    Return true if all characters in the string are digits and there
    is at least one character, false otherwise. Digits include decimal
    characters and digits that need special handling, such as the
    compatibility superscript digits. Formally, a digit is a character
    that has the property value Numeric_Type=Digit or
    Numeric_Type=Decimal.

str.isidentifier()

    Return true if the string is a valid identifier according to the
    language definition, section Identifiers and keywords.

    Use keyword.iskeyword() to test for reserved identifiers such as
    def and class.

str.islower()

    Return true if all cased characters [4] in the string are
    lowercase and there is at least one cased character, false
    otherwise.

str.isnumeric()

    Return true if all characters in the string are numeric
    characters, and there is at least one character, false otherwise.
    Numeric characters include digit characters, and all characters
    that have the Unicode numeric value property, e.g. U+2155, VULGAR
    FRACTION ONE FIFTH. Formally, numeric characters are those with
    the property value Numeric_Type=Digit, Numeric_Type=Decimal or
    Numeric_Type=Numeric.

str.isprintable()

    Return true if all characters in the string are printable or the
    string is empty, false otherwise. Nonprintable characters are
    those characters defined in the Unicode character database as
    ?Other? or ?Separator?, excepting the ASCII space (0x20) which is
    considered printable. (Note that printable characters in this
    context are those which should not be escaped when repr() is
    invoked on a string. It has no bearing on the handling of strings
    written to sys.stdout or sys.stderr.)

str.isspace()

    Return true if there are only whitespace characters in the string
    and there is at least one character, false otherwise. Whitespace
    characters are those characters defined in the Unicode character
    database as ?Other? or ?Separator? and those with bidirectional
    property being one of ?WS?, ?B?, or ?S?.

str.istitle()

    Return true if the string is a titlecased string and there is at
    least one character, for example uppercase characters may only
    follow uncased characters and lowercase characters only cased
    ones. Return false otherwise.

str.isupper()

    Return true if all cased characters [4] in the string are
    uppercase and there is at least one cased character, false
    otherwise.

str.join(iterable)

    Return a string which is the concatenation of the strings in the
    iterable iterable. A TypeError will be raised if there are any
    non-string values in iterable, including bytes objects. The
    separator between elements is the string providing this method.

str.ljust(width[, fillchar])

    Return the string left justified in a string of length width.
    Padding is done using the specified fillchar (default is a space).
    The original string is returned if width is less than or equal to
    len(s).

str.lower()

    Return a copy of the string with all the cased characters [4]
    converted to lowercase.

    The lowercasing algorithm used is described in section 3.13 of the
    Unicode Standard.

str.lstrip([chars])

    Return a copy of the string with leading characters removed. The
    chars argument is a string specifying the set of characters to be
    removed. If omitted or None, the chars argument defaults to
    removing whitespace. The chars argument is not a prefix; rather,
    all combinations of its values are stripped:
    >>>

    >>> '   spacious   '.lstrip()
    'spacious   '
    >>> 'www.example.com'.lstrip('cmowz.')
    'example.com'

static str.maketrans(x[, y[, z]])

    This static method returns a translation table usable for
    str.translate().

    If there is only one argument, it must be a dictionary mapping
    Unicode ordinals (integers) or characters (strings of length 1) to
    Unicode ordinals, strings (of arbitrary lengths) or None.
    Character keys will then be converted to ordinals.

    If there are two arguments, they must be strings of equal length,
    and in the resulting dictionary, each character in x will be
    mapped to the character at the same position in y. If there is a
    third argument, it must be a string, whose characters will be
    mapped to None in the result.

str.partition(sep)

    Split the string at the first occurrence of sep, and return a
    3-tuple containing the part before the separator, the separator
    itself, and the part after the separator. If the separator is not
    found, return a 3-tuple containing the string itself, followed by
    two empty strings.

str.replace(old, new[, count])

    Return a copy of the string with all occurrences of substring old
    replaced by new. If the optional argument count is given, only the
    first count occurrences are replaced.

str.rfind(sub[, start[, end]])

    Return the highest index in the string where substring sub is
    found, such that sub is contained within s[start:end]. Optional
    arguments start and end are interpreted as in slice notation.
    Return -1 on failure.

str.rindex(sub[, start[, end]])

    Like rfind() but raises ValueError when the substring sub is not
    found.

str.rjust(width[, fillchar])

    Return the string right justified in a string of length width.
    Padding is done using the specified fillchar (default is a space).
    The original string is returned if width is less than or equal to
    len(s).

str.rpartition(sep)

    Split the string at the last occurrence of sep, and return a
    3-tuple containing the part before the separator, the separator
    itself, and the part after the separator. If the separator is not
    found, return a 3-tuple containing two empty strings, followed by
    the string itself.

str.rsplit(sep=None, maxsplit=-1)

    Return a list of the words in the string, using sep as the
    delimiter string. If maxsplit is given, at most maxsplit splits
    are done, the rightmost ones. If sep is not specified or None, any
    whitespace string is a separator. Except for splitting from the
    right, rsplit() behaves like split() which is described in detail
    below.

str.rstrip([chars])

    Return a copy of the string with trailing characters removed. The
    chars argument is a string specifying the set of characters to be
    removed. If omitted or None, the chars argument defaults to
    removing whitespace. The chars argument is not a suffix; rather,
    all combinations of its values are stripped:
    >>>

    >>> '   spacious   '.rstrip()
    '   spacious'
    >>> 'mississippi'.rstrip('ipz')
    'mississ'

str.split(sep=None, maxsplit=-1)

    Return a list of the words in the string, using sep as the
    delimiter string. If maxsplit is given, at most maxsplit splits
    are done (thus, the list will have at most maxsplit+1 elements).
    If maxsplit is not specified or -1, then there is no limit on the
    number of splits (all possible splits are made).

    If sep is given, consecutive delimiters are not grouped together
    and are deemed to delimit empty strings (for example,
    '1,,2'.split(',') returns ['1', '', '2']). The sep argument may
    consist of multiple characters (for example, '1<>2<>3'.split('<>')
    returns ['1', '2', '3']). Splitting an empty string with a
    specified separator returns [''].

    If sep is not specified or is None, a different splitting
    algorithm is applied: runs of consecutive whitespace are regarded
    as a single separator, and the result will contain no empty
    strings at the start or end if the string has leading or trailing
    whitespace. Consequently, splitting an empty string or a string
    consisting of just whitespace with a None separator returns [].

    For example, ' 1  2   3  '.split() returns ['1', '2', '3'], and '
    1  2   3  '.split(None, 1) returns ['1', '2   3  '].

str.splitlines([keepends])

    Return a list of the lines in the string, breaking at line
    boundaries. This method uses the universal newlines approach to
    splitting lines. Line breaks are not included in the resulting
    list unless keepends is given and true.

    For example, 'ab c\n\nde fg\rkl\r\n'.splitlines() returns ['ab c',
    '', 'de fg', 'kl'], while the same call with splitlines(True)
    returns ['ab c\n', '\n', 'de fg\r', 'kl\r\n'].

    Unlike split() when a delimiter string sep is given, this method
    returns an empty list for the empty string, and a terminal line
    break does not result in an extra line.

str.startswith(prefix[, start[, end]])

    Return True if string starts with the prefix, otherwise return
    False. prefix can also be a tuple of prefixes to look for. With
    optional start, test string beginning at that position. With
    optional end, stop comparing string at that position.

str.strip([chars])

    Return a copy of the string with the leading and trailing
    characters removed. The chars argument is a string specifying the
    set of characters to be removed. If omitted or None, the chars
    argument defaults to removing whitespace. The chars argument is
    not a prefix or suffix; rather, all combinations of its values are
    stripped:
    >>>

    >>> '   spacious   '.strip()
    'spacious'
    >>> 'www.example.com'.strip('cmowz.')
    'example'

str.swapcase()

    Return a copy of the string with uppercase characters converted to
    lowercase and vice versa. Note that it is not necessarily true
    that s.swapcase().swapcase() == s.

    The reason for this is given by the following code and its printout.

        '''
        Find where str.swapcase() isn't its own inverse.
        '''
        fp = open("a.results", "w")
        for i in range(1000000):
            s = chr(i)
            t = s.swapcase()
            u = t.swapcase()
            if s != u:
                ordu = ord(u) if len(u) == 1 else ""
                w = f"{i:5d}:{s} {t:2s} {u:2s}:{ordu}"
                print(w)
                print(w, file=fp)
    which prints                        
          181:µ Μ  μ :956
          223:ß SS ss:
          304:İ i̇ İ:
          305:ı I  i :105
          329:ŉ ʼN ʼn:
          383:ſ S  s :115
          496:ǰ J̌ ǰ:
          837:ͅ Ι  ι :953
          912:ΐ Ϊ́ ΐ:
          944:ΰ Ϋ́ ΰ:
          962:ς Σ  σ :963
          976:ϐ Β  β :946
          977:ϑ Θ  θ :952
          981:ϕ Φ  φ :966
          982:ϖ Π  π :960
         1008:ϰ Κ  κ :954
         1009:ϱ Ρ  ρ :961
         1012:ϴ θ  Θ :920
         1013:ϵ Ε  ε :949
         1415:և ԵՒ եւ:
         7296:ᲀ В  в :1074
         7297:ᲁ Д  д :1076
         7298:ᲂ О  о :1086
         7299:ᲃ С  с :1089
         7300:ᲄ Т  т :1090
         7301:ᲅ Т  т :1090
         7302:ᲆ Ъ  ъ :1098
         7303:ᲇ Ѣ  ѣ :1123
         7304:ᲈ Ꙋ  ꙋ :42571
         7830:ẖ H̱ ẖ:
         7831:ẗ T̈ ẗ:
         7832:ẘ W̊ ẘ:
         7833:ẙ Y̊ ẙ:
         7834:ẚ Aʾ aʾ:
         7835:ẛ Ṡ  ṡ :7777
         7838:ẞ ß  SS:
         8016:ὐ Υ̓ ὐ:
         8018:ὒ Υ̓̀ ὒ:
         8020:ὔ Υ̓́ ὔ:
         8022:ὖ Υ̓͂ ὖ:
         8064:ᾀ ἈΙ ἀι:
         8065:ᾁ ἉΙ ἁι:
         8066:ᾂ ἊΙ ἂι:
         8067:ᾃ ἋΙ ἃι:
         8068:ᾄ ἌΙ ἄι:
         8069:ᾅ ἍΙ ἅι:
         8070:ᾆ ἎΙ ἆι:
         8071:ᾇ ἏΙ ἇι:
         8080:ᾐ ἨΙ ἠι:
         8081:ᾑ ἩΙ ἡι:
         8082:ᾒ ἪΙ ἢι:
         8083:ᾓ ἫΙ ἣι:
         8084:ᾔ ἬΙ ἤι:
         8085:ᾕ ἭΙ ἥι:
         8086:ᾖ ἮΙ ἦι:
         8087:ᾗ ἯΙ ἧι:
         8096:ᾠ ὨΙ ὠι:
         8097:ᾡ ὩΙ ὡι:
         8098:ᾢ ὪΙ ὢι:
         8099:ᾣ ὫΙ ὣι:
         8100:ᾤ ὬΙ ὤι:
         8101:ᾥ ὭΙ ὥι:
         8102:ᾦ ὮΙ ὦι:
         8103:ᾧ ὯΙ ὧι:
         8114:ᾲ ᾺΙ ὰι:
         8115:ᾳ ΑΙ αι:
         8116:ᾴ ΆΙ άι:
         8118:ᾶ Α͂ ᾶ:
         8119:ᾷ Α͂Ι ᾶι:
         8126:ι Ι  ι :953
         8130:ῂ ῊΙ ὴι:
         8131:ῃ ΗΙ ηι:
         8132:ῄ ΉΙ ήι:
         8134:ῆ Η͂ ῆ:
         8135:ῇ Η͂Ι ῆι:
         8146:ῒ Ϊ̀ ῒ:
         8147:ΐ Ϊ́ ΐ:
         8150:ῖ Ι͂ ῖ:
         8151:ῗ Ϊ͂ ῗ:
         8162:ῢ Ϋ̀ ῢ:
         8163:ΰ Ϋ́ ΰ:
         8164:ῤ Ρ̓ ῤ:
         8166:ῦ Υ͂ ῦ:
         8167:ῧ Ϋ͂ ῧ:
         8178:ῲ ῺΙ ὼι:
         8179:ῳ ΩΙ ωι:
         8180:ῴ ΏΙ ώι:
         8182:ῶ Ω͂ ῶ:
         8183:ῷ Ω͂Ι ῶι:
         8486:Ω ω  Ω :937
         8490:K k  K :75
         8491:Å å  Å :197
        64256:ﬀ FF ff:
        64257:ﬁ FI fi:
        64258:ﬂ FL fl:
        64259:ﬃ FFI ffi:
        64260:ﬄ FFL ffl:
        64261:ﬅ ST st:
        64262:ﬆ ST st:
        64275:ﬓ ՄՆ մն:
        64276:ﬔ ՄԵ մե:
        64277:ﬕ ՄԻ մի:
        64278:ﬖ ՎՆ վն:
        64279:ﬗ ՄԽ մխ:



str.title()

    Return a titlecased version of the string where words start with
    an uppercase character and the remaining characters are lowercase.

    The algorithm uses a simple language-independent definition of a
    word as groups of consecutive letters. The definition works in
    many contexts but it means that apostrophes in contractions and
    possessives form word boundaries, which may not be the desired
    result:
    >>>

    >>> "they're bill's friends from the UK".title()
    "They'Re Bill'S Friends From The Uk"

    A workaround for apostrophes can be constructed using regular
    expressions:
    >>>

    >>> import re def titlecase(s):
    ...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?", ...  lambda mo:
    mo.group(0)[0].upper() + ...  mo.group(0)[1:].lower(), ...
    s) ...
    >>> titlecase("they're bill's friends.")
    "They're Bill's Friends."

str.translate(map)

    Return a copy of the s where all characters have been mapped
    through the map which must be a dictionary of Unicode ordinals
    (integers) to Unicode ordinals, strings or None. Unmapped
    characters are left untouched. Characters mapped to None are
    deleted.

    You can use str.maketrans() to create a translation map from
    character-to-character mappings in different formats.

    Note

    An even more flexible approach is to create a custom character
    mapping codec using the codecs module (see encodings.cp1251 for an
    example).

str.upper()

    Return a copy of the string with all the cased characters [4]
    converted to uppercase. Note that str.upper().isupper() might be
    False if s contains uncased characters or if the Unicode category
    of the resulting character(s) is not ?Lu? (Letter, uppercase), but
    e.g. ?Lt? (Letter, titlecase).

    The uppercasing algorithm used is described in section 3.13 of the
    Unicode Standard.

str.zfill(width)
    
    Return the numeric string left filled with zeros in a string of
    length width. A sign prefix is handled correctly. The original
    string is returned if width is less than or equal to len(s).

----------------------------------------------------------------------
Optimization                                    *python_optimization*

Basic guidelines:

    Rule 1:  don't bother.  It's rare that python isn't fast enough.
    Rule 2:  Measure.
    Rule 3:  Identify the limiting factor.
    Rule 4:  Think; use better algorithms and data structures.

Note:  In 16 years of using python, I've had two occasions where I
needed something faster.  First was in 1999 (Gumby driver) where I
used python to index about 1e5 C++ files (network & ClearCase overhead
were important too).  python took a couple of hours; a C++ version
reduced that by an order of magnitude or two.

The other was in a python GUI app using numpy.  Using the profiler, I
found a loop on a numpy array which was using a python built-in rather
than numpy's.  When I changed over, I got a couple orders of magnitude
improvement in performance.  This made a significant difference to the
customer.

Python's profiling tools work well, but you'll have to invest a bit of
time in figuring out how to use them (in 16 years, I've only used them
twice).  Python's built-in profile is in the profile module.

Example (python 2 stuff):

    import cProfile, pstats, io
    pr = cProfile.Profile()
    pr.enable()

    # Here's the code being profiled
    def func2(a):
        return a//2
    def func1(a):
        a = a + a + a + a + a + a + a + a + a + a + a + a + a + a + a 
        a = func2(a)
        return a + a + a + a + a + a + a + a + a + a + a + a + a + a + a
    def func(a):
        t = 0
        for i in range(10**5):
            t += func1(i)
    func(1)
    # Done

    pr.disable()
    s = io.StringIO()
    sortby = 'cumulative'
    ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
    ps.print_stats()
    print(s.getvalue())

Results:
         200002 function calls in 0.840 seconds

   Ordered by: cumulative time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.172    0.172    0.840    0.840 a.py:12(func)
   100000    0.500    0.000    0.667    0.000 a.py:8(func1)
   100000    0.167    0.000    0.167    0.000 a.py:6(func2)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

----------------------------------------------------------------------
Strings and bytes                           *python_strings_and_bytes*

A string is a sequence of Unicode codepoints, which in an abstract sense is a
sequence of integers in range(0 to 0x11000).  You get a string if you read a
text file in text mode
    s = open(file, "r").read()
    isinstance(s, str) --> True

A 'bytes' object is a sequence of bytes, which are 8-bit unsigned integers.
These are the things you get when you read a file in from disk in C.  You
also get a bytes object in python if you open a file in binary mode and read
it:  
    open(file, "rb").read()
    isinstance(s, str)   --> False
    isinstance(s, bytes) --> True

You need to use encoding/decoding to convert between a bytes object b and
string object s:

    string ----------> bytes
            encoding

    bytes  ----------> string
            decoding
    
    or 
        b = s.encode("UTF-8")
        s = b.decode("UTF-8")

    UTF-8 is the default encoding and should be suitable for virtually all
    needs in the US working with English.  The only other encoding I'll
    occasionally use is ISO-8859-1 ("latin1" or "L1" aliases) for some legacy
    stuff from the web.  Encoding will be much more relevant for non-English
    languages.

The key mantra to burn into your mind is that in python 3 "all text strings
are encoded".  Thus the following syntax
    
    s = open(file, "r", encoding="UTF-8").read()

Concatenating strings and bytes
    https://docs.python.org/3/faq/programming.html#what-is-the-most-efficient-way-to-concatenate-many-strings-together
    Strings:
        str.join():
            chunks = []
            for s in my_strings:
                chunks.append(s)
            result = ''.join(chunks)
        io.StringIO
            output = io.StringIO()
            for s in my_strings:
                output.write(s)
            result = output.getvalue()
    Bytes:
        result = bytearray()
        for b in my_bytes_objects:
            result += b

Byte arrays
    bytes() returns an immutable sequences of integers in [0, 255].  
    bytearray() objects are a mutable counterpart to bytes objects.

    class bytearray([source[, encoding[, errors]]]) 
        source:  
            string(must also include encoding)
            integer:  create that size and initialize with null bytes
            iterable of integers in range [0, 255]
            object with buffer interface
    Examples:
        Empty:  bytearray()
        Creating a zero-filled instance with a given length: bytearray(10)
        From an iterable of integers: bytearray(range(20))
        Copying existing binary data via the buffer protocol: bytearray(b'Hi!')


----------------------------------------------------------------------
requests library                            *python_requests*

Installation
    pip install requests

Getting a file from the web
    # Download the url contents in binary format
    url = https://www.hpl.hp.com/hpjournal/pdfs/IssuePDFs/1971-03.pdf
    r = requests.get(url)
    # Write to file
    with open("1971-03.pdf", "wb") as fp:
        fp.write(r.content)

----------------------------------------------------------------------
PyPDF2                                      *python_PyPDF2*

See https://pythonhosted.org/PyPDF2/

Basic stuff
    from PyPDF2 import PdfFileWriter, PdfFileReader

    output = PdfFileWriter()
    inp = PdfFileReader(open(pdf_document, "rb"))

    # Number of pages
        print(f"{pdf_document} has {inp.getNumPages()} pages.")

    # Add page 1 from inp to output document, unchanged
        output.addPage(inp.getPage(0))

    # Add page 2 from inp, but rotated clockwise 90 degrees
        output.addPage(inp.getPage(1).rotateClockwise(90))

    # Add page 3 from inp, rotated the other way
        output.addPage(inp.getPage(2).rotateCounterClockwise(90))
        # or: output.addPage(inp.getPage(2).rotateClockwise(270))

    # Add page 4 from inp, but first add a watermark from another PDF
        page4 = inp.getPage(3)
        watermark = PdfFileReader(open("watermark.pdf", "rb"))
        page4.mergePage(watermark.getPage(0))
        output.addPage(page4)

    # Add page 5 from inp, but crop it to half size:
        page5 = inp.getPage(4)
        page5.mediaBox.upperRight = (
            page5.mediaBox.getUpperRight_x()/2,
            page5.mediaBox.getUpperRight_y()/2
        )
        output.addPage(page5)

    # Add some Javascript to launch the print window on opening this PDF.
    # The password dialog may prevent the print dialog from being shown,
    # comment the the encription lines, if that's the case, to try this out
        output.addJS("this.print({bUI:true,bSilent:false,bShrinkToFit:true});")

    # Encrypt your new PDF and add a password
        password = "secret"
        output.encrypt(password)

    # Write "output" to document-output.pdf
        outputStream = file("PyPDF2-output.pdf", "wb")
        output.write(outputStream)

Merging
    from PyPDF2 import PdfFileMerger

    merger = PdfFileMerger()

    input1 = open("document1.pdf", "rb")
    input2 = open("document2.pdf", "rb")
    input3 = open("document3.pdf", "rb")

    # add the first 3 pages of input1 document to output
    merger.append(fileobj = input1, pages = (0,3))

    # insert the first page of input2 into the output beginning after the second pag
    merger.merge(position = 2, fileobj = input2, pages = (0,1))

    # append entire input3 document to the end of the output document
    merger.append(input3)

    # Write to an output PDF document
    output = open("document-output.pdf", "wb")
    merger.write(output)

Make simple
    # Make some simple multipage pdf files

    from sys import argv

    # See https://pypi.org/project/reportlab/.  This is a tool to make PDF
    # files.
    from reportlab.pdfgen import canvas

    point = 1
    inch = 72

    TEXT = """%s    page %d of %d

    a wonderful file
    created with Sample_Code/makesimple.py"""


    def make_pdf_file(output_filename, np):
        title = output_filename
        c = canvas.Canvas(output_filename, pagesize=(8.5 * inch, 11 * inch))
        c.setStrokeColorRGB(0,0,0)
        c.setFillColorRGB(0,0,0)
        c.setFont("Helvetica", 12 * point)
        for pn in range(1, np + 1):
            v = 10 * inch
            for subtline in (TEXT % (output_filename, pn, np)).split( '\n' ):
                c.drawString( 1 * inch, v, subtline )
                v -= 12 * point
            c.showPage()
        c.save()

    if __name__ == "__main__":
        nps = [None, 5, 11, 17]
        for i, np in enumerate(nps):
            if np:
                filename = "simple%d.pdf" % i
                make_pdf_file(filename, np)
                print ("Wrote", filename)

----------------------------------------------------------------------
struct                                      *python_struct*

Allows reading/writing data from/to a binary file written in a tool like C.


Methods
    calcsize(format)
        Returns size of the indicated struct in bytes.
    pack(format, v1, v2, ...)
        Return a bytes object packed according to the data string.
    pack_into(format, buffer, offset, v1, v2, ...)
        Same as pack but into a buffer; buffer offset is required.
    unpack(format, buffer)
        Return a tuple of items per the format string.
    unpack_from(format, buffer, offset=0)
        Same as unpack except use an offset.
    iter_unpack(format, buffer)
        Returns an iterator that reads equally-sized chunks from buffer until
        consumed.

Format characters
    Format  C type              Python type     Bytes
    ------  -------------       -----------     -----
      x     pad byte            no value
      c     char                bytes of len 1    1 
      b     signed char         integer           1
      B     unsigned char       integer           1
      ?     _Bool               bool              1
      h     short               integer           2
      H     unsigned short      integer           2
      i     int                 integer           4
      I     unsigned int        integer           4
      l     long                integer           4
      L     unsigned long       integer           4
      q     long long           integer           8
      q     unsigned long long  integer           8
      n     ssize_t             integer            
      N     size_t              integer            
      e     half_prec float     float             2
      f     float               float             4
      d     double              float             8
      s     char[]              bytes
      p     char[] (Pascal str) bytes
      P     void *              integer

Format strings
        Byte order      Size        Alignment
        ----------      --------    ---------
    @   native          native      native
    =   native          standard    none
    <   little-endian   standard    none
    >   big-endian      standard    none
    !   network         standard    none
          (big-endian)

Example
    from struct import unpack
    from io import StringIO, BytesIO

    s = "4002 0303 4441 5332 3230 5f30 3930 3435"
    b = b''.fromhex(s)

    f = BytesIO(b)
    # Get two 2 byte signed integers
    a = unpack("2h", f.read(4))
    print("Two 2 byte signed integers (0x240 and 0x303) =", a)
    # Get 12 byte string
    t = b''.join(unpack("12c", f.read(12)))
    u = t.decode("UTF-8")
    print("12 byte string =", u)

  Output:
    Two 2 byte signed integers (0x240 and 0x303) = (576, 771)
    12 byte string = DAS220_09045

----------------------------------------------------------------------
Number methods                                  *python_number_methods*

int.bit_length()
    Number of bits necessary to represent the number excluding the sign and
    leading zeros.  If k = x.bit_length(), then 2**(k - 1) <= abs(x) < 2**k.

int.to_bytes(length, byteorder, *, signed=False)
    Return an array of bytes representing an integer.
    (1024).to_bytes(2, byteorder='big')
        --> b'\x04\x00'
    Use sys.byteorder to get the native byte order.

classmethod int.from_bytes(bytes, byteorder, *, signed=False)
    int.from_bytes(b'\x00\x10', byteorder='big')
        --> 16
    int.from_bytes(b'\x00\x10', byteorder='little')
        --> 4096

x.as_integer_ratio()
    Returns pair of integers whose ratio is exactly equal to the original
    float and with a positive denominator.

float.is_integer()


float.hex()
    Return a representation of a floating-point number as a hexadecimal
    string. For finite floating-point numbers, this representation will
    always include a leading 0x and a trailing p and exponent.

    float.hex(3740.0)
        --> '0x1.d380000000000p+11'

    Hex strings take the form
        [sign] ['0x'] integer ['.' fraction] ['p' exponent]

    The output of float.hex() is usable as a hexadecimal floating-point
    literal in C or Java code, and hexadecimal strings producehe output of
    float.hex() is usable as a hexadecimal floating-point literal in C or
    Java code, and hexadecimal strings producehe output of float.hex() is
    usable as a hexadecimal floating-point literal in C or Java code, and
    hexadecimal strings produced by C’s %a format character or Java’s
    Double.toHexString are accepted by float.fromhex().

    exponent is in base 10.

classmethod float.fromhex(s)
    Class method to return the float represented by a hexadecimal string s.
    The string s may have leading and trailing whitespace.

    float.fromhex('0x3.a7p10')
        --> 3740.0

----------------------------------------------------------------------
Deques                                              *python_deque*

collections.deque([iterable[, maxlen]])
    Thread-safe memory efficient appends and pops from either end with about
    O(1) performance in either direction.  Arbitrary length unless maxlen is
    given.  If bounded and full, an insert on one end pops an item off the
    other end.

append(x)
    Add x to the right side.
appendleft(x)
    Add x to the left side.
clear()
    Remove all elements
copy()
    Shallow copy
count()
    Return number of elements
extend(iterable)
    Extend to right
extendleft(iterable)
    Extend to left
index(x[, start[, stop]])
    Return posn of x or raises ValueError if not in
insert(i, x)
    Insert x at position i.  If i == 0, x will become the first item.
    If i >= len(deque), it's appended to the end.
pop()
    Remove and return element from right (IndexError if empty)
popleft()
    Remove and return element from left (IndexError if empty)
remove(value)
    Remove first occurrence of value (raise ValueError if not in)
reverse()
    Reverse elements in place
rotate(n=1)
    Rotate n steps to right (left in n < 0)
maxlen
    Maximum size or None if unbounded

Deques also support iteration, pickling, len(d), reversed(d), copy.copy(d),
copy.deepcopy(d), membership with in, and subscript references like d[i].
Indexed access is O(1) at ends and O(n) in middle.

Use a deque to get the last n lines of a file:
    def tail(filename, n=10):
        'Return the last n lines of a file'
        with open(filename) as f:
            return deque(f, n)

----------------------------------------------------------------------
decimal.Decimal objects                             *python_decimal*

Search for topics:
    Methods
    Contexts
        xzz Context constructor
    Rounding modes
    Signals

decimal.Decimal(value="0", context=None)

    value can be integer, string, tuple/list, float, or Decimal.  If
    tuple/list, must be (sign, sequence of digits, exponent).  Example:
    Decimal((0, (1, 4, 1, 4), -3)) returns Decimal('1.414').

    For floats, the binary floating point value is converted losslessly
    to a Decimal.  This can require more digits than you think.

    The context is used to determine what to do with a malformed string
    for value.  For example, if the context traps InvalidOperation, an
    exception is raised; otherwise, you get Decimal(NaN)

    Differs from python's mod:
        python:  (-7) % 3 gives 1
        Decimal(-7) % Decimal(3) gives Decimal(-3)

    // behaves analogously, returning the integer part of the true
    quotient (truncating towards zero) rather than its floor, so as to
    preserve the identity x == (x // y) * y + x % y:

        -7 // 4 gives -2
        Decimal(-7) // Decimal(4) gives Decimal(-1)

Methods
-------

    adjusted()  
    as_integer_ratio()
    as_tuple()
    canonical()
    compare(other, context=None)
    compare_signal(other, context=None)
    compare_total(other, context=None)
    compare_total_mag(other, context=None)
    conjugate()
    copy_abs()
    copy_negate()
    copy_sign(other, context=None)
    exp(context=None)
    fma(other, third, context=None)
    from_float(f)
    is_canonical()
    is_finite()
    is_infinite()
    is_nan()
    is_normal(context=None)
    is_qnan()
    is_signed()
    is_snan()
    is_subnormal(context=None)
    is_zero()
    ln(context=None)
    log10(context=None)
    logb(context=None)
    logical_and(other, context=None)
    logical_invert(context=None)
    logical_or(other, context=None)
    logical_xor(other, context=None)
    max(other, context=None)
    max_mag(other, context=None)
    min(other, context=None)
    min_mag(other, context=None)
    next_minus(context=None)
    next_plus(context=None)
    next_toward(other, context=None)
    normalize(context=None)
    number_class(context=None)
    quantize(exp, rounding=None, context=None)
    radix()
    remainder_near(other, context=None)
    rotate(other, context=None)
    same_quantum(other, context=None)
    scaleb(other, context=None)
    shift(other, context=None)
    sqrt(context=None)
    to_eng_string(context=None)
    to_integral(rounding=None, context=None)
    to_integral_exact(rounding=None, context=None)
    to_integral_value(rounding=None, context=None)

    adjusted()  

        Return the adjusted exponent after shifting out the coefficient’s
        rightmost digits until only the lead digit remains:
        Decimal('321e+5').adjusted() returns seven. Used for determining the
        position of the most significant digit with respect to the decimal
        point.
            
    as_integer_ratio()

        Return a pair (n, d) of integers that represent the given Decimal
        instance as a fraction, in lowest terms and with a positive
        denominator: Decimal('-3.14').as_integer_ratio() returns (-157, 50).
        The conversion is exact. Raise OverflowError on infinities and
        ValueError on NaNs.

    as_tuple()

        Return a named tuple representation of the number: DecimalTuple(sign,
        digits, exponent).

    canonical()

        Return the canonical encoding of the argument. Currently, the
        encoding of a Decimal instance is always canonical, so this operation
        returns its argument unchanged.

    compare(other, context=None)

        Compare the values of two Decimal instances. compare() returns a
        Decimal instance, and if either operand is a NaN then the result is a
        NaN:

            a or b is a NaN  ==> Decimal('NaN')
            a < b            ==> Decimal('-1')
            a == b           ==> Decimal('0')
            a > b            ==> Decimal('1')

    compare_signal(other, context=None)

        This operation is identical to the compare() method, except that all
        NaNs signal. That is, if neither operand is a signaling NaN then any
        quiet NaN operand is treated as though it were a signaling NaN.

    compare_total(other, context=None)

        Compare two operands using their abstract representation rather than
        their numerical value. Similar to the compare() method, but the
        result gives a total ordering on Decimal instances. Two Decimal
        instances with the same numeric value but different representations
        compare unequal in this ordering:

            >>> Decimal('12.0').compare_total(Decimal('12'))
            Decimal('-1')

        Quiet and signaling NaNs are also included in the total ordering. The
        result of this function is Decimal('0') if both operands have the
        same representation, Decimal('-1') if the first operand is lower in
        the total order than the second, and Decimal('1') if the first
        operand is higher in the total order than the second operand. See the
        specification for details of the total order.

        This operation is unaffected by context and is quiet: no flags are
        changed and no rounding is performed. As an exception, the C version
        may raise InvalidOperation if the second operand cannot be converted
        exactly.

    compare_total_mag(other, context=None)

        Compare two operands using their abstract representation rather than
        their value as in compare_total(), but ignoring the sign of each
        operand.  x.compare_total_mag(y) is equivalent to
        x.copy_abs().compare_total(y.copy_abs()).

        This operation is unaffected by context and is quiet: no flags are
        changed and no rounding is performed. As an exception, the C version
        may raise InvalidOperation if the second operand cannot be converted
        exactly.

    conjugate()

        Just returns self, this method is only to comply with the Decimal
        Specification.

    copy_abs()

        Return the absolute value of the argument. This operation is
        unaffected by the context and is quiet: no flags are changed and no
        rounding is performed.

    copy_negate()

        Return the negation of the argument. This operation is unaffected by
        the context and is quiet: no flags are changed and no rounding is
        performed.

    copy_sign(other, context=None)

        Return a copy of the first operand with the sign set to be the same
        as the sign of the second operand. For example:

        >>> Decimal('2.3').copy_sign(Decimal('-1.5'))
        Decimal('-2.3')

        This operation is unaffected by context and is quiet: no flags are
        changed and no rounding is performed. As an exception, the C version
        may raise InvalidOperation if the second operand cannot be converted
        exactly.

    exp(context=None)

        Return the value of the (natural) exponential function e**x at the
        given number. The result is correctly rounded using the
        ROUND_HALF_EVEN rounding mode.

        >>> Decimal(1).exp()
        Decimal('2.718281828459045235360287471')
        >>> Decimal(321).exp()
        Decimal('2.561702493119680037517373933E+139')

    from_float(f)

        Classmethod that converts a float to a decimal number, exactly.

        Note Decimal.from_float(0.1) is not the same as Decimal(‘0.1’). Since
        0.1 is not exactly representable in binary floating point, the value
        is stored as the nearest representable value which is
        0x1.999999999999ap-4.  That equivalent value in decimal is
        0.1000000000000000055511151231257827021181583404541015625.

        Note: From Python 3.2 onwards, a Decimal instance can also be
        constructed directly from a float.

            >>> Decimal.from_float(0.1)
            Decimal('0.1000000000000000055511151231257827021181583404541015625')
            >>> Decimal.from_float(float('nan'))
            Decimal('NaN')
            >>> Decimal.from_float(float('inf'))
            Decimal('Infinity')
            >>> Decimal.from_float(float('-inf'))
            Decimal('-Infinity')

    fma(other, third, context=None)

        Fused multiply-add. Return self*other+third with no rounding of the
        intermediate product self*other.

        >>> Decimal(2).fma(3, 5)
        Decimal('11')

    is_canonical()

        Return True if the argument is canonical and False otherwise.
        Currently, a Decimal instance is always canonical, so this operation
        always returns True.

    is_finite()

        Return True if the argument is a finite number, and False if the
        argument is an infinity or a NaN.

    is_infinite()

        Return True if the argument is either positive or negative infinity
        and False otherwise.

    is_nan()

        Return True if the argument is a (quiet or signaling) NaN and False
        otherwise.

    is_normal(context=None)

        Return True if the argument is a normal finite number. Return False
        if the argument is zero, subnormal, infinite or a NaN.

    is_qnan()

        Return True if the argument is a quiet NaN, and False otherwise.

    is_signed()

        Return True if the argument has a negative sign and False otherwise.
        Note that zeros and NaNs can both carry signs.

    is_snan()

        Return True if the argument is a signaling NaN and False otherwise.

    is_subnormal(context=None)

        Return True if the argument is subnormal, and False otherwise.

    is_zero()

        Return True if the argument is a (positive or negative) zero and
        False otherwise.

    ln(context=None)

        Return the natural (base e) logarithm of the operand. The result is
        correctly rounded using the ROUND_HALF_EVEN rounding mode.

    log10(context=None)

        Return the base ten logarithm of the operand. The result is correctly
        rounded using the ROUND_HALF_EVEN rounding mode.

    logb(context=None)

        For a nonzero number, return the adjusted exponent of its operand as
        a Decimal instance. If the operand is a zero then
        Decimal('-Infinity') is returned and the DivisionByZero flag is
        raised. If the operand is an infinity then Decimal('Infinity') is
        returned.

    logical_and(other, context=None)

        logical_and() is a logical operation which takes two logical operands
        (see Logical operands). The result is the digit-wise and of the two
        operands.

    logical_invert(context=None)

        logical_invert() is a logical operation. The result is the digit-wise
        inversion of the operand.

    logical_or(other, context=None)

        logical_or() is a logical operation which takes two logical operands
        (see Logical operands). The result is the digit-wise or of the two
        operands.

    logical_xor(other, context=None)

        logical_xor() is a logical operation which takes two logical operands
        (see Logical operands). The result is the digit-wise exclusive or of
        the two operands.

    max(other, context=None)

        Like max(self, other) except that the context rounding rule is
        applied before returning and that NaN values are either signaled or
        ignored (depending on the context and whether they are signaling or
        quiet).

    max_mag(other, context=None)

        Similar to the max() method, but the comparison is done using the
        absolute values of the operands.

    min(other, context=None)

        Like min(self, other) except that the context rounding rule is
        applied before returning and that NaN values are either signaled or
        ignored (depending on the context and whether they are signaling or
        quiet).

    min_mag(other, context=None)

        Similar to the min() method, but the comparison is done using the
        absolute values of the operands.

    next_minus(context=None)

        Return the largest number representable in the given context (or in
        the current thread’s context if no context is given) that is smaller
        than the given operand.

    next_plus(context=None)

        Return the smallest number representable in the given context (or in
        the current thread’s context if no context is given) that is larger
        than the given operand.

    next_toward(other, context=None)

        If the two operands are unequal, return the number closest to the
        first operand in the direction of the second operand. If both
        operands are numerically equal, return a copy of the first operand
        with the sign set to be the same as the sign of the second operand.

    normalize(context=None)

        Normalize the number by stripping the rightmost trailing zeros and
        converting any result equal to Decimal('0') to Decimal('0e0'). Used
        for producing canonical values for attributes of an equivalence
        class. For example, Decimal('32.100') and Decimal('0.321000e+2') both
        normalize to the equivalent value Decimal('32.1').

    number_class(context=None)

        Return a string describing the class of the operand. The returned
        value is one of the following ten strings.

            "-Infinity", indicating that the operand is negative infinity.
            "-Normal", indicating that the operand is a negative normal number.
            "-Subnormal", indicating that the operand is negative and subnormal.
            "-Zero", indicating that the operand is a negative zero.
            "+Zero", indicating that the operand is a positive zero.
            "+Subnormal", indicating that the operand is positive and subnormal.
            "+Normal", indicating that the operand is a positive normal number.
            "+Infinity", indicating that the operand is positive infinity.
            "NaN", indicating that the operand is a quiet NaN (Not a Number).
            "sNaN", indicating that the operand is a signaling NaN.

    quantize(exp, rounding=None, context=None)

        Return a value equal to the first operand after rounding and having
        the exponent of the second operand.

        >>> Decimal('1.41421356').quantize(Decimal('1.000'))
        Decimal('1.414')

        Unlike other operations, if the length of the coefficient after the
        quantize operation would be greater than precision, then an
        InvalidOperation is signaled. This guarantees that, unless there is
        an error condition, the quantized exponent is always equal to that of
        the right-hand operand.

        Also unlike other operations, quantize never signals Underflow, even
        if the result is subnormal and inexact.

        If the exponent of the second operand is larger than that of the
        first then rounding may be necessary. In this case, the rounding mode
        is determined by the rounding argument if given, else by the given
        context argument; if neither argument is given the rounding mode of
        the current thread’s context is used.

        An error is returned whenever the resulting exponent is greater than
        Emax or less than Etiny.

    radix()

        Return Decimal(10), the radix (base) in which the Decimal class does
        all its arithmetic. Included for compatibility with the
        specification.

    remainder_near(other, context=None)

        Return the remainder from dividing self by other. This differs from
        self % other in that the sign of the remainder is chosen so as to
        minimize its absolute value. More precisely, the return value is 
        self - n*other where n is the integer nearest to the exact value of
        self/other, and if two integers are equally near then the even one is
        chosen.

        If the result is zero then its sign will be the sign of self.

        >>> Decimal(18).remainder_near(Decimal(10))
        Decimal('-2')
        >>> Decimal(25).remainder_near(Decimal(10))
        Decimal('5')
        >>> Decimal(35).remainder_near(Decimal(10))
        Decimal('-5')

    rotate(other, context=None)

        Return the result of rotating the digits of the first operand by an
        amount specified by the second operand. The second operand must be an
        integer in the range -precision through precision. The absolute value
        of the second operand gives the number of places to rotate. If the
        second operand is positive then rotation is to the left; otherwise
        rotation is to the right. The coefficient of the first operand is
        padded on the left with zeros to length precision if necessary. The
        sign and exponent of the first operand are unchanged.

    same_quantum(other, context=None)

        Test whether self and other have the same exponent or whether both
        are NaN.

        This operation is unaffected by context and is quiet: no flags are
        changed and no rounding is performed. As an exception, the C version
        may raise InvalidOperation if the second operand cannot be converted
        exactly.

    scaleb(other, context=None)

        Return the first operand with exponent adjusted by the second.
        Equivalently, return the first operand multiplied by 10**other. The
        second operand must be an integer.

    shift(other, context=None)

        Return the result of shifting the digits of the first operand by an
        amount specified by the second operand. The second operand must be an
        integer in the range -precision through precision. The absolute value
        of the second operand gives the number of places to shift. If the
        second operand is positive then the shift is to the left; otherwise
        the shift is to the right. Digits shifted into the coefficient are
        zeros. The sign and exponent of the first operand are unchanged.

    sqrt(context=None)

        Return the square root of the argument to full precision.

    to_eng_string(context=None)

        Convert to a string, using engineering notation if an exponent is
        needed.

        Engineering notation has an exponent which is a multiple of 3. This
        can leave up to 3 digits to the left of the decimal place and may
        require the addition of either one or two trailing zeros.

        For example, this converts Decimal('123E+1') to Decimal('1.23E+3').

    to_integral(rounding=None, context=None)

        Identical to the to_integral_value() method. The to_integral name has
        been kept for compatibility with older versions.

    to_integral_exact(rounding=None, context=None)

        Round to the nearest integer, signaling Inexact or Rounded as
        appropriate if rounding occurs. The rounding mode is determined by
        the rounding parameter if given, else by the given context. If
        neither parameter is given then the rounding mode of the current
        context is used.

    to_integral_value(rounding=None, context=None)

        Round to the nearest integer without signaling Inexact or Rounded. If
        given, applies rounding; otherwise, uses the rounding method in
        either the supplied context or the current context.

Contexts
--------
    Jump to xzz to get Context constructor

    Etiny()
    Etop()
    abs(x)
    add(x, y)
    canonical(x)
    clear_flags()
    clear_traps()
    compare(x, y)
    compare_signal(x, y)
    compare_total(x, y)
    compare_total_mag(x, y)
    copy()
    copy_abs(x)
    copy_decimal(num)
    copy_negate(x)
    copy_sign(x, y)
    create_decimal(num)
    create_decimal_from_float(f)
    divide(x, y)
    divide_int(x, y)
    divmod(x, y)
    exp(x)
    fma(x, y, z)
    is_canonical(x)
    is_finite(x)
    is_infinite(x)
    is_nan(x)
    is_normal(x)
    is_qnan(x)
    is_signed(x)
    is_snan(x)
    is_subnormal(x)
    is_zero(x)
    ln(x)
    log10(x)
    logb(x)
    logical_and(x, y)
    logical_invert(x)
    logical_or(x, y)
    logical_xor(x, y)
    max(x, y)
    max_mag(x, y)
    min(x, y)
    min_mag(x, y)
    minus(x)
    multiply(x, y)
    next_minus(x)
    next_plus(x)
    next_toward(x, y)
    normalize(x)
    number_class(x)
    plus(x)
    power(x, y, modulo=None)
    quantize(x, y)
    radix()
    remainder(x, y)
    remainder_near(x, y)
    rotate(x, y)
    same_quantum(x, y)
    scaleb(x, y)
    shift(x, y)
    sqrt(x)
    subtract(x, y)
    to_eng_string(x)
    to_integral_exact(x)
    to_sci_string(x)

    Contexts are environments for arithmetic operations. They govern
    precision, set rules for rounding, determine which signals are treated as
    exceptions, and limit the range for exponents.

    Each thread has its own current context which is accessed or changed
    using the getcontext() and setcontext() functions:

    decimal.getcontext()

        Return the current context for the active thread.

    decimal.setcontext(c)

        Set the current context for the active thread to c.

    You can also use the with statement and the localcontext() function to
    temporarily change the active context.

    decimal.localcontext(ctx=None)

        Return a context manager that will set the current context for the
        active thread to a copy of ctx on entry to the with-statement and
        restore the previous context when exiting the with-statement. If no
        context is specified, a copy of the current context is used.

        For example, the following code sets the current decimal precision to
        42 places, performs a calculation, and then automatically restores
        the previous context:

            from decimal import localcontext

            with localcontext() as ctx:
                ctx.prec = 42   # Perform a high precision calculation
                s = calculate_something()
            s = +s  # Round the final result back to the default precision

    New contexts can also be created using the Context constructor described
    below. In addition, the module provides three pre-made contexts:

    class decimal.BasicContext

        This is a standard context defined by the General Decimal Arithmetic
        Specification. Precision is set to nine. Rounding is set to
        ROUND_HALF_UP. All flags are cleared. All traps are enabled (treated
        as exceptions) except Inexact, Rounded, and Subnormal.

        Because many of the traps are enabled, this context is useful for
        debugging.

    class decimal.ExtendedContext

        This is a standard context defined by the General Decimal Arithmetic
        Specification. Precision is set to nine. Rounding is set to
        ROUND_HALF_EVEN. All flags are cleared. No traps are enabled (so that
        exceptions are not raised during computations).

        Because the traps are disabled, this context is useful for
        applications that prefer to have result value of NaN or Infinity
        instead of raising exceptions. This allows an application to complete
        a run in the presence of conditions that would otherwise halt the
        program.

    class decimal.DefaultContext

        This context is used by the Context constructor as a prototype for
        new contexts. Changing a field (such a precision) has the effect of
        changing the default for new contexts created by the Context
        constructor.

        This context is most useful in multi-threaded environments. Changing
        one of the fields before threads are started has the effect of
        setting system-wide defaults. Changing the fields after threads have
        started is not recommended as it would require thread synchronization
        to prevent race conditions.

        In single threaded environments, it is preferable to not use this
        context at all. Instead, simply create contexts explicitly as
        described below.

        The default values are prec=28, rounding=ROUND_HALF_EVEN, and enabled
        traps for Overflow, InvalidOperation, and DivisionByZero.

    In addition to the three supplied contexts, new contexts can be created
    with the Context constructor.

    xzz
    class decimal.Context(prec=None, rounding=None, Emin=None, Emax=None,
    capitals=None, clamp=None, flags=None, traps=None)

        Creates a new context. If a field is not specified or is None, the
        default values are copied from the DefaultContext. If the flags field
        is not specified or is None, all flags are cleared.

        prec is an integer in the range [1, MAX_PREC] that sets the precision
        for arithmetic operations in the context.

        The rounding option is one of the constants listed in the section
        Rounding Modes.

        The traps and flags fields list any signals to be set. Generally, new
        contexts should only set traps and leave the flags clear.

        The Emin and Emax fields are integers specifying the outer limits
        allowable for exponents. Emin must be in the range [MIN_EMIN, 0],
        Emax in the range [0, MAX_EMAX].

        The capitals field is either 0 or 1 (the default). If set to 1,
        exponents are printed with a capital E; otherwise, a lowercase e is
        used: Decimal('6.02e+23').

        The clamp field is either 0 (the default) or 1. If set to 1, the
        exponent e of a Decimal instance representable in this context is
        strictly limited to the range Emin - prec + 1 <= e <= Emax - prec +
        1. If clamp is 0 then a weaker condition holds: the adjusted exponent
        of the Decimal instance is at most Emax. When clamp is 1, a large
        normal number will, where possible, have its exponent reduced and a
        corresponding number of zeros added to its coefficient, in order to
        fit the exponent constraints; this preserves the value of the number
        but loses information about significant trailing zeros. For example:

        >>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')
        Decimal('1.23000E+999')

        A clamp value of 1 allows compatibility with the fixed-width decimal
        interchange formats specified in IEEE 754.

        The Context class defines several general purpose methods as well as
        a large number of methods for doing arithmetic directly in a given
        context. In addition, for each of the Decimal methods described above
        (with the exception of the adjusted() and as_tuple() methods) there
        is a corresponding Context method. For example, for a Context
        instance C and Decimal instance x, C.exp(x) is equivalent to
        x.exp(context=C). Each Context method accepts a Python integer (an
        instance of int) anywhere that a Decimal instance is accepted.

        clear_flags()

            Resets all of the flags to 0.

        clear_traps()

            Resets all of the traps to 0.

            New in version 3.3.

        copy()

            Return a duplicate of the context.

        copy_decimal(num)

            Return a copy of the Decimal instance num.

        create_decimal(num)

            Creates a new Decimal instance from num but using self as
            context. Unlike the Decimal constructor, the context precision,
            rounding method, flags, and traps are applied to the conversion.

            This is useful because constants are often given to a greater
            precision than is needed by the application. Another benefit is
            that rounding immediately eliminates unintended effects from
            digits beyond the current precision. In the following example,
            using unrounded inputs means that adding zero to a sum can change
            the result:

            >>> getcontext().prec = 3 Decimal('3.4445') + Decimal('1.0023')
            Decimal('4.45')
            >>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')
            Decimal('4.44')

            This method implements the to-number operation of the IBM
            specification. If the argument is a string, no leading or
            trailing whitespace or underscores are permitted.

        create_decimal_from_float(f)

            Creates a new Decimal instance from a float f but rounding using
            self as the context. Unlike the Decimal.from_float() class
            method, the context precision, rounding method, flags, and traps
            are applied to the conversion.

            >>> context = Context(prec=5, rounding=ROUND_DOWN)
            >>> context.create_decimal_from_float(math.pi)
            Decimal('3.1415')
            >>> context = Context(prec=5, traps=[Inexact])
            >>> context.create_decimal_from_float(math.pi)
            Traceback (most recent call last): ...  decimal.Inexact: None

            New in version 3.1.

        Etiny()

            Returns a value equal to Emin - prec + 1 which is the minimum
            exponent value for subnormal results. When underflow occurs, the
            exponent is set to Etiny.

        Etop()

            Returns a value equal to Emax - prec + 1.

        The usual approach to working with decimals is to create Decimal
        instances and then apply arithmetic operations which take place
        within the current context for the active thread. An alternative
        approach is to use context methods for calculating within a specific
        context. The methods are similar to those for the Decimal class and
        are only briefly recounted here.

        abs(x)

            Returns the absolute value of x.

        add(x, y)

            Return the sum of x and y.

        canonical(x)

            Returns the same Decimal object x.

        compare(x, y)

            Compares x and y numerically.

        compare_signal(x, y)

            Compares the values of the two operands numerically.

        compare_total(x, y)

            Compares two operands using their abstract representation.

        compare_total_mag(x, y)

            Compares two operands using their abstract representation,
            ignoring sign.

        copy_abs(x)

            Returns a copy of x with the sign set to 0.

        copy_negate(x)

            Returns a copy of x with the sign inverted.

        copy_sign(x, y)

            Copies the sign from y to x.

        divide(x, y)

            Return x divided by y.

        divide_int(x, y)

            Return x divided by y, truncated to an integer.

        divmod(x, y)

            Divides two numbers and returns the integer part of the result.

        exp(x)

            Returns e ** x.

        fma(x, y, z)

            Returns x multiplied by y, plus z.

        is_canonical(x)

            Returns True if x is canonical; otherwise returns False.

        is_finite(x)

            Returns True if x is finite; otherwise returns False.

        is_infinite(x)

            Returns True if x is infinite; otherwise returns False.

        is_nan(x)

            Returns True if x is a qNaN or sNaN; otherwise returns False.

        is_normal(x)

            Returns True if x is a normal number; otherwise returns False.

        is_qnan(x)

            Returns True if x is a quiet NaN; otherwise returns False.

        is_signed(x)

            Returns True if x is negative; otherwise returns False.

        is_snan(x)

            Returns True if x is a signaling NaN; otherwise returns False.

        is_subnormal(x)

            Returns True if x is subnormal; otherwise returns False.

        is_zero(x)

            Returns True if x is a zero; otherwise returns False.

        ln(x)

            Returns the natural (base e) logarithm of x.

        log10(x)

            Returns the base 10 logarithm of x.

        logb(x)

            Returns the exponent of the magnitude of the operand’s MSD.

        logical_and(x, y)

            Applies the logical operation and between each operand’s digits.

        logical_invert(x)

            Invert all the digits in x.

        logical_or(x, y)

            Applies the logical operation or between each operand’s digits.

        logical_xor(x, y)

            Applies the logical operation xor between each operand’s digits.

        max(x, y)

            Compares two values numerically and returns the maximum.

        max_mag(x, y)

            Compares the values numerically with their sign ignored.

        min(x, y)

            Compares two values numerically and returns the minimum.

        min_mag(x, y)

            Compares the values numerically with their sign ignored.

        minus(x)

            Minus corresponds to the unary prefix minus operator in Python.

        multiply(x, y)

            Return the product of x and y.

        next_minus(x)

            Returns the largest representable number smaller than x.

        next_plus(x)

            Returns the smallest representable number larger than x.

        next_toward(x, y)

            Returns the number closest to x, in direction towards y.

        normalize(x)

            Reduces x to its simplest form.

        number_class(x)

            Returns an indication of the class of x.

        plus(x)

            Plus corresponds to the unary prefix plus operator in Python.
            This operation applies the context precision and rounding, so it
            is not an identity operation.

        power(x, y, modulo=None)

            Return x to the power of y, reduced modulo modulo if given.

            With two arguments, compute x**y. If x is negative then y must be
            integral. The result will be inexact unless y is integral and the
            result is finite and can be expressed exactly in ‘precision’
            digits. The rounding mode of the context is used. Results are
            always correctly-rounded in the Python version.

            Changed in version 3.3: The C module computes power() in terms of
            the correctly-rounded exp() and ln() functions. The result is
            well-defined but only “almost always correctly-rounded”.

            With three arguments, compute (x**y) % modulo. For the three
            argument form, the following restrictions on the arguments hold:

                    all three arguments must be integral

                    y must be nonnegative

                    at least one of x or y must be nonzero

                    modulo must be nonzero and have at most ‘precision’
                    digits

            The value resulting from Context.power(x, y, modulo) is equal to
            the value that would be obtained by computing (x**y) % modulo
            with unbounded precision, but is computed more efficiently. The
            exponent of the result is zero, regardless of the exponents of x,
            y and modulo. The result is always exact.

        quantize(x, y)

            Returns a value equal to x (rounded), having the exponent of y.

        radix()

            Just returns 10, as this is Decimal, :)

        remainder(x, y)

            Returns the remainder from integer division.

            The sign of the result, if non-zero, is the same as that of the
            original dividend.

        remainder_near(x, y)

            Returns x - y * n, where n is the integer nearest the exact value
            of x / y (if the result is 0 then its sign will be the sign of
            x).

        rotate(x, y)

            Returns a rotated copy of x, y times.

        same_quantum(x, y)

            Returns True if the two operands have the same exponent.

        scaleb(x, y)

            Returns the first operand after adding the second value its exp.

        shift(x, y)

            Returns a shifted copy of x, y times.

        sqrt(x)

            Square root of a non-negative number to context precision.

        subtract(x, y)

            Return the difference between x and y.

        to_eng_string(x)

            Convert to a string, using engineering notation if an exponent is
            needed.

            Engineering notation has an exponent which is a multiple of 3.
            This can leave up to 3 digits to the left of the decimal place
            and may require the addition of either one or two trailing zeros.

        to_integral_exact(x)

            Rounds to an integer.

        to_sci_string(x)

            Converts a number to a string using scientific notation.

Rounding modes
    decimal.ROUND_CEILING
        Round towards Infinity.
    decimal.ROUND_DOWN
        Round towards zero.
    decimal.ROUND_FLOOR
        Round towards -Infinity.
    decimal.ROUND_HALF_DOWN
        Round to nearest with ties going towards zero.
    decimal.ROUND_HALF_EVEN
        Round to nearest with ties going to nearest even integer.
    decimal.ROUND_HALF_UP
        Round to nearest with ties going away from zero.
    decimal.ROUND_UP
        Round away from zero.
    decimal.ROUND_05UP
        Round away from zero if last digit after rounding towards zero would have been 0 or 5; otherwise round towards zero.

Signals

    Signals represent conditions that arise during computation. Each
    corresponds to one context flag and one context trap enabler.

    The context flag is set whenever the condition is encountered. After the
    computation, flags may be checked for informational purposes (for
    instance, to determine whether a computation was exact). After checking
    the flags, be sure to clear all flags before starting the next
    computation.

    If the context’s trap enabler is set for the signal, then the condition
    causes a Python exception to be raised. For example, if the
    DivisionByZero trap is set, then a DivisionByZero exception is raised
    upon encountering the condition.

    class decimal.Clamped

        Altered an exponent to fit representation constraints.

        Typically, clamping occurs when an exponent falls outside the
        context’s Emin and Emax limits. If possible, the exponent is reduced
        to fit by adding zeros to the coefficient.

    class decimal.DecimalException

        Base class for other signals and a subclass of ArithmeticError.

    class decimal.DivisionByZero

        Signals the division of a non-infinite number by zero.

        Can occur with division, modulo division, or when raising a number to
        a negative power. If this signal is not trapped, returns Infinity or
        -Infinity with the sign determined by the inputs to the calculation.

    class decimal.Inexact

        Indicates that rounding occurred and the result is not exact.

        Signals when non-zero digits were discarded during rounding. The
        rounded result is returned. The signal flag or trap is used to detect
        when results are inexact.

    class decimal.InvalidOperation

        An invalid operation was performed.

        Indicates that an operation was requested that does not make sense.
        If not trapped, returns NaN. Possible causes include:

            Infinity - Infinity
            0 * Infinity
            Infinity / Infinity
            x % 0
            Infinity % x
            sqrt(-x) and x > 0
            0 ** 0
            x ** (non-integer)
            x ** Infinity

    class decimal.Overflow

        Numerical overflow.

        Indicates the exponent is larger than Emax after rounding has
        occurred. If not trapped, the result depends on the rounding mode,
        either pulling inward to the largest representable finite number or
        rounding outward to Infinity. In either case, Inexact and Rounded are
        also signaled.

    class decimal.Rounded

        Rounding occurred though possibly no information was lost.

        Signaled whenever rounding discards digits; even if those digits are
        zero (such as rounding 5.00 to 5.0). If not trapped, returns the
        result unchanged. This signal is used to detect loss of significant
        digits.

    class decimal.Subnormal

        Exponent was lower than Emin prior to rounding.

        Occurs when an operation result is subnormal (the exponent is too
        small). If not trapped, returns the result unchanged.

    class decimal.Underflow

        Numerical underflow with result rounded to zero.

        Occurs when a subnormal result is pushed to zero by rounding. Inexact
        and Subnormal are also signaled.

    class decimal.FloatOperation

        Enable stricter semantics for mixing floats and Decimals.

        If the signal is not trapped (default), mixing floats and Decimals is
        permitted in the Decimal constructor, create_decimal() and all
        comparison operators. Both conversion and comparisons are exact. Any
        occurrence of a mixed operation is silently recorded by setting
        FloatOperation in the context flags. Explicit conversions with
        from_float() or create_decimal_from_float() do not set the flag.

        Otherwise (the signal is trapped), only equality comparisons and
        explicit conversions are silent. All other mixed operations raise
        FloatOperation.

    The following table summarizes the hierarchy of signals:

        exceptions.ArithmeticError(exceptions.Exception)
            DecimalException
                Clamped
                DivisionByZero(DecimalException, exceptions.ZeroDivisionError)
                Inexact
                    Overflow(Inexact, Rounded)
                    Underflow(Inexact, Rounded, Subnormal)
                InvalidOperation
                Rounded
                Subnormal
                FloatOperation(DecimalException, exceptions.TypeError)

----------------------------------------------------------------------
Collections                                     *python_collections*

deque
namedtuple

deque([iterable[, maxlen]])
    Thread-safe efficient push/pops from ends.  Indexed access; O(1) at ends,
    O(n) at middle (almost certainly a linked list implementation).

    append(x)       Add x to the right side of the deque.
    appendleft(x)
    clear()
    copy()          Shallow copy
    count(x)        Num elements == x
    extend(iter)    Extend right side
    extendleft(iter)
    index(x[, start[, stop]])
    insert(posn, x)
    pop()           Remove element from right
    popleft()
    remove(value)
    reverse()
    rotate(n=1)     Rotate n steps to the right. If n < 0, rotate left.

    maxlen  Attribute None or maximum size

namedtuple(typename, field_names, *, rename=False, defaults=None,
           module=None)
    typename is a string
    field_names is seq of str or e.g. 'ab cd ef'.

    Example:
        Point = namedtuple("Point", "x y")
        p = Point(11, y=22)
        p[0] + p[1] --> 33  # indexable
        x, y = p    # unpack
        p.x + p.y   # Get parts by field names
        repr(p) --> Point(x=11, y=22)

    Methods:
        _make(iterable)  Make new instance from iterable
        _asdict()        Returns a new dict which maps names to values
        _replace(**kw)   New instance with replaced values
        _fields          Tuple of field name strings
        _field_defaults  Return dict mapping names to defaults

----------------------------------------------------------------------
subprocess                                      *python_subprocess*

Run a program/script
    # sys.executable is the python executable you're running
    cmd = [sys.executable, python_script]
    r = subprocess.run(cmd, capture_output=True)

    r is a CompletedProcess instance with attributes
        args            Arguments
        returncode      Integer value
        stdout          Text from stdout (bytes)
        stderr          Text from stderr (bytes)

    Use encoding="UTF-8" to get text instead of bytes in the output streams.

    r.check_returncode() will raise a CalledProcessError exception if
    the return code was nonzero.

    Example:  Run a command as a string
        cmd = "d:/cygwin64/bin/ls.exe --color=auto --group-directories-first"
        subprocess.run(cmd, shell=True, check=True)
        # Note you need to use the shell=True feature to get this to work

    Example:  Run a command list
        cmd = ["d:/cygwin64/bin/ls.exe", "--color=auto", 
            "--group-directories-first"]
        subprocess.run(cmd)

Starting a file with its registered application
    f = 'myfile.html'
    subprocess.run(['d:/cygwin64/bin/cygstart.exe', f])

Editing a temporary file
    with tempfile.NamedTemporaryFile() as temp:
        subprocess.call(['vi', temp.name])
        text = P(temp.name).read_text()
    Now you have the text of the file.  You can use Popen instead of call;
    the difference is that call() blocks and waits for the return code.
    Use  
        file = tempfile.mkstemp(suffix=".txt", prefix="pye_", text=True)[1]
    if you want to keep the file name around.  You'll have to remember to
    delete the file.

Here's how to use subprocess to invoke a program and capture its
output (this is preferred over the old method of popen()):
    p = subprocess.PIPE
    s = subprocess.Popen((hg, "status", "-A"), stdout=p, stderr=p)
    print("stdout:")
    print(s.stdout.readlines())
    print("stderr:")
    print(s.stderr.readlines())

    As another example, you can use the C:/cygwin/bin/cygpath.exe
    utility to translate paths back and forth between Windows and UNIX
    forms.  Here's an example of changing '/tools' to a DOS path:

        import subprocess
        cygwin = "c:/cygwin/bin/cygpath.exe"
        p = subprocess.PIPE
        s = subprocess.Popen((cygwin, "-w", "/tools"), stdout=p, stderr=p)
        errlines = s.stderr.readlines()
        if errlines:
            # Had an error, so print error message and exit
            err("Error:")
            for i in errlines:
                err("  ", i)
            exit(1)
        lines = [i.strip() for i in s.stdout.readlines()]
        assert len(lines) == 1
        print(lines[0].replace("\\", "/"))

    You can also run a command in a script and have its colored output
    go to the screen:
        s = subprocess.Popen((
            "c:/cygwin/bin/egrep.exe",
            "--color=always",
            "regex",
            "file_with_words",
        ))

    I haven't figured out how to get the GNU units program to work in
    an "interactive" sense.  However, here's a way to perform a
    conversion:

        units = "d:/don/bin/bat/units_.exe"
        data = "d:/don/bin/bat/units.dat"units =
        o = subprocess.PIPE
        base = (units, "-o", "%.15g", "-f", data, "--verbose")
        cmd = base + ("m", "inches")    # Convert from meters to inches
        p = subprocess.Popen(cmd, stdout=o)
        print("Results:")
        print(p.stdout.readlines())

    results in the output

        Results:
        ['\tm = 39.3700787401575 in\n', '\tm = (1 / 0.0254) in\n']

    If you don't print to the screen, you can complete 1000 such
    conversions in around 13 s, so a few hundred will will take on the
    order of a second or so.

----------------------------------------------------------------------
Memory usage                                *python_memory_usage*

There are two modules:
    tracemalloc 
        Pros:  accurate
        Cons:  slows things down a lot
    resource
        Pros:  Fast
        Cons:  Only takes a snapshot

Here's an example of use for testing the kolor module
    from kolor import Color
    from f import flt
    from random import random
    import sys

    def MakeColors(n):
        a = []
        for i in range(n):
            c = Color(random(), random(), random())
            a.append(c)
        return a

    n = int(sys.argv[1])

    if 1:
        # Use tracemalloc
        import tracemalloc as T
        def Get():
            # Return usage in bytes
            return flt(T.get_traced_memory()[1])
        T.start()
        a = MakeColors(n)
        usage_in_bytes = Get()
        T.stop()
        print(f"{flt(usage_in_bytes/n)} bytes per Color instance (tracemalloc)")
    if 1:
        # Use resource
        import resource 
        def Get():
            # Returns RAM usage in bytes
            kB = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            return 1000*kB
        start = Get()
        a = MakeColors(n)
        finish = Get()
        usage_in_bytes = finish - start
        print(f"{flt(usage_in_bytes/n)} bytes per Color instance (resource)")

Comments:  

    I ran these techniques with the resource command (tracemalloc commented
    out):
        'for n in 1 10 100 1000 10000 ; do p mem.py $n ; done'
    Results:
        12000. bytes per Color instance (resource)
        1200. bytes per Color instance (resource)
        120. bytes per Color instance (resource)
    **  12.0 bytes per Color instance (resource)
        114. bytes per Color instance (resource)
        131. bytes per Color instance (resource)

    The result marked ** seems to be close to the truth (each instance
    should have been perhaps 5-10 bytes by my reckoning.  The tracemalloc
    module gave 4360 to 117 bytes per instance.

----------------------------------------------------------------------
Functions                                   *python_functions*

(Function listing from 3.9.5 documentation) 

__import__()   complex()      hasattr()      max()          round()
abs()          delattr()      hash()         memoryview()   set()
all()          dict()         help()         min()          setattr()
any()          dir()          hex()          next()         slice()
ascii()        divmod()       id()           object()       sorted()
bin()          enumerate()    input()        oct()          staticmethod()
bool()         eval()         int()          open()         str()
breakpoint()   exec()         isinstance()   ord()          sum()
bytearray()    filter()       issubclass()   pow()          super()
bytes()        float()        iter()         print()        tuple()
callable()     format()       len()          property()     type()
chr()          frozenset()    list()         range()        vars()
classmethod()  getattr()      locals()       repr()         zip()
compile()      globals()      map()          reversed()

abs(x)
    Return the absolute value of a number. The argument may be an
    integer, a floating point number, or an object implementing
    __abs__(). If the argument is a complex number, its magnitude is
    returned.

all(iterable)
    Return True if all elements of the iterable are true (or if the
    iterable is empty).

any(iterable)
    Return True if any element of the iterable is true. If the iterable
    is empty, return False. Equivalent to:

ascii(object)
    As repr(), return a string containing a printable representation of
    an object, but escape the non-ASCII characters in the string
    returned by repr() using \x, \u or \U escapes. This generates a
    string similar to that returned by repr() in Python 2.

bin(x)
    Convert an integer number to a binary string prefixed with “0b”. The
    result is a valid Python expression. If x is not a Python int
    object, it has to define an __index__() method that returns an
    integer. 

class bool([x])
    Return a Boolean value, i.e. one of True or False. x is converted
    using the standard truth testing procedure. If x is false or
    omitted, this returns False; otherwise it returns True. The bool
    class is a subclass of int (see Numeric Types — int, float,
    complex). It cannot be subclassed further. Its only instances are
    False and True (see Boolean Values).

breakpoint(*args, **kws)
    This function drops you into the debugger at the call site.
    Specifically, it calls sys.breakpointhook(), passing args and kws
    straight through. By default, sys.breakpointhook() calls
    pdb.set_trace() expecting no arguments. In this case, it is purely a
    convenience function so you don’t have to explicitly import pdb or
    type as much code to enter the debugger. However,
    sys.breakpointhook() can be set to some other function and
    breakpoint() will automatically call that, allowing you to drop into
    the debugger of choice.

    Raises an auditing event builtins.breakpoint with argument
    breakpointhook.

class bytearray([source[, encoding[, errors]]])
    Return a new array of bytes. The bytearray class is a mutable
    sequence of integers in the range 0 <= x < 256. It has most of the
    usual methods of mutable sequences, described in Mutable Sequence
    Types, as well as most methods that the bytes type has, see Bytes
    and Bytearray Operations.

    The optional source parameter can be used to initialize the array in
    a few different ways:

        If it is a string, you must also give the encoding (and
        optionally, errors) parameters; bytearray() then converts the
        string to bytes using str.encode().

        If it is an integer, the array will have that size and will be
        initialized with null bytes.

        If it is an object conforming to the buffer interface, a
        read-only buffer of the object will be used to initialize the
        bytes array.

        If it is an iterable, it must be an iterable of integers in the
        range 0 <= x < 256, which are used as the initial contents of
        the array.

    Without an argument, an array of size 0 is created.

class bytes([source[, encoding[, errors]]])
    Return a new “bytes” object, which is an immutable sequence of
    integers in the range 0 <= x < 256. bytes is an immutable version of
    bytearray – it has the same non-mutating methods and the same
    indexing and slicing behavior.  Same constructor arguments as
    bytearray().

callable(object)
    Return True if the object argument appears callable, False if not.
    If this returns True, it is still possible that a call fails, but if
    it is False, calling object will never succeed. Note that classes
    are callable (calling a class returns a new instance); instances are
    callable if their class has a __call__() method.

chr(i)
    Return the string representing a character whose Unicode code point
    is the integer i. For example, chr(97) returns the string 'a', while
    chr(8364) returns the string '€'. This is the inverse of ord().
    The valid range for the argument is from 0 through 1,114,111
    (0x10FFFF in base 16). ValueError will be raised if i is outside
    that range.

@classmethod
    Decorator to transform a method into a class method.  A class method
    receives the class as implicit first argument, just like an instance
    method receives the instance. 

    A class method can be called either on the class (such as C.f()) or
    on an instance (such as C().f()). The instance is ignored except for
    its class. If a class method is called for a derived class, the
    derived class object is passed as the implied first argument.

compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)
    Compile the source into a code or AST object. Code objects can be
    executed by exec() or eval(). source can either be a normal string,
    a byte string, or an AST object. Refer to the ast module
    documentation for information on how to work with AST objects.

    The filename argument should give the file from which the code was
    read; pass some recognizable value if it wasn’t read from a file
    ('<string>' is commonly used).

    The mode argument specifies what kind of code must be compiled:
        'exec':  source consists of a sequence of statements
        'eval':  source is a single expression

        'single':  source consists of a single interactive statement.
                   Expression statements that evaluate to something
                   other than None will be printed).

class complex([real[, imag]])
    Return a complex number with the value real + imag*1j or convert a
    string or number to a complex number. If the first parameter is a
    string, it will be interpreted as a complex number and the function
    must be called without a second parameter. The second parameter can
    never be a string. Each argument may be any numeric type (including
    complex). If imag is omitted, it defaults to zero and the
    constructor serves as a numeric conversion like int and float. If
    both arguments are omitted, returns 0j.

delattr(object, name: str)
    The string must be the name of one of the object’s attributes. The
    function deletes the named attribute, provided the object allows it.

class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)

dir([object])

    Without arguments, return the list of names in the current local
    scope. With an argument, attempt to return a list of valid
    attributes for that object.

    If the object has a method named __dir__(), this method will be
    called and must return the list of attributes. This allows objects
    that implement a custom __getattr__() or __getattribute__() function
    to customize the way dir() reports their attributes.

    If the object does not provide __dir__(), the function tries its
    best to gather information from the object’s __dict__ attribute, if
    defined, and from its type object. The resulting list is not
    necessarily complete, and may be inaccurate when the object has a
    custom __getattr__().

divmod(a, b)
    Take two (non complex) numbers as arguments and return a pair of
    numbers consisting of their quotient and remainder when using
    integer division. With mixed operand types, the rules for binary
    arithmetic operators apply. For integers, the result is the same as
    (a // b, a % b). For floating point numbers the result is (q, a %
    b), where q is usually math.floor(a / b) but may be 1 less than
    that. In any case q * b + a % b is very close to a, if a % b is
    non-zero it has the same sign as b, and 0 <= abs(a % b) < abs(b).

enumerate(iterable, start=0)
    Return an enumerate object. iterable must be a sequence, an
    iterator, or some other object which supports iteration. The
    __next__() method of the iterator returned by enumerate() returns a
    tuple containing a count (from start which defaults to 0) and the
    values obtained from iterating over iterable.

eval(expression[, globals[, locals]])
    The arguments are a string and optional globals and locals. If
    provided, globals must be a dictionary. If provided, locals can be
    any mapping object.

    The expression argument is parsed and evaluated as a Python
    expression (technically speaking, a condition list) using the
    globals and locals dictionaries as global and local namespace. If
    the globals dictionary is present and does not contain a value for
    the key __builtins__, a reference to the dictionary of the built-in
    module builtins is inserted under that key before expression is
    parsed. This means that expression normally has full access to the
    standard builtins module and restricted environments are propagated.
    If the locals dictionary is omitted it defaults to the globals
    dictionary. If both dictionaries are omitted, the expression is
    executed with the globals and locals in the environment where eval()
    is called. Note, eval() does not have access to the nested scopes
    (non-locals) in the enclosing environment.

    The return value is the result of the evaluated expression. Syntax
    errors are reported as exceptions. 

    This function can also be used to execute arbitrary code objects
    (such as those created by compile()). In this case pass a code
    object instead of a string. If the code object has been compiled
    with 'exec' as the mode argument, eval()’s return value will be
    None.

    Hints: dynamic execution of statements is supported by the exec()
    function. The globals() and locals() functions returns the current
    global and local dictionary, respectively, which may be useful to
    pass around for use by eval() or exec().

    See ast.literal_eval() for a function that can safely evaluate
    strings with expressions containing only literals.

exec(object[, globals[, locals]])
    This function supports dynamic execution of Python code. object must
    be either a string or a code object. If it is a string, the string
    is parsed as a suite of Python statements which is then executed
    (unless a syntax error occurs). 1 If it is a code object, it is
    simply executed. In all cases, the code that’s executed is expected
    to be valid as file input (see the section “File input” in the
    Reference Manual). Be aware that the nonlocal, yield, and return
    statements may not be used outside of function definitions even
    within the context of code passed to the exec() function. The return
    value is None.

    In all cases, if the optional parts are omitted, the code is
    executed in the current scope. If only globals is provided, it must
    be a dictionary (and not a subclass of dictionary), which will be
    used for both the global and the local variables. If globals and
    locals are given, they are used for the global and local variables,
    respectively. If provided, locals can be any mapping object.
    Remember that at module level, globals and locals are the same
    dictionary. If exec gets two separate objects as globals and locals,
    the code will be executed as if it were embedded in a class
    definition.

    If the globals dictionary does not contain a value for the key
    __builtins__, a reference to the dictionary of the built-in module
    builtins is inserted under that key. That way you can control what
    builtins are available to the executed code by inserting your own
    __builtins__ dictionary into globals before passing it to exec().

    Note:  The built-in functions globals() and locals() return the
    current global and local dictionary, respectively, which may be
    useful to pass around for use as the second and third argument to
    exec().

    Note:  The default locals act as described for function locals()
    below: modifications to the default locals dictionary should not be
    attempted. Pass an explicit locals dictionary if you need to see
    effects of the code on locals after function exec() returns.

filter(function, iterable)
    Construct an iterator from those elements of iterable for which
    function returns True. iterable may be either a sequence, a
    container which supports iteration, or an iterator. If function is
    None, the identity function is assumed, that is, all elements of
    iterable that are False are removed.

    Note that filter(function, iterable) is equivalent to the generator
    expression (item for item in iterable if function(item)) if function
    is not None and (item for item in iterable if item) if function is
    None.

    See itertools.filterfalse() for the complementary function that
    returns elements of iterable for which function returns false.

class float([x])
    Return a floating point number constructed from a number or string x.

    If the argument is a string, it should contain a decimal number,
    optionally preceded by a sign, and optionally embedded in
    whitespace. The optional sign may be '+' or '-'; a '+' sign has no
    effect on the value produced. The argument may also be a string
    representing a NaN (not-a-number), or a positive or negative
    infinity. More precisely, the input must conform to the following
    grammar after leading and trailing whitespace characters are
    removed:

    sign           ::=  "+" | "-"
    infinity       ::=  "Infinity" | "inf"
    nan            ::=  "nan"
    numeric_value  ::=  floatnumber | infinity | nan
    numeric_string ::=  [sign] numeric_value

    Here floatnumber is the form of a Python floating-point literal,
    described in Floating point literals. Case is not significant, so,
    for example, “inf”, “Inf”, “INFINITY” and “iNfINity” are all
    acceptable spellings for positive infinity.

    Otherwise, if the argument is an integer or a floating point number,
    a floating point number with the same value (within Python’s
    floating point precision) is returned. If the argument is outside
    the range of a Python float, an OverflowError will be raised.

    For a general Python object x, float(x) delegates to x.__float__().
    If __float__() is not defined then it falls back to __index__().

    If no argument is given, 0.0 is returned.

format(value[, format_spec])
    Convert a value to a “formatted” representation, as controlled by
    format_spec. The interpretation of format_spec will depend on the
    type of the value argument, however there is a standard formatting
    syntax that is used by most built-in types: Format Specification
    Mini-Language.

    The default format_spec is an empty string which usually gives the
    same effect as calling str(value).

    A call to format(value, format_spec) is translated to
    type(value).__format__(value, format_spec) which bypasses the
    instance dictionary when searching for the value’s __format__()
    method. A TypeError exception is raised if the method search reaches
    object and the format_spec is non-empty, or if either the
    format_spec or the return value are not strings.

class frozenset([iterable])
    Return a new frozenset object, optionally with elements taken from
    iterable. frozenset is a built-in class. 

getattr(object, name[, default])
    Return the value of the named attribute of object. name must be a
    string. If the string is the name of one of the object’s attributes,
    the result is the value of that attribute. For example, getattr(x,
    'foobar') is equivalent to x.foobar. If the named attribute does not
    exist, default is returned if provided, otherwise AttributeError is
    raised.

globals()
    Return a dictionary representing the current global symbol table.
    This is always the dictionary of the current module (inside a
    function or method, this is the module where it is defined, not the
    module from which it is called).

hasattr(object, name: str)

hash(object)
    Return the hash value of the object (if it has one). Hash values are
    integers. They are used to quickly compare dictionary keys during a
    dictionary lookup. Numeric values that compare equal have the same
    hash value (even if they are of different types, as is the case for
    1 and 1.0).

help([object])
    Invoke the built-in help system. (This function is intended for
    interactive use.) If no argument is given, the interactive help
    system starts on the interpreter console. If the argument is a
    string, then the string is looked up as the name of a module,
    function, class, method, keyword, or documentation topic, and a help
    page is printed on the console. If the argument is any other kind of
    object, a help page on the object is generated.

hex(x)
    Convert an integer number to a lowercase hexadecimal string prefixed
    with “0x”. If x is not a Python int object, it has to define an
    __index__() method that returns an integer. 

id(object)
    Return the “identity” of an object. This is an integer which is
    guaranteed to be unique and constant for this object during its
    lifetime. Two objects with non-overlapping lifetimes may have the
    same id() value.

    CPython implementation detail: This is the address of the object in
    memory.

input([prompt])

    If the prompt argument is present, it is written to standard output
    without a trailing newline. The function then reads a line from
    input, converts it to a string (stripping a trailing newline), and
    returns that. When EOF is read, EOFError is raised. 

    If the readline module was loaded, then input() will use it to
    provide elaborate line editing and history features.

class int([x])
class int(x, base=10)
    Return an integer object constructed from a number or string x, or
    return 0 if no arguments are given. If x defines __int__(), int(x)
    returns x.__int__(). If x defines __index__(), it returns
    x.__index__(). If x defines __trunc__(), it returns x.__trunc__().
    For floating point numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in
    radix base. Optionally, the literal can be preceded by + or - (with
    no space in between) and surrounded by whitespace. A base-n literal
    consists of the digits 0 to n-1, with a to z (or A to Z) having
    values 10 to 35. The default base is 10. The allowed values are 0
    and 2–36. Base-2, -8, and -16 literals can be optionally prefixed
    with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. Base
    0 means to interpret exactly as a code literal, so that the actual
    base is 2, 8, 10, or 16, and so that int('010', 0) is not legal,
    while int('010') is, as well as int('010', 8).

isinstance(object, classinfo)
    Return True if the object argument is an instance of the classinfo
    argument, or of a (direct, indirect or virtual) subclass thereof. If
    object is not an object of the given type, the function always
    returns False. If classinfo is a tuple of type objects (or
    recursively, other such tuples), return True if object is an
    instance of any of the types. If classinfo is not a type or tuple of
    types and such tuples, a TypeError exception is raised.

issubclass(class, classinfo)
    Return True if class is a subclass (direct, indirect or virtual) of
    classinfo. A class is considered a subclass of itself. classinfo may
    be a tuple of class objects, in which case every entry in classinfo
    will be checked. In any other case, a TypeError exception is raised.

iter(object[, sentinel])
    Return an iterator object. The first argument is interpreted very
    differently depending on the presence of the second argument.
    Without a second argument, object must be a collection object which
    supports the iteration protocol (the __iter__() method), or it must
    support the sequence protocol (the __getitem__() method with integer
    arguments starting at 0). If it does not support either of those
    protocols, TypeError is raised. If the second argument, sentinel, is
    given, then object must be a callable object. The iterator created
    in this case will call object with no arguments for each call to its
    __next__() method; if the value returned is equal to sentinel,
    StopIteration will be raised, otherwise the value will be returned.

    One useful application of the second form of iter() is to build a
    block-reader. For example, reading fixed-width blocks from a binary
    database file until the end of file is reached:

    from functools import partial
    with open('mydata.db', 'rb') as f:
        for block in iter(partial(f.read, 64), b''):
            process_block(block)

len(s)
    Return the length (the number of items) of an object. The argument
    may be a sequence (such as a string, bytes, tuple, list, or range)
    or a collection (such as a dictionary, set, or frozen set).

    CPython implementation detail: len raises OverflowError on lengths
    larger than sys.maxsize (2147483647 for 3.7 cygwin), such as
    range(2**100).

class list([iterable])

    Constructor for lists.

locals()
    Update and return a dictionary representing the current local symbol
    table. Free variables are returned by locals() when it is called in
    function blocks, but not in class blocks. Note that at the module
    level, locals() and globals() are the same dictionary.

    Note: The contents of this dictionary should not be modified;
    changes may not affect the values of local and free variables used
    by the interpreter.

map(function, iterable, ...)
    Return an iterator that applies function to every item of iterable,
    yielding the results. If additional iterable arguments are passed,
    function must take that many arguments and is applied to the items
    from all iterables in parallel. With multiple iterables, the
    iterator stops when the shortest iterable is exhausted. For cases
    where the function inputs are already arranged into argument tuples,
    see itertools.starmap().

max(iterable, *[, key, default])
max(arg1, arg2, *args[, key])
    Return the largest item in an iterable or the largest of two or more
    arguments.

    If one positional argument is provided, it should be an iterable.
    The largest item in the iterable is returned. If two or more
    positional arguments are provided, the largest of the positional
    arguments is returned.

    There are two optional keyword-only arguments. The key argument
    specifies a one-argument ordering function like that used for
    list.sort(). The default argument specifies an object to return if
    the provided iterable is empty. If the iterable is empty and default
    is not provided, a ValueError is raised.

    If multiple items are maximal, the function returns the first one
    encountered. This is consistent with other sort-stability preserving
    tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and
    heapq.nlargest(1, iterable, key=keyfunc).

class memoryview(obj)
    Return a “memory view” object created from the given argument. See
    Memory Views for more information.

min(iterable, *[, key, default])
min(arg1, arg2, *args[, key])
    Return the smallest item in an iterable or the smallest of two or
    more arguments.

    If one positional argument is provided, it should be an iterable.
    The smallest item in the iterable is returned. If two or more
    positional arguments are provided, the smallest of the positional
    arguments is returned.

    There are two optional keyword-only arguments. The key argument
    specifies a one-argument ordering function like that used for
    list.sort(). The default argument specifies an object to return if
    the provided iterable is empty. If the iterable is empty and default
    is not provided, a ValueError is raised.

    If multiple items are minimal, the function returns the first one
    encountered. This is consistent with other sort-stability preserving
    tools such as sorted(iterable, key=keyfunc)[0] and
    heapq.nsmallest(1, iterable, key=keyfunc).

next(iterator[, default])
    Retrieve the next item from the iterator by calling its __next__()
    method. If default is given, it is returned if the iterator is
    exhausted, otherwise StopIteration is raised.

class object
    Return a new featureless object. object is a base for all classes.
    It has the methods that are common to all instances of Python
    classes. This function does not accept any arguments.

    Note:  object does not have a __dict__, so you can’t assign
    arbitrary attributes to an instance of the object class.

oct(x)
    Convert an integer number to an octal string prefixed with “0o”. The
    result is a valid Python expression. If x is not a Python int
    object, it has to define an __index__() method that returns an
    integer. 

open(file, mode='r', buffering=-1, encoding=None, errors=None,
     newline=None, closefd=True, opener=None)

    Open file and return a corresponding file object. If the file cannot
    be opened, an OSError is raised. See Reading and Writing Files for
    more examples of how to use this function.

    file is a path-like object giving the pathname (absolute or relative
    to the current working directory) of the file to be opened or an
    integer file descriptor of the file to be wrapped. (If a file
    descriptor is given, it is closed when the returned I/O object is
    closed, unless closefd is set to False.)

    mode is an optional string that specifies the mode in which the file
    is opened. It defaults to 'r' which means open for reading in text
    mode. Other common values are 'w' for writing (truncating the file
    if it already exists), 'x' for exclusive creation and 'a' for
    appending (which on some Unix systems, means that all writes append
    to the end of the file regardless of the current seek position). In
    text mode, if encoding is not specified the encoding used is
    platform dependent: locale.getpreferredencoding(False) is called to
    get the current locale encoding. (For reading and writing raw bytes
    use binary mode and leave encoding unspecified.) The available modes
    are:

    'r'     open for reading (default)
    'w'     open for writing, truncating the file first
    'x'     open for exclusive creation, failing if the file already exists
    'a'     open for writing, appending to the end of the file if it exists
    'b'     binary mode
    't'     text mode (default)
    '+'     open for updating (reading and writing)

    The default mode is 'r' (open for reading text, synonym of 'rt').
    Modes 'w+' and 'w+b' open and truncate the file. Modes 'r+' and
    'r+b' open the file with no truncation.

    As mentioned in the Overview, Python distinguishes between binary
    and text I/O. Files opened in binary mode (including 'b' in the mode
    argument) return contents as bytes objects without any decoding. In
    text mode (the default, or when 't' is included in the mode
    argument), the contents of the file are returned as str, the bytes
    having been first decoded using a platform-dependent encoding or
    using the specified encoding if given.

    There is an additional mode character permitted, 'U', which no
    longer has any effect, and is considered deprecated. It previously
    enabled universal newlines in text mode, which became the default
    behaviour in Python 3.0. Refer to the documentation of the newline
    parameter for further details.

    Note: Python doesn’t depend on the underlying operating system’s
    notion of text files; all the processing is done by Python itself,
    and is therefore platform-independent.

    buffering is an optional integer used to set the buffering policy.
    Pass 0 to switch buffering off (only allowed in binary mode), 1 to
    select line buffering (only usable in text mode), and an integer > 1
    to indicate the size in bytes of a fixed-size chunk buffer. When no
    buffering argument is given, the default buffering policy works as
    follows:

        Binary files are buffered in fixed-size chunks; the size of the
        buffer is chosen using a heuristic trying to determine the
        underlying device’s “block size” and falling back on
        io.DEFAULT_BUFFER_SIZE. On many systems, the buffer will
        typically be 4096 or 8192 bytes long.

        “Interactive” text files (files for which isatty() returns True)
        use line buffering. Other text files use the policy described
        above for binary files.

    encoding is the name of the encoding used to decode or encode the
    file. This should only be used in text mode. The default encoding is
    platform dependent (whatever locale.getpreferredencoding() returns),
    but any text encoding supported by Python can be used. See the
    codecs module for the list of supported encodings.

    errors is an optional string that specifies how encoding and
    decoding errors are to be handled—this cannot be used in binary
    mode. A variety of standard error handlers are available (listed
    under Error Handlers), though any error handling name that has been
    registered with codecs.register_error() is also valid. The standard
    names include:

        'strict' to raise a ValueError exception if there is an encoding
        error. The default value of None has the same effect.

        'ignore' ignores errors. Note that ignoring encoding errors can
        lead to data loss.

        'replace' causes a replacement marker (such as '?') to be
        inserted where there is malformed data.

        'surrogateescape' will represent any incorrect bytes as code
        points in the Unicode Private Use Area ranging from U+DC80 to
        U+DCFF. These private code points will then be turned back into
        the same bytes when the surrogateescape error handler is used
        when writing data. This is useful for processing files in an
        unknown encoding.

        'xmlcharrefreplace' is only supported when writing to a file.
        Characters not supported by the encoding are replaced with the
        appropriate XML character reference &#nnn;.

        'backslashreplace' replaces malformed data by Python’s
        backslashed escape sequences.

        'namereplace' (also only supported when writing) replaces
        unsupported characters with \N{...} escape sequences.

    newline controls how universal newlines mode works (it only applies
    to text mode). It can be None, '', '\n', '\r', and '\r\n'. It works
    as follows:

        When reading input from the stream, if newline is None,
        universal newlines mode is enabled. Lines in the input can end
        in '\n', '\r', or '\r\n', and these are translated into '\n'
        before being returned to the caller. If it is '', universal
        newlines mode is enabled, but line endings are returned to the
        caller untranslated. If it has any of the other legal values,
        input lines are only terminated by the given string, and the
        line ending is returned to the caller untranslated.

        When writing output to the stream, if newline is None, any '\n'
        characters written are translated to the system default line
        separator, os.linesep. If newline is '' or '\n', no translation
        takes place. If newline is any of the other legal values, any
        '\n' characters written are translated to the given string.

    If closefd is False and a file descriptor rather than a filename was
    given, the underlying file descriptor will be kept open when the
    file is closed. If a filename is given closefd must be True (the
    default) otherwise an error will be raised.

    A custom opener can be used by passing a callable as opener. The
    underlying file descriptor for the file object is then obtained by
    calling opener with (file, flags). opener must return an open file
    descriptor (passing os.open as opener results in functionality
    similar to passing None).

    The newly created file is non-inheritable.

ord(c)
    Given a string representing one Unicode character, return an integer
    representing the Unicode code point of that character. 

pow(base, exp[, mod])
    Return base to the power exp; if mod is present, return base to the
    power exp, modulo mod (computed more efficiently than pow(base, exp)
    % mod). The two-argument form pow(base, exp) is equivalent to using
    the power operator: base**exp.

    The arguments must have numeric types. With mixed operand types, the
    coercion rules for binary arithmetic operators apply. For int
    operands, the result has the same type as the operands (after
    coercion) unless the second argument is negative; in that case, all
    arguments are converted to float and a float result is delivered.
    For example, 10**2 returns 100, but 10**-2 returns 0.01.

    For int operands base and exp, if mod is present, mod must also be
    of integer type and mod must be nonzero. If mod is present and exp
    is negative, base must be relatively prime to mod. In that case,
    pow(inv_base, -exp, mod) is returned, where inv_base is an inverse
    to base modulo mod.

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
    Print objects to the text stream file, separated by sep and followed
    by end. sep, end, file and flush, if present, must be given as
    keyword arguments.

    All non-keyword arguments are converted to strings like str() does
    and written to the stream, separated by sep and followed by end.
    Both sep and end must be strings; they can also be None, which means
    to use the default values. If no objects are given, print() will
    just write end.

    The file argument must be an object with a write(string) method; if
    it is not present or None, sys.stdout will be used. Since printed
    arguments are converted to text strings, print() cannot be used with
    binary mode file objects. For these, use file.write(...) instead.

    Whether output is buffered is usually determined by file, but if the
    flush keyword argument is true, the stream is forcibly flushed.

class property(fget=None, fset=None, fdel=None, doc=None)
    Return a property attribute.

    fget is a function for getting an attribute value. fset is a
    function for setting an attribute value. fdel is a function for
    deleting an attribute value. And doc creates a docstring for the
    attribute.

    A typical use is to define a managed attribute x:

    class C:
        def __init__(self):
            self._x = None

        def getx(self):
            return self._x

        def setx(self, value):
            self._x = value

        def delx(self):
            del self._x

        x = property(getx, setx, delx, "I'm the 'x' property.")

    If c is an instance of C, c.x will invoke the getter, c.x = value
    will invoke the setter and del c.x the deleter.

    If given, doc will be the docstring of the property attribute.
    Otherwise, the property will copy fget’s docstring (if it exists).
    This makes it possible to create read-only properties easily using
    property() as a decorator:

    class Parrot:
        def __init__(self):
            self._voltage = 100000

        @property
        def voltage(self):
            """Get the current voltage."""
            return self._voltage

    The @property decorator turns the voltage() method into a “getter”
    for a read-only attribute with the same name, and it sets the
    docstring for voltage to “Get the current voltage.”

    A property object has getter, setter, and deleter methods usable as
    decorators that create a copy of the property with the corresponding
    accessor function set to the decorated function. This is best
    explained with an example:

    class C:
        def __init__(self):
            self._x = None

        @property
        def x(self):
            """I'm the 'x' property."""
            return self._x

        @x.setter
        def x(self, value):
            self._x = value

        @x.deleter
        def x(self):
            del self._x

    This code is exactly equivalent to the first example. Be sure to
    give the additional functions the same name as the original property
    (x in this case.)

    The returned property object also has the attributes fget, fset, and
    fdel corresponding to the constructor arguments.

class range(stop)
class range(start, stop[, step])
    Rather than being a function, range is actually an immutable
    sequence type, as documented in Ranges and Sequence Types — list,
    tuple, range.

repr(object)
    Return a string containing a printable representation of an object.
    For many types, this function makes an attempt to return a string
    that would yield an object with the same value when passed to
    eval(), otherwise the representation is a string enclosed in angle
    brackets that contains the name of the type of the object together
    with additional information often including the name and address of
    the object. A class can control what this function returns for its
    instances by defining a __repr__() method.

reversed(seq)
    Return a reverse iterator. seq must be an object which has a
    __reversed__() method or supports the sequence protocol (the
    __len__() method and the __getitem__() method with integer arguments
    starting at 0).

round(number[, ndigits])
    Return number rounded to ndigits precision after the decimal point.
    If ndigits is omitted or is None, it returns the nearest integer to
    its input.

    For the built-in types supporting round(), values are rounded to the
    closest multiple of 10 to the power minus ndigits; if two multiples
    are equally close, rounding is done toward the even choice (so, for
    example, both round(0.5) and round(-0.5) are 0, and round(1.5) is
    2). Any integer value is valid for ndigits (positive, zero, or
    negative). The return value is an integer if ndigits is omitted or
    None. Otherwise the return value has the same type as number.

    For a general Python object number, round delegates to
    number.__round__.

    Note:  The behavior of round() for floats can be surprising: for
    example, round(2.675, 2) gives 2.67 instead of the expected 2.68.
    This is not a bug: it’s a result of the fact that most decimal
    fractions can’t be represented exactly as a float. See Floating
    Point Arithmetic: Issues and Limitations for more information.

class set([iterable])
    Return a new set object, optionally with elements taken from
    iterable. set is a built-in class. See set and Set Types — set,
    frozenset for documentation about this class.

    For other containers see the built-in frozenset, list, tuple, and
    dict classes, as well as the collections module.

setattr(object, name, value)
    This is the counterpart of getattr(). The arguments are an object, a
    string and an arbitrary value. The string may name an existing
    attribute or a new attribute. The function assigns the value to the
    attribute, provided the object allows it. For example, setattr(x,
    'foobar', 123) is equivalent to x.foobar = 123.

class slice(stop)
class slice(start, stop[, step])
    Return a slice object representing the set of indices specified by
    range(start, stop, step). The start and step arguments default to
    None. Slice objects have read-only data attributes start, stop and
    step which merely return the argument values (or their default).
    They have no other explicit functionality; however they are used by
    Numerical Python and other third party extensions. Slice objects are
    also generated when extended indexing syntax is used. For example:
    a[start:stop:step] or a[start:stop, i]. See itertools.islice() for
    an alternate version that returns an iterator.

sorted(iterable, *, key=None, reverse=False)
    Return a new sorted list from the items in iterable.

    Has two optional arguments which must be specified as keyword
    arguments.

    key specifies a function of one argument that is used to extract a
    comparison key from each element in iterable (for example,
    key=str.lower). The default value is None (compare the elements
    directly).

    reverse is a boolean value. If set to True, then the list elements
    are sorted as if each comparison were reversed.

    Use functools.cmp_to_key() to convert an old-style cmp function to a
    key function.

    The built-in sorted() function is guaranteed to be stable. A sort is
    stable if it guarantees not to change the relative order of elements
    that compare equal — this is helpful for sorting in multiple passes
    (for example, sort by department, then by salary grade).

    For sorting examples and a brief sorting tutorial, see Sorting HOW TO.

@staticmethod
    Transform a method into a static method.

    A static method does not receive an implicit first argument. To
    declare a static method, use this idiom:

        class C:
            @staticmethod
            def f(arg1, arg2, ...): ...

    The @staticmethod form is a function decorator – see Function
    definitions for details.

    A static method can be called either on the class (such as C.f()) or
    on an instance (such as C().f()).

    Static methods in Python are similar to those found in Java or C++.
    Also see classmethod() for a variant that is useful for creating
    alternate class constructors.

    Like all decorators, it is also possible to call staticmethod as a
    regular function and do something with its result. This is needed in
    some cases where you need a reference to a function from a class
    body and you want to avoid the automatic transformation to instance
    method. For these cases, use this idiom:

    class C:
        builtin_open = staticmethod(open)

    For more information on static methods, see The standard type hierarchy.

class str(object='')
class str(object=b'', encoding='utf-8', errors='strict')
    Return a str version of object. See str() for details.

    str is the built-in string class. For general information about
    strings, see Text Sequence Type — str.

sum(iterable, /, start=0)
    Sums start and the items of an iterable from left to right and
    returns the total. The iterable’s items are normally numbers, and
    the start value is not allowed to be a string.

    For some use cases, there are good alternatives to sum(). The
    preferred, fast way to concatenate a sequence of strings is by
    calling ''.join(sequence). To add floating point values with
    extended precision, see math.fsum(). To concatenate a series of
    iterables, consider using itertools.chain().

super([type[, object-or-type]])
    Return a proxy object that delegates method calls to a parent or
    sibling class of type. This is useful for accessing inherited
    methods that have been overridden in a class.

    The object-or-type determines the method resolution order to be
    searched. The search starts from the class right after the type.

    For example, if __mro__ of object-or-type is D -> B -> C -> A ->
    object and the value of type is B, then super() searches C -> A ->
    object.

    The __mro__ attribute of the object-or-type lists the method
    resolution search order used by both getattr() and super(). The
    attribute is dynamic and can change whenever the inheritance
    hierarchy is updated.

    If the second argument is omitted, the super object returned is
    unbound. If the second argument is an object, isinstance(obj, type)
    must be true. If the second argument is a type, issubclass(type2,
    type) must be true (this is useful for classmethods).

    There are two typical use cases for super. In a class hierarchy with
    single inheritance, super can be used to refer to parent classes
    without naming them explicitly, thus making the code more
    maintainable. This use closely parallels the use of super in other
    programming languages.

    The second use case is to support cooperative multiple inheritance
    in a dynamic execution environment. This use case is unique to
    Python and is not found in statically compiled languages or
    languages that only support single inheritance. This makes it
    possible to implement “diamond diagrams” where multiple base classes
    implement the same method. Good design dictates that such
    implementations have the same calling signature in every case
    (because the order of calls is determined at runtime, because that
    order adapts to changes in the class hierarchy, and because that
    order can include sibling classes that are unknown prior to
    runtime).

    For both use cases, a typical superclass call looks like this:

    class C(B):
        def method(self, arg):
            super().method(arg)    # This does the same thing as:
                                   # super(C, self).method(arg)

    In addition to method lookups, super() also works for attribute
    lookups. One possible use case for this is calling descriptors in a
    parent or sibling class.

    Note that super() is implemented as part of the binding process for
    explicit dotted attribute lookups such as super().__getitem__(name).
    It does so by implementing its own __getattribute__() method for
    searching classes in a predictable order that supports cooperative
    multiple inheritance. Accordingly, super() is undefined for implicit
    lookups using statements or operators such as super()[name].

    Also note that, aside from the zero argument form, super() is not
    limited to use inside methods. The two argument form specifies the
    arguments exactly and makes the appropriate references. The zero
    argument form only works inside a class definition, as the compiler
    fills in the necessary details to correctly retrieve the class being
    defined, as well as accessing the current instance for ordinary
    methods.

    For practical suggestions on how to design cooperative classes using
    super(), see guide to using super().

class tuple([iterable])
    Rather than being a function, tuple is actually an immutable
    sequence type, as documented in Tuples and Sequence Types — list,
    tuple, range.

class type(object)
class type(name, bases, dict, **kwds)
    With one argument, return the type of an object. The return value is
    a type object and generally the same object as returned by
    object.__class__.

    The isinstance() built-in function is recommended for testing the
    type of an object, because it takes subclasses into account.

    With three arguments, return a new type object. This is essentially
    a dynamic form of the class statement. The name string is the class
    name and becomes the __name__ attribute. The bases tuple contains
    the base classes and becomes the __bases__ attribute; if empty,
    object, the ultimate base of all classes, is added. The dict
    dictionary contains attribute and method definitions for the class
    body; it may be copied or wrapped before becoming the __dict__
    attribute. 

vars([object])
    Return the __dict__ attribute for a module, class, instance, or any
    other object with a __dict__ attribute.

    Objects such as modules and instances have an updateable __dict__
    attribute; however, other objects may have write restrictions on
    their __dict__ attributes (for example, classes use a
    types.MappingProxyType to prevent direct dictionary updates).

    Without an argument, vars() acts like locals(). Note, the locals
    dictionary is only useful for reads since updates to the locals
    dictionary are ignored.

    A TypeError exception is raised if an object is specified but it
    doesn’t have a __dict__ attribute (for example, if its class defines
    the __slots__ attribute).

zip(*iterables)
    Make an iterator that aggregates elements from each of the
    iterables.

    Returns an iterator of tuples, where the i-th tuple contains the
    i-th element from each of the argument sequences or iterables. The
    iterator stops when the shortest input iterable is exhausted. With a
    single iterable argument, it returns an iterator of 1-tuples. With
    no arguments, it returns an empty iterator. Equivalent to:

    def zip(*iterables):
        # zip('ABCD', 'xy') --> Ax By
        sentinel = object()
        iterators = [iter(it) for it in iterables]
        while iterators:
            result = []
            for it in iterators:
                elem = next(it, sentinel)
                if elem is sentinel:
                    return
                result.append(elem)
            yield tuple(result)

    The left-to-right evaluation order of the iterables is guaranteed.
    This makes possible an idiom for clustering a data series into
    n-length groups using zip(*[iter(s)]*n). This repeats the same
    iterator n times so that each output tuple has the result of n calls
    to the iterator. This has the effect of dividing the input into
    n-length chunks.

    zip() should only be used with unequal length inputs when you don’t
    care about trailing, unmatched values from the longer iterables. If
    those values are important, use itertools.zip_longest() instead.

    zip() in conjunction with the * operator can be used to unzip a
    list:

    >>> x = [1, 2, 3]
    >>> y = [4, 5, 6]
    >>> zipped = zip(x, y)
    >>> list(zipped)
    [(1, 4), (2, 5), (3, 6)]
    >>> x2, y2 = zip(*zip(x, y))
    >>> x == list(x2) and y == list(y2)
    True

__import__(name, globals=None, locals=None, fromlist=(), level=0)

    This is an advanced function that is not needed in everyday Python
    programming, unlike importlib.import_module().

    This function is invoked by the import statement. It can be replaced
    (by importing the builtins module and assigning to
    builtins.__import__) in order to change semantics of the import
    statement, but doing so is strongly discouraged as it is usually
    simpler to use import hooks (see PEP 302) to attain the same goals
    and does not cause issues with code which assumes the default import
    implementation is in use. Direct use of __import__() is also
    discouraged in favor of importlib.import_module().

    The function imports the module name, potentially using the given
    globals and locals to determine how to interpret the name in a
    package context. The fromlist gives the names of objects or
    submodules that should be imported from the module given by name.
    The standard implementation does not use its locals argument at all,
    and uses its globals only to determine the package context of the
    import statement.

    level specifies whether to use absolute or relative imports. 0 (the
    default) means only perform absolute imports. Positive values for
    level indicate the number of parent directories to search relative
    to the directory of the module calling __import__() (see PEP 328 for
    the details).

    When the name variable is of the form package.module, normally, the
    top-level package (the name up till the first dot) is returned, not
    the module named by name. However, when a non-empty fromlist
    argument is given, the module named by name is returned.

    For example, the statement import spam results in bytecode
    resembling the following code:

        spam = __import__('spam', globals(), locals(), [], 0)

    The statement import spam.ham results in this call:

        spam = __import__('spam.ham', globals(), locals(), [], 0)

    Note how __import__() returns the toplevel module here because this
    is the object that is bound to a name by the import statement.

    On the other hand, the statement from spam.ham import eggs, sausage
    as saus results in

        _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
        eggs = _temp.eggs
        saus = _temp.sausage

    Here, the spam.ham module is returned from __import__(). From this
    object, the names to import are retrieved and assigned to their
    respective names.

    If you simply want to import a module (potentially within a package)
    by name, use importlib.import_module().

This is for python 3.9, last updated on May 12, 2021
----------------------------------------------------------------------
Fractions                                           *python_fractions*

Constructor
    Fraction(numerator=0, denominator=1)
    Fraction(other_fraction)
    Fraction(float)
    Fraction(decimal)
    Fraction(string)    Must be '[sign]x[/y]'

numerator
    Numerator of the Fraction in lowest term.

denominator
    Denominator of the Fraction in lowest term.

from_float(flt)
    This class method constructs a Fraction representing the exact value of
    flt, which must be a float. Beware that Fraction.from_float(0.3) is not
    the same value as Fraction(3, 10).

from_decimal(dec)
    This class method constructs a Fraction representing the exact value of
    dec, which must be a decimal.Decimal instance.

limit_denominator(max_denominator=1000000)
    Finds and returns the closest Fraction to self that has denominator at
    most max_denominator. This method is useful for finding rational
    approximations to a given floating-point number:

__floor__()
    Returns the greatest int <= self. This method can also be accessed
    through the math.floor() function.

__ceil__()
    Returns the least int >= self. This method can also be accessed through
    the math.ceil() function.

__round__()
__round__(ndigits)
    The first version returns the nearest int to self, rounding half to
    even.  The second version rounds self to the nearest multiple of
    Fraction(1, 10**ndigits) (logically, if ndigits is negative), again
    rounding half toward even. This method can also be accessed through the
    round() function.

fractions.gcd(a, b)
    Return the greatest common divisor of the integers a and b. If either a
    or b is nonzero, then the absolute value of gcd(a, b) is the largest
    integer that divides both a and b. gcd(a,b) has the same sign as b if b
    is nonzero; otherwise it takes the sign of a. gcd(0, 0) returns 0.

    Deprecated since version 3.5: Use math.gcd() instead.

--------------------------------------------------------------------------------
virtualenv                                  *python_virtualenv*

This sets up a virtual python environment for a project in a desired
project directory.  The core use case is to allow you to install the
desired python library dependencies and have this be independent of the
system python's libraries.

    Example:  your system python uses somelibrary1.5, but the application
    you're writing needs version 1.4.  Setting up a virtualenv for the
    project allows you to do this.  

    cd /tmp
    virtualenv myproject
    cd myproject
    . bin/activate

    The prompt will show that you're in this virtualenv.  'deactivate' is
    now an alias and you type that to return to your previous shell
    environment.

    Note there's a .gitignore file that contains '*'.  You don't really
    need to put this virtualenv directory under source control.  If you
    want myproject under your regular project directory, put an ignore 
    command in the project's .gitignore file to ignore the virtualenv
    directory.  Include a requirements.txt file so that others can use the
    virtualenv as needed:
            
        pip freeze >requirements.txt

    Use it with

        pip install -r requirements.txt

--------------------------------------------------------------------------------
Type hints                                  *python_typehints*

Avoiding forward reference problems:
    from __future__ import annotations
else:
    Put quotes around the forward references

from typing import Union

Num = Union[int, float, complex]

Variables
    a: int = 4
Aliases
    b: list[int] = [1, 2]
Functions
    def f(a: int, b: Num) -> Num:

vim:  wm=3
