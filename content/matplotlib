*matplotlib*

Note:  search for keywords beyond the usual text, as I've added the
docstrings from the functions at the end (search for @@@ ).

From http://matplotlib.sourceforge.net/matplotlib.pylab.html

----------------------------------------------------------------------
Plotting two plots with the same horizontal axis but different left
and right scales (two_scales.py example):

from pylab import *

ax1 = subplot(111)
t = arange(0.01, 10.0, 0.01)
s1 = exp(t)
plot(t, s1, 'b-')
xlabel('time (s)')
ylabel('exp')


# turn off the 2nd axes rectangle with frameon kwarg
ax2 = twinx()
s2 = sin(2*pi*t)
plot(t, s2, 'r.')
ylabel('sin')
ax2.yaxis.tick_right()
show()
----------------------------------------------------------------------

from pylab import *

t = arange(0, max, step, "float")
x = sin(t)

# Plot types
plot(t, x)
semilogx(t, x)
semilogy(t, x)
loglog(t, x)
hist(x, bins=10)    # Histogram
acorr(x)            # Autocorrelation
bar()               # Bar chart
boxplot()           # Box and whisker
contour()           # Contour
contourf()          # Filled contour
csd()               # Cross spectral density
fill()              # Make filled polygons
pcolor()            # Pseudocolor plot
pie()               # Pie chart
polar()             # Polar coordinate plot
    thetagrid()     # Customize the polar grid
psd()               # Power spectral density
quiver()            # Direction field plot
scatter()           # Scatter plot
specgram()          # Spectrogram plot
stem()              # Stem plot
subplot()
table()             # Add a table to the plot
text()              # Add text to the plot
xcorr(x, y)         # Plot autocorrelation between x and y

# Annotation
annotate()
xlabel("Time")
ylabel("Effect")
xlim(0, 10)  # Limit axes
ylim(0, 100)
title("Interesting Plot")
grid(True)
legend(("label1", "label2"), loc="upper left")

# Change colors
# Axis background in dark slate gray
subplot(111 , axisbg =(0.1843 , 0.3098 , 0.3098) )
# yellow circles with red edge color
plot(t, s, 'yo', markeredgecolor='r', label="Plot legend label")
xlabel('time (s)', color='b') # xlabel is blue
# Put in a horizontal line
axhline(y=0, color="r", linestyle="--")

# Put TeX stuff on the screen
xlabel(r'$\Delta_i^j$', fontsize=20)
ylabel(r'$\Delta_{i+1}^j$', fontsize=20)
tex = r'$\cal{R}\prod_{i=\alpha_{i+1}}^\infty a_i\rm{sin}(2 \pi f x_i)$'
text(1, 1.6, tex, fontsize=20)
title(r'$\Delta_i^j \hspace{0.4} \rm{versus} \hspace{0.4} \Delta_{i+1}^j$', font size=20)

Some TeX symbols:
    \vert (or |)
    \langle, \rangle
    \lceil, \rceil, \lfloor, \rfloor
    \int, \iint, \iiint, \oint, \prod, \sum
    Function names:  \arg, \coth, \inf, \max, \sinh, \arccos, \cos, \csc,
        \exp, \min, \sup, \arcsin, \cosh, \deg, \gcd, \lg, \ln, \sec, \tan,
        \arctan, \cot, \det, \lim, \log, \sin, \tanh
    \approx
    \perp
    \bullet
    \cdot, \times, \nabla, \wedge
    \backepsilon
    \bigcirc
    \circ
    \cong (congruent)
    \doteq
    \equiv, \nequiv, \sim
    \therefore
    \cap, \cup
    \div
    \in
    \leq, \geq, \nleq, \ngeq
    \ll, \gg
    \ne, \neq, \nsubset, \nsupset
    \pm, \mp  (plus, minus)
    \propto
    \oplus, \odot, \oslash
    \downarrow, \rightarrow, \leftarrow, \uparrow (single arrows)
    \Downarrow, \Rightarrow, \Leftarrow, \Uparrow (double arrows)
    \Re, \Im
    \circledR, \copyright
    \exists, \forall
    \infty
    \checkmark
    \emptyset
    \partial
    \angle
    \ell
    \mapsto

show()                  # shows on screen
savefig("out.png")      # puts in file
savefig("out.svg")      # Export svg & edit in Inkscape

Symbol styles:
        -     : solid line
        --    : dashed line
        -.    : dash-dot line
        :     : dotted line
        .     : points
        ,     : pixels
        o     : circle symbols
        ^     : triangle up symbols
        v     : triangle down symbols
        <     : triangle left symbols
        >     : triangle right symbols
        s     : square symbols
        +     : plus symbols
        x     : cross symbols
        D     : diamond symbols
        d     : thin diamond symbols
        1     : tripod down symbols
        2     : tripod up symbols
        3     : tripod left symbols
        4     : tripod right symbols
        h     : hexagon symbols
        H     : rotated hexagon symbols
        p     : pentagon symbols
        |     : vertical line symbols
        _     : horizontal line symbols
        steps : use gnuplot style 'steps' # kwarg only

Colors:
        b  : blue
        g  : green
        r  : red
        c  : cyan
        m  : magenta
        y  : yellow
        k  : black
        w  : white

Here's an example showing a variety of techniques:

    import matplotlib.pyplot as plt
    fig = plt.figure()
    fig.suptitle("bold figure suptitle", fontsize=14, fontweight="bold")
    ax = fig.add_subplot(111)
    fig.subplots_adjust(top=0.85)
    ax.set_title("axes title")
    ax.set_xlabel("xlabel")
    ax.set_ylabel("ylabel")
    ax.text(3, 8, "boxed italics text in data coords", style="italic",
        bbox={"facecolor":"red", "alpha":0.5, "pad":10})
    ax.text(2, 6, r"an equation: $E=mc^2$", fontsize=15)
    ax.text(3, 2, unicode("unicode: Institut f\374r Festk\366rperphysik",
        "latin-1"))
    ax.text(0.95, 0.01, "colored text in axes coords",
        verticalalignment="bottom", horizontalalignment="right",
        transform=ax.transAxes,
        color="green", fontsize=15)
    ax.plot([2], [1], "o")
    ax.annotate("annotate", xy=(2, 1), xytext=(3, 4),
        arrowprops=dict(facecolor="blue", shrink=0.05, width=1,
        frac=0.1))
    ax.axis([0, 10, 0, 10])
    if 1:
        plt.show()
    else:
        plt.savefig("a.png", dpi=150)
----------------------------------------------------------------------
Regression
----------

from pylab import *

# Generate some test data ; y is a linear function of x + nse

x = arange (0.0 , 2.0 , 0.05)
nse = 0.3*randn(len(x))
y = 2 + 3*x + nse

# The bestfit line from polyfit; you can do arbitrary order
# polynomials but here we take advantage of a line being a first order
# polynomial.

m,b = polyfit(x, y, 1)

# Plot the data with blue circles and the best fit with a thick
# solid black line.

plot(x, y, 'bo', x, m*x+b, '-k', linewidth=2)
ylabel('regression')
grid(True)

Polynomial Regression
---------------------

coeffs = polyfit(x, y, N)

where N is order of polynomial.

Example:


from pylab import *
# Generate some test data; y is a polynomial function of x + nse
x = arange (0.0, 2.0, 0.05)
nse = 0.6* randn(len(x))
y = 1.1 + 3.2*x + 0.1*x**2 + 2*x**3 + nse
# The bestfit line from polyfit
coeffs = polyfit (x, y, 3)
# Plot the data with blue circles and the best fit with a thick
# solid black line.
besty = polyval(coeffs, x)
plot(x, y, 'bo', x, besty , '-k', linewidth=2)
ylabel('polynomial regression')
grid(True)

----------------------------------------------------------------------

The following plotting commands are provided; some of these do not
exist in matlab(TM) but have proven themselves to be useful nonetheless.
The majority of them, however, have matlab analogs

_Plotting commands

  axes      - Create a new axes
  axhline   - draw a horizontal line across axes
  axvline   - draw a vertical line across axes
  axhspan   - draw a horizontal bar across axes
  axvspan   - draw a vertical bar across axes
  axis      - Set or return the current axis limits
  bar       - make a bar chart
  barh      - a horizontal bar chart
  box       - set the axes frame on/off state
  boxplot   - make a box and whisker plot
  cla       - clear current axes
  clabel    - label a contour plot
  clf       - clear a figure window
  clim      - adjust the color limits of the current image
  close     - close a figure window
  colorbar  - add a colorbar to the current figure
  cohere    - make a plot of coherence
  contour   - make a contour plot
  contourf  - make a filled contour plot
  csd       - make a plot of cross spectral density
  delaxes   - delete an axes from the current figure
  draw      - Force a redraw of the current figure
  errorbar  - make an errorbar graph
  figlegend - make legend on the figure rather than the axes
  figimage  - make a figure image
  figtext   - add text in figure coords
  figure   - create or change active figure
  fill     - make filled polygons
  gca      - return the current axes
  gcf      - return the current figure
  gci      - get the current image, or None
  getp      - get a handle graphics property
  grid     - set whether gridding is on
  hist     - make a histogram
  hold     - set the axes hold state
  ioff     - turn interaction mode off
  ion      - turn interaction mode on
  isinteractive - return True if interaction mode is on
  imread   - load image file into array
  imshow   - plot image data
  ishold   - return the hold state of the current axes
  legend   - make an axes legend
  loglog   - a log log plot
  matshow  - display a matrix in a new figure preserving aspect
  pcolor   - make a pseudocolor plot
  pcolormesh - make a pseudocolor plot using a quadrilateral mesh
  pie      - make a pie chart
  plot     - make a line plot
  plot_date - plot dates
  pie      - pie charts
  polar    - make a polar plot on a PolarAxes
  psd      - make a plot of power spectral density
  quiver   - make a direction field (arrows) plot
  rc       - control the default params
  rgrids   - customize the radial grids and labels for polar
  savefig  - save the current figure
  scatter  - make a scatter plot
  setp      - set a handle graphics property
  semilogx - log x axis
  semilogy - log y axis
  show     - show the figures
  specgram - a spectrogram plot
  spy      - plot sparsity pattern using markers
  spy2     - plot sparsity pattern using image
  stem     - make a stem plot
  subplot  - make a subplot (numrows, numcols, axesnum)
  subplots_adjust - change the params controlling the subplot positions of current figure
  subplot_tool - launch the subplot configuration tool
  table    - add a table to the plot
  text     - add some text at location x,y to the current axes
  thetagrids - customize the radial theta grids and labels for polar

  title    - add a title to the current axes
  xlim     - set/get the xlimits
  ylim     - set/get the ylimits
  xticks   - set/get the xticks
  yticks   - set/get the yticks
  xlabel   - add an xlabel to the current axes
  ylabel   - add a ylabel to the current axes

  autumn - set the default colormap to autumn
  bone   - set the default colormap to bone
  cool   - set the default colormap to cool
  copper - set the default colormap to copper
  flag   - set the default colormap to flag
  gray   - set the default colormap to gray
  hot    - set the default colormap to hot
  hsv    - set the default colormap to hsv
  jet    - set the default colormap to jet
  pink   - set the default colormap to pink
  prism  - set the default colormap to prism
  spring - set the default colormap to spring
  summer - set the default colormap to summer
  winter - set the default colormap to winter

_Event handling

  connect - register an event handler
  disconnect - remove a connected event handler

_Matrix commands

  cumprod   - the cumulative product along a dimension
  cumsum    - the cumulative sum along a dimension
  detrend   - remove the mean or besdt fit line from an array
  diag      - the k-th diagonal of matrix
  diff      - the n-th differnce of an array
  eig       - the eigenvalues and eigen vectors of v
  eye       - a matrix where the k-th diagonal is ones, else zero
  find      - return the indices where a condition is nonzero
  fliplr    - flip the rows of a matrix up/down
  flipud    - flip the columns of a matrix left/right
  linspace  - a linear spaced vector of N values from min to max inclusive
  meshgrid  - repeat x and y to make regular matrices
  ones      - an array of ones
  rand      - an array from the uniform distribution [0,1]
  randn     - an array from the normal distribution
  rot90     - rotate matrix k*90 degress counterclockwise
  squeeze   - squeeze an array removing any dimensions of length 1
  tri       - a triangular matrix
  tril      - a lower triangular matrix
  triu      - an upper triangular matrix
  vander    - the Vandermonde matrix of vector x
  svd       - singular value decomposition
  zeros     - a matrix of zeros

_Probability

  levypdf   - The levy probability density function from the char. func.
  normpdf   - The Gaussian probability density function
  rand      - random numbers from the uniform distribution
  randn     - random numbers from the normal distribution

_Statistics

  corrcoef  - correlation coefficient
  cov       - covariance matrix
  amax       - the maximum along dimension m
  mean      - the mean along dimension m
  median    - the median along dimension m
  amin       - the minimum along dimension m
  norm      - the norm of vector x
  prod      - the product along dimension m
  ptp       - the max-min along dimension m
  std       - the standard deviation along dimension m
  asum       - the sum along dimension m

_Time series analysis

  bartlett  - M-point Bartlett window
  blackman  - M-point Blackman window
  cohere    - the coherence using average periodiogram
  csd       - the cross spectral density using average periodiogram
  fft       - the fast Fourier transform of vector x
  hamming   - M-point Hamming window
  hanning   - M-point Hanning window
  hist      - compute the histogram of x
  kaiser    - M length Kaiser window
  psd       - the power spectral density using average periodiogram
  sinc      - the sinc function of array x

_Dates

  date2num  - convert python datetimes to numeric representation
  drange    - create an array of numbers for date plots
  num2date  - convert numeric type (float days since 0001) to datetime

_Other

  angle     - the angle of a complex array
  load     - load ASCII data into array
  polyfit   - fit x, y to an n-th order polynomial
  polyval   - evaluate an n-th order polynomial
  roots     - the roots of the polynomial coefficients in p
  save      - save an array to an ASCII file
  trapz     - trapezoidal integration

__end

Credits: The plotting commands were provided by
John D. Hunter <jdhunter@ace.bsd.uhicago.edu>

Most of the other commands are from Numeric, MLab and FFT, with the
exception of those in mlab.py provided by matplotlib.


Modules
      	  	
matplotlib._pylab_helpers
matplotlib.backends
matplotlib.cm
	matplotlib.dates
matplotlib.image
matplotlib
	matplotlib.mlab
matplotlib.numerix
sys
	matplotlib.ticker
warnings


Functions
      	  	
acorr(*args, **kwargs)
    ACORR(x, normed=False, detrend=mlab.detrend_none, usevlines=False,
          maxlags=None, **kwargs)
    Plot the autocorrelation of x.  If normed=True, normalize the
    data but the autocorrelation at 0-th lag.  x is detrended by
    the detrend callable (default no normalization.

    data are plotted as plot(lags, c, **kwargs)

    return value is lags, c, line where lags are a length
    2*maxlags+1 lag vector, c is the 2*maxlags+1 auto correlation
    vector, and line is a Line2D instance returned by plot.  The
    default linestyle is None and the default marker is 'o',
    though these can be overridden with keyword args.  The cross
    correlation is performed with numpy correlate with
    mode=2.

    If usevlines is True, Axes.vlines rather than Axes.plot is used to
    draw vertical lines from the origin to the acorr.  Otherwise the
    plotstyle is determined by the kwargs, which are Line2D
    properties.  If usevlines, the return value is lags, c, linecol, b
    where linecol is the collections.LineCollection and b is the
    x-axis

    if usevlines=True, kwargs are passed onto Axes.vlines
    if usevlines=False, kwargs are passed onto Axes.plot

    maxlags is a positive integer detailing the number of lags to show.
    The default value of None will return all (2*len(x)-1) lags.

    See the respective function for documentation on valid kwargs
    Additional kwargs: hold = [True|False] overrides default hold state

arange(...)
    arange(start, stop=None, step=1, dtype=int)

     Just like range() except it returns an array whose type can be
    specified by the keyword argument typecode.

array(...)
    array(object, dtype=None, copy=1, fortran=0, subok=0)
    will return a new array formed from the given object type given.
    Object can anything with an __array__ method, or any object
    exposing the array interface, or any (nested) sequence.
    If no type is given, then the type will be determined as the
    minimum type required to hold the objects in the sequence.
    If copy is zero and sequence is already an array with the right
    type, a reference will be returned.  If the sequence is an array,
    type can be used only to upcast the array.  For downcasting
    use .astype(t) method.  If subok is true, then subclasses of the
    array may be returned. Otherwise, a base-class ndarray is returned

arrayrange = arange(...)
    arange(start, stop=None, step=1, dtype=int)

     Just like range() except it returns an array whose type can be
    specified by the keyword argument typecode.

autumn()
    set the default colormap to autumn and apply to current image if any.  See help(colormaps) for more information

axes(*args, **kwargs)
    Add an axes at positon rect specified by::

    axes() by itself creates a default full subplot(111) window axis

    axes(rect, axisbg='w') where rect=[left, bottom, width, height] in
    normalized (0,1) units.  axisbg is the background color for the
    axis, default white

    axes(h) where h is an axes instance makes h the
    current axis An Axes instance is returned

    kwargs:

      axisbg=color   : the axes background color
      frameon=False  : don't display the frame
      sharex=otherax : the current axes shares xaxis attribute with otherax
      sharey=otherax : the current axes shares yaxis attribute with otherax
      polar=True|False : use a polar axes or not

    Examples

      examples/axes_demo.py places custom axes.
      examples/shared_axis_demo.py uses sharex and sharey

axhline(*args, **kwargs)
    AXHLINE(y=0, xmin=0, xmax=1, **kwargs)
    Axis Horizontal Line
    Draw a horizontal line at y from xmin to xmax.  With the default
    values of xmin=0 and xmax=1, this line will always span the horizontal
    extent of the axes, regardless of the xlim settings, even if you
    change them, eg with the xlim command.  That is, the horizontal extent
    is in axes coords: 0=left, 0.5=middle, 1.0=right but the y location is
    in data coordinates.
    Return value is the Line2D instance.  kwargs are the same as kwargs to
    plot, and can be used to control the line properties.  Eg
      # draw a thick red hline at y=0 that spans the xrange
      axhline(linewidth=4, color='r')
      # draw a default hline at y=1 that spans the xrange
      axhline(y=1)
      # draw a default hline at y=.5 that spans the the middle half of
      # the xrange
      axhline(y=.5, xmin=0.25, xmax=0.75)

    Addition kwargs: hold = [True|False] overrides default hold state

axhspan(*args, **kwargs)
    AXHSPAN(ymin, ymax, xmin=0, xmax=1, **kwargs)
    Axis Horizontal Span.  ycoords are in data units and x
    coords are in axes (relative 0-1) units
    Draw a horizontal span (regtangle) from ymin to ymax.  With the
    default values of xmin=0 and xmax=1, this always span the xrange,
    regardless of the xlim settings, even if you change them, eg with the
    xlim command.  That is, the horizontal extent is in axes coords:
    0=left, 0.5=middle, 1.0=right but the y location is in data
    coordinates.
    kwargs are the kwargs to Patch, eg
      antialiased, aa
      linewidth,   lw
      edgecolor,   ec
      facecolor,   fc
    the terms on the right are aliases
    Return value is the patches.Polygon instance.
        #draws a gray rectangle from y=0.25-0.75 that spans the horizontal
        #extent of the axes
        axhspan(0.25, 0.75, facecolor=0.5, alpha=0.5)

    Addition kwargs: hold = [True|False] overrides default hold state

axis(*v, **kwargs)
    Set/Get the axis properties::

        axis()  returns the current axis as a length a length 4 vector

        axis(v) where v = [xmin, xmax, ymin, ymax] sets the min and max of the x
            and y axis limits

        axis('off') turns off the axis lines and labels

        axis('equal') changes limits of x or y axis such that equal
          tick mark increments are equal in size. This makes a
          circle look like a circle, for example. This is persistent.
          For example, when axis limits are changed after this command,
          the scale remains equal

        axis('scaled') makes scale equal, changes lengths of axes while
          keeping limits of x and y axes fixed. Keeps lower left hand corner
          in original position. Fixes axis limits.

        axis('tight') changes limits x and y axis such that all data is
          shown. If all data is already shown, it will move it to the center
          of the figure without modifying (xmax-xmin) or (ymax-ymin). Note
          this is slightly different than in matlab. Fixes axis limits.

        axis('normal') sets the axis to normal, i.e. turns equal scale off

       if len(*v)==0, you can pass in xmin, xmax, ymin, ymax as kwargs
       selectively to alter just those limits w/o changing the others.
       See help(xlim) and help(ylim) for more information

       The xmin, xmax, ymin, ymax tuple is returned

axvline(*args, **kwargs)
    AXVLINE(x=0, ymin=0, ymax=1, **kwargs)
    Axis Vertical Line
    Draw a vertical line at x from ymin to ymax.  With the default values
    of ymin=0 and ymax=1, this line will always span the vertical extent
    of the axes, regardless of the xlim settings, even if you change them,
    eg with the xlim command.  That is, the vertical extent is in axes
    coords: 0=bottom, 0.5=middle, 1.0=top but the x location is in data
    coordinates.
    Return value is the Line2D instance.  kwargs are the same as
    kwargs to plot, and can be used to control the line properties.  Eg
        # draw a thick red vline at x=0 that spans the yrange
        l = axvline(linewidth=4, color='r')
        # draw a default vline at x=1 that spans the yrange
        l = axvline(x=1)
        # draw a default vline at x=.5 that spans the the middle half of
        # the yrange
        axvline(x=.5, ymin=0.25, ymax=0.75)

    Addition kwargs: hold = [True|False] overrides default hold state

axvspan(*args, **kwargs)
    AXVSPAN(xmin, xmax, ymin=0, ymax=1, **kwargs)
    axvspan : Axis Vertical Span.  xcoords are in data units and y coords
    are in axes (relative 0-1) units
    Draw a vertical span (regtangle) from xmin to xmax.  With the default
    values of ymin=0 and ymax=1, this always span the yrange, regardless
    of the ylim settings, even if you change them, eg with the ylim
    command.  That is, the vertical extent is in axes coords: 0=bottom,
    0.5=middle, 1.0=top but the y location is in data coordinates.
    kwargs are the kwargs to Patch, eg
      antialiased, aa
      linewidth,   lw
      edgecolor,   ec
      facecolor,   fc
    the terms on the right are aliases
    return value is the patches.Polygon instance.
        # draw a vertical green translucent rectangle from x=1.25 to 1.55 that
        # spans the yrange of the axes
        axvspan(1.25, 1.55, facecolor='g', alpha=0.5)

    Addition kwargs: hold = [True|False] overrides default hold state

bar(*args, **kwargs)
    BAR(left, height, width=0.8, bottom=0,
        color='b', yerr=None, xerr=None, ecolor='k', capsize=3)
    Make a bar plot with rectangles at
      left, left+width, 0, height
    left and height are Numeric arrays.
    Return value is a list of Rectangle patch instances
    BAR(left, height, width, bottom,
        color, yerr, xerr, capsize, yoff)
        xerr and yerr, if not None, will be used to generate errorbars
          on the bar chart
        color specifies the color of the bar
        ecolor specifies the color of any errorbar
        capsize determines the length in points of the error bar caps
    The optional arguments color, width and bottom can be either
    scalars or len(x) sequences
    This enables you to use bar as the basis for stacked bar
    charts, or candlestick plots

    Addition kwargs: hold = [True|False] overrides default hold state

barh(*args, **kwargs)
    BARH(x, y, height=0.8, left=0,
         color='b', yerr=None, xerr=None, ecolor='k', capsize=3)
        BARH(x, y)
        The y values give the heights of the center of the bars.  The
        x values give the length of the bars.
        Return value is a list of Rectangle patch instances
    Optional arguments
        height - the height (thickness)  of the bar
        left  - the x coordinate of the left side of the bar
        color specifies the color of the bar
        xerr and yerr, if not None, will be used to generate errorbars
        on the bar chart
        ecolor specifies the color of any errorbar
        capsize determines the length in points of the error bar caps
    The optional arguments color, height and left can be either
    scalars or len(x) sequences

    Addition kwargs: hold = [True|False] overrides default hold state

bone()
    set the default colormap to bone and apply to current image if any.  See help(colormaps) for more information

box(on=None)
    Turn the axes box on or off according to 'on'

    If on is None, toggle state

boxplot(*args, **kwargs)
    boxplot(x, notch=0, sym='+', vert=1, whis=1.5,
            positions=None, widths=None)
    Make a box and whisker plot for each column of x.
    The box extends from the lower to upper quartile values
    of the data, with a line at the median.  The whiskers
    extend from the box to show the range of the data.  Flier
    points are those past the end of the whiskers.
    notch = 0 (default) produces a rectangular box plot.
    notch = 1 will produce a notched box plot
    sym (default 'b+') is the default symbol for flier points.
    Enter an empty string ('') if you don't want to show fliers.
    vert = 1 (default) makes the boxes vertical.
    vert = 0 makes horizontal boxes.  This seems goofy, but
    that's how Matlab did it.
    whis (default 1.5) defines the length of the whiskers as
    a function of the inner quartile range.  They extend to the
    most extreme data point within ( whis*(75%-25%) ) data range.
    positions (default 1,2,...,n) sets the horizontal positions of
    the boxes. The ticks and limits are automatically set to match
    the positions.
    widths is either a scalar or a vector and sets the width of
    each box. The default is 0.5, or 0.15*(distance between extreme
    positions) if that is smaller.
    x is a Numeric array
    Returns a list of the lines added

    Addition kwargs: hold = [True|False] overrides default hold state

can_cast(...)
    can_cast_safely(from=d1, to=d2) returns True if data type d1 can be cast to data type d2 without losing precision.

cla(*args, **kwargs)
    Clear the current axes

clabel(*args, **kwargs)
    clabel(CS, **kwargs) - add labels to line contours in CS,
           where CS is a ContourSet object returned by contour.
    clabel(CS, V, **kwargs) - only label contours listed in V
    keyword arguments:
    * fontsize = None: as described in http://matplotlib.sf.net/fonts.html
    * colors = None:
       - a tuple of matplotlib color args (string, float, rgb, etc),
         different labels will be plotted in different colors in the order
         specified
       - one string color, e.g. colors = 'r' or colors = 'red', all labels
         will be plotted in this color
       - if colors == None, the color of each label matches the color
         of the corresponding contour
    * inline = True: controls whether the underlying contour is removed
                 (inline = True) or not (False)
    * fmt = '%1.3f': a format string for the label

    Addition kwargs: hold = [True|False] overrides default hold state

clf()
    Clear the current figure

clim(vmin=None, vmax=None)
    Set the color limits of the current image

    To apply clim to all axes images do

    clim(0, 0.5)

    If either vmin or vmax is None, the image min/max respectively
    will be used for color scaling.

    If you want to set the clim of multiple images,
    use, for example for im in gca().get_images(): im.set_clim(0,
    0.05)

close(*args)
    Close a figure window

    close() by itself closes the current figure

    close(num) closes figure number num

    close(h) where h is a figure handle(instance) closes that figure

    close('all') closes all the figure windows

cohere(*args, **kwargs)
    COHERE(x, y, NFFT=256, Fs=2, detrend=detrend_none,
          window=window_hanning, noverlap=0, **kwargs)
    cohere the coherence between x and y.  Coherence is the normalized
    cross spectral density
      Cxy = |Pxy|^2/(Pxx*Pyy)
    The return value is (Cxy, f), where f are the frequencies of the
    coherence vector.
    See the PSD help for a description of the optional parameters.
    kwargs are applied to the lines
    Returns the tuple Cxy, freqs
    Refs: Bendat & Piersol -- Random Data: Analysis and Measurement
      Procedures, John Wiley & Sons (1986)

    Addition kwargs: hold = [True|False] overrides default hold state

colorbar(mappable=None, cax=None, orientation='vertical', tickfmt='%1.1f', cspacing='proportional', clabels=None, drawedges=False, edgewidth=0.5, edgecolor='k')
    Create a colorbar for mappable; if mappable is None,
    use current image.

    tickfmt is a format string to format the colorbar ticks

    cax is a colorbar axes instance in which the colorbar will be
    placed.  If None, as default axesd will be created resizing the
    current aqxes to make room for it.  If not None, the supplied axes
    will be used and the other axes positions will be unchanged.

    orientation is the colorbar orientation: one of 'vertical' | 'horizontal'

    cspacing controls how colors are distributed on the colorbar.
    if cspacing == 'linear', each color occupies an equal area
    on the colorbar, regardless of the contour spacing.
    if cspacing == 'proportional' (Default), the area each color
    occupies on the the colorbar is proportional to the contour interval.
    Only relevant for a Contour image.

    clabels can be a sequence containing the
    contour levels to be labelled on the colorbar, or None (Default).
    If clabels is None, labels for all contour intervals are
    displayed. Only relevant for a Contour image.

    if drawedges == True, lines are drawn at the edges between
    each color on the colorbar. Default False.

    edgecolor is the line color delimiting the edges of the colors
    on the colorbar (if drawedges == True). Default black ('k')

    edgewidth is the width of the lines delimiting the edges of
    the colors on the colorbar (if drawedges == True). Default 0.5

    return value is the colorbar axes instance

colormaps()
    matplotlib provides the following colormaps.

      autumn bone cool copper flag gray hot hsv jet pink prism
      spring summer winter

    You can set the colormap for an image, pcolor, scatter, etc,
    either as a keyword argumentdef con

    >>> imshow(X, cmap=cm.hot)

    or post-hoc using the corresponding pylab interface function

    >>> imshow(X)
    >>> hot()
    >>> jet()

    In interactive mode, this will update the colormap allowing you to
    see which one works best for your data.

colors()
    This is a do nothing function to provide you with help on how
    matplotlib handles colors.

    Commands which take color arguments can use several formats to
    specify the colors.  For the basic builtin colors, you can use a
    single letter

      b  : blue
      g  : green
      r  : red
      c  : cyan
      m  : magenta
      y  : yellow
      k  : black
      w  : white


    For a greater range of colors, you have two options.  You can
    specify the color using an html hex string, as in

      color = '#eeefff'

    or you can pass an R,G,B tuple, where each of R,G,B are in the
    range [0,1].

    You can also use any legal html name for a color, like 'red',
    'burlywood' and 'chartreuse'

    The example below creates a subplot with a dark
    slate gray background

       subplot(111, axisbg=(0.1843, 0.3098, 0.3098))

    Here is an example that creates a pale turqoise title

      title('Is this the best color?', color='#afeeee')

concatenate(...)
    concatenate((a1,a2,...),axis=None).

connect(s, func)
    Connect event with string s to func.  The signature of func is
      def func(event)
    where event is a MplEvent.  The following events are recognized
     'resize_event'
     'draw_event'
     'key_press_event'
     'key_release_event'
     'button_press_event'
     'button_release_event'
     'motion_notify_event'
     For the three events above, if the mouse is over the axes,
     the variable event.inaxes will be set to the axes it is over,
     and additionally, the variables event.xdata and event.ydata
     will be defined.  This is the mouse location in data coords.
     See backend_bases.MplEvent.
    return value is a connection id that can be used with
    mpl_disconnect

contour(*args, **kwargs)
    contour and contourf draw contour lines and filled contours,
    respectively.  Except as noted, function signatures and return
    values are the same for both versions.
    contourf differs from the Matlab (TM) version in that it does not
        draw the polygon edges, because the contouring engine yields
        simply connected regions with branch cuts.  To draw the edges,
        add line contours with calls to contour.
    Function signatures
    contour(Z) - make a contour plot of an array Z. The level
             values are chosen automatically.
    contour(X,Y,Z) - X,Y specify the (x,y) coordinates of the surface
    contour(Z,N) and contour(X,Y,Z,N) - contour N automatically-chosen
             levels.
    contour(Z,V) and contour(X,Y,Z,V) - draw len(V) contour lines,
             at the values specified in sequence V
    contourf(..., V) - fill the (len(V)-1) regions between the
             values in V
    contour(Z, **kwargs) - Use keyword args to control colors, linewidth,
                origin, cmap ... see below
    X, Y, and Z must be arrays with the same dimensions.
    Z may be a masked array, but filled contouring may not handle
               internal masked regions correctly.
    C = contour(...) returns a ContourSet object.
    Optional keyword args are shown with their defaults below (you must
    use kwargs for these):
        * colors = None; or one of the following:
          - a tuple of matplotlib color args (string, float, rgb, etc),
          different levels will be plotted in different colors in the order
          specified
          -  one string color, e.g. colors = 'r' or colors = 'red', all levels
          will be plotted in this color
          - if colors == None, the colormap specified by cmap will be used
        * alpha=1.0 : the alpha blending value
        * cmap = None: a cm Colormap instance from matplotlib.cm.
          - if cmap == None and colors == None, a default Colormap is used.
        * norm = None: a matplotlib.colors.normalize instance for
          scaling data values to colors.
          - if norm == None, and colors == None, the default
            linear scaling is used.
        * origin = None: 'upper'|'lower'|'image'|None.
          If 'image', the rc value for image.origin will be used.
          If None (default), the first value of Z will correspond
          to the lower left corner, location (0,0).
          This keyword is active only if contourf is called with
          one or two arguments, that is, without explicitly
          specifying X and Y.
        * extent = None: (x0,x1,y0,y1); also active only if X and Y
          are not specified.  If origin is not None, then extent is
          interpreted as in imshow: it gives the outer pixel boundaries.
          In this case, the position of Z[0,0] is the center of the
          pixel, not a corner.
          If origin is None, then (x0,y0) is the position of Z[0,0],
          and (x1,y1) is the position of Z[-1,-1].
        * locator = None: an instance of a ticker.Locator subclass;
          default is MaxNLocator.  It is used to determine the
          contour levels if they are not given explicitly via the
          V argument.
        contour only:
        * linewidths = None: or one of these:
          - a number - all levels will be plotted with this linewidth,
            e.g. linewidths = 0.6
          - a tuple of numbers, e.g. linewidths = (0.4, 0.8, 1.2) different
            levels will be plotted with different linewidths in the order
            specified
          - if linewidths == None, the default width in lines.linewidth in
            .matplotlibrc is used
        contourf only:
        * clip_ends = True
          If False, the limits for color scaling are set to the
          minimum and maximum contour levels.
          True (default) clips the scaling limits.  Example:
          if the contour boundaries are V = [-100, 2, 1, 0, 1, 2, 100],
          then the scaling limits will be [-100, 100] if clip_ends
          is False, and [-3, 3] if clip_ends is True.
        * linewidths = None or a number; default of 0.05 works for
          Postscript; a value of about 0.5 seems better for Agg.
        * antialiased = True (default) or False; if False, there is
          no need to increase the linewidths for Agg, but True gives
          nicer color boundaries.  If antialiased is True and linewidths
          is too small, then there may be light-colored lines at the
          color boundaries caused by the antialiasing.
        * nchunk = 0 (default) for no subdivision of the domain;
          specify a positive integer to divide the domain into
          subdomains of roughly nchunk by nchunk points. This may
          never actually be advantageous, so this option may be
          removed.  Chunking introduces artifacts at the chunk
          boundaries unless antialiased = False, or linewidths is
          set to a large enough value for the particular renderer and
          resolution.

    Addition kwargs: hold = [True|False] overrides default hold state

contourf(*args, **kwargs)
    contour and contourf draw contour lines and filled contours,
    respectively.  Except as noted, function signatures and return
    values are the same for both versions.
    contourf differs from the Matlab (TM) version in that it does not
        draw the polygon edges, because the contouring engine yields
        simply connected regions with branch cuts.  To draw the edges,
        add line contours with calls to contour.
    Function signatures
    contour(Z) - make a contour plot of an array Z. The level
             values are chosen automatically.
    contour(X,Y,Z) - X,Y specify the (x,y) coordinates of the surface
    contour(Z,N) and contour(X,Y,Z,N) - contour N automatically-chosen
             levels.
    contour(Z,V) and contour(X,Y,Z,V) - draw len(V) contour lines,
             at the values specified in sequence V
    contourf(..., V) - fill the (len(V)-1) regions between the
             values in V
    contour(Z, **kwargs) - Use keyword args to control colors, linewidth,
                origin, cmap ... see below
    X, Y, and Z must be arrays with the same dimensions.
    Z may be a masked array, but filled contouring may not handle
               internal masked regions correctly.
    C = contour(...) returns a ContourSet object.
    Optional keyword args are shown with their defaults below (you must
    use kwargs for these):
        * colors = None; or one of the following:
          - a tuple of matplotlib color args (string, float, rgb, etc),
          different levels will be plotted in different colors in the order
          specified
          -  one string color, e.g. colors = 'r' or colors = 'red', all levels
          will be plotted in this color
          - if colors == None, the colormap specified by cmap will be used
        * alpha=1.0 : the alpha blending value
        * cmap = None: a cm Colormap instance from matplotlib.cm.
          - if cmap == None and colors == None, a default Colormap is used.
        * norm = None: a matplotlib.colors.normalize instance for
          scaling data values to colors.
          - if norm == None, and colors == None, the default
            linear scaling is used.
        * origin = None: 'upper'|'lower'|'image'|None.
          If 'image', the rc value for image.origin will be used.
          If None (default), the first value of Z will correspond
          to the lower left corner, location (0,0).
          This keyword is active only if contourf is called with
          one or two arguments, that is, without explicitly
          specifying X and Y.
        * extent = None: (x0,x1,y0,y1); also active only if X and Y
          are not specified.  If origin is not None, then extent is
          interpreted as in imshow: it gives the outer pixel boundaries.
          In this case, the position of Z[0,0] is the center of the
          pixel, not a corner.
          If origin is None, then (x0,y0) is the position of Z[0,0],
          and (x1,y1) is the position of Z[-1,-1].
        * locator = None: an instance of a ticker.Locator subclass;
          default is MaxNLocator.  It is used to determine the
          contour levels if they are not given explicitly via the
          V argument.
        contour only:
        * linewidths = None: or one of these:
          - a number - all levels will be plotted with this linewidth,
            e.g. linewidths = 0.6
          - a tuple of numbers, e.g. linewidths = (0.4, 0.8, 1.2) different
            levels will be plotted with different linewidths in the order
            specified
          - if linewidths == None, the default width in lines.linewidth in
            .matplotlibrc is used
        contourf only:
        * clip_ends = True
          If False, the limits for color scaling are set to the
          minimum and maximum contour levels.
          True (default) clips the scaling limits.  Example:
          if the contour boundaries are V = [-100, 2, 1, 0, 1, 2, 100],
          then the scaling limits will be [-100, 100] if clip_ends
          is False, and [-3, 3] if clip_ends is True.
        * linewidths = None or a number; default of 0.05 works for
          Postscript; a value of about 0.5 seems better for Agg.
        * antialiased = True (default) or False; if False, there is
          no need to increase the linewidths for Agg, but True gives
          nicer color boundaries.  If antialiased is True and linewidths
          is too small, then there may be light-colored lines at the
          color boundaries caused by the antialiasing.
        * nchunk = 0 (default) for no subdivision of the domain;
          specify a positive integer to divide the domain into
          subdomains of roughly nchunk by nchunk points. This may
          never actually be advantageous, so this option may be
          removed.  Chunking introduces artifacts at the chunk
          boundaries unless antialiased = False, or linewidths is
          set to a large enough value for the particular renderer and
          resolution.

    Addition kwargs: hold = [True|False] overrides default hold state

cool()
    set the default colormap to cool and apply to current image if any.  See help(colormaps) for more information

copper()
    set the default colormap to copper and apply to current image if any.  See help(colormaps) for more information

csd(*args, **kwargs)
    CSD(x, y, NFFT=256, Fs=2, detrend=detrend_none,
        window=window_hanning, noverlap=0, **kwargs)
    The cross spectral density Pxy by Welches average periodogram method.
    The vectors x and y are divided into NFFT length segments.  Each
    segment is detrended by function detrend and windowed by function
    window.  The product of the direct FFTs of x and y are averaged over
    each segment to compute Pxy, with a scaling to correct for power loss
    due to windowing.
    See the PSD help for a description of the optional parameters.
    Returns the tuple Pxy, freqs.  Pxy is the cross spectrum (complex
    valued), and 10*log10(|Pxy|) is plotted
    Refs:
      Bendat & Piersol -- Random Data: Analysis and Measurement
        Procedures, John Wiley & Sons (1986)

    Addition kwargs: hold = [True|False] overrides default hold state

delaxes(*args)
    delaxes(ax) - remove ax from the current figure.  If ax doesn't
    exist an error will be raised.

    delaxes(): delete the current axes

disconnect(cid)
    Connect s to func. return an id that can be used with disconnect
    Method should return None

dot(...)
    dot(a,v) returns matrix-multiplication between a and b.
    The product-sum is over the last dimension of a and the
    second-to-last dimension of b.

draw()
    redraw the current figure

dump(...)
    dump(obj, file, protocol=0) -- Write an object in pickle format to the given file.

    See the Pickler docstring for the meaning of optional argument proto.

dumps(...)
    dumps(obj, protocol=0) -- Return a string containing an object in pickle format.

    See the Pickler docstring for the meaning of optional argument proto.

empty(...)
    empty((d1,...,dn),dtype=int,fortran=0) will return a new array
    of shape (d1,...,dn) and given type with all its entries uninitialized. This can be faster than zeros.

errorbar(*args, **kwargs)
    ERRORBAR(x, y, yerr=None, xerr=None,
             fmt='b-', ecolor=None, capsize=3, barsabove=False)
    Plot x versus y with error deltas in yerr and xerr.
    Vertical errorbars are plotted if yerr is not None
    Horizontal errorbars are plotted if xerr is not None
    xerr and yerr may be any of:
        a rank-0, Nx1 Numpy array  - symmetric errorbars +/- value
        an N-element list or tuple - symmetric errorbars +/- value
        a rank-1, Nx2 Numpy array  - asymmetric errorbars -column1/+column2
    Alternatively, x, y, xerr, and yerr can all be scalars, which
    plots a single error bar at x, y.
        fmt is the plot format symbol for y.  if fmt is None, just
        plot the errorbars with no line symbols.  This can be useful
        for creating a bar plot with errorbars
        ecolor is a matplotlib color arg which gives the color the
        errorbar lines; if None, use the marker color.
        capsize is the size of the error bar caps in points
        barsabove, if True, will plot the errorbars above the plot symbols
        - default is below
        kwargs are passed on to the plot command for the markers.
          So you can add additional key=value pairs to control the
          errorbar markers.  For example, this code makes big red
          squares with thick green edges
          >>> x,y,yerr = rand(3,10)
          >>> errorbar(x, y, yerr, marker='s',
                       mfc='red', mec='green', ms=20, mew=4)
         mfc, mec, ms and mew are aliases for the longer property
         names, markerfacecolor, markeredgecolor, markersize and
         markeredgewith.
    Return value is a length 2 tuple.  The first element is the
    Line2D instance for the y symbol lines.  The second element is
    a list of error bar lines.

    Addition kwargs: hold = [True|False] overrides default hold state

fastCopyAndTranspose = _fastCopyAndTranspose(...)
    _fastCopyAndTranspose(a)

figimage(*args, **kwargs)
    FIGIMAGE(X) # add non-resampled array to figure
    FIGIMAGE(X, xo, yo) # with pixel offsets
    FIGIMAGE(X, **kwargs) # control interpolation ,scaling, etc
    Add a nonresampled figure to the figure from array X.  xo and yo are
    offsets in pixels
    X must be a float array
        If X is MxN, assume luminance (grayscale)
        If X is MxNx3, assume RGB
        If X is MxNx4, assume RGBA
    The following kwargs are allowed:
      * cmap is a cm colormap instance, eg cm.jet.  If None, default to
        the rc image.cmap valuex
      * norm is a matplotlib.colors.normalize instance; default is
        normalization().  This scales luminance -> 0-1
      * vmin and vmax are used to scale a luminance image to 0-1.  If
        either is None, the min and max of the luminance values will be
        used.  Note if you pass a norm instance, the settings for vmin and
        vmax will be ignored.
      * alpha = 1.0 : the alpha blending value
      * origin is either 'upper' or 'lower', which indicates where the [0,0]
        index of the array is in the upper left or lower left corner of
        the axes.  Defaults to the rc image.origin value
    This complements the axes image (Axes.imshow) which will be resampled
    to fit the current axes.  If you want a resampled image to fill the
    entire figure, you can define an Axes with size [0,1,0,1].
    A image.FigureImage instance is returned.

    Addition kwargs: hold = [True|False] overrides default hold state

figlegend(handles, labels, loc, **kwargs)
    Place a legend in the figure.  Labels are a sequence of
    strings, handles is a sequence of line or patch instances, and
    loc can be a string r an integer specifying the legend
    location

    USAGE:
      legend( (line1, line2, line3),
              ('label1', 'label2', 'label3'),
              'upper right')

    See help(legend) for information about the location codes

    A matplotlib.legend.Legend instance is returned

figtext(*args, **kwargs)
    Add text to figure at location x,y (relative 0-1 coords) See
    the help for Axis text for the meaning of the other arguments

figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)
    figure(num = None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')


    Create a new figure and return a handle to it.  If num=None, the figure
    number will be incremented and a new figure will be created.  The returned
    figure objects have a .number attribute holding this number.

    If num is an integer, and figure(num) already exists, make it
    active and return the handle to it.  If figure(num) does not exist
    it will be created.  Numbering starts at 1, matlab style

      figure(1)


    kwargs:

      figsize - width x height in inches; defaults to rc figure.figsize
      dpi     - resolution; defaults to rc figure.dpi
      facecolor - the background color; defaults to rc figure.facecolor
      edgecolor - the border color; defaults to rc figure.edgecolor

    rcParams gives the default values from the .matplotlibrc file

fill(*args, **kwargs)
    FILL(*args, **kwargs)
    plot filled polygons.  *args is a variable length argument, allowing
    for multiple x,y pairs with an optional color format string; see plot
    for details on the argument parsing.  For example, all of the
    following are legal, assuming a is the Axis instance:
      ax.fill(x,y)            # plot polygon with vertices at x,y
      ax.fill(x,y, 'b' )      # plot polygon with vertices at x,y in blue
    An arbitrary number of x, y, color groups can be specified, as in
      ax.fill(x1, y1, 'g', x2, y2, 'r')
    Return value is a list of patches that were added
    The same color strings that plot supports are supported by the fill
    format string.
    The kwargs that are can be used to set line properties (any
    property that has a set_* method).  You can use this to set edge
    color, face color, etc.

    Addition kwargs: hold = [True|False] overrides default hold state

flag()
    set the default colormap to flag and apply to current image if any.  See help(colormaps) for more information

frombuffer(...)
    frombuffer(buffer=, dtype=int, count=-1, offset=0)

    Returns a 1-d array of data type dtype from buffer. The buffer
     argument must be an object that exposes the buffer interface.
     If count is -1 then the entire buffer is used, otherwise, count
     is the size of the output.  If offset is given then jump that
     far into the buffer. If the buffer has data that is out
     not in machine byte-order, than use a propert data type
     descriptor. The data will not
     be byteswapped, but the array will manage it in future
     operations.

fromfile(...)
    fromfile(file=, dtype=int, count=-1, sep='')

    Return an array of the given data type from a
    (text or binary) file.   The file argument can be an open file
    or a string with the name of a file to read from.  If
    count==-1, then the entire file is read, otherwise count is
    the number of items of the given type read in.  If sep is ''
    then read a binary file, otherwise it gives the separator
    between elements in a text file.

    WARNING: This function should be used sparingly, as it is not
    a platform-independent method of persistence.  But it can be
    useful to read in simply-formatted or binary data quickly.

frompyfunc(...)
    frompyfunc(func, nin, nout) take an arbitrary python function that takes nin objects as input and returns nout objects and return a universal function (ufunc).  This ufunc always returns PyObject arrays

fromstring(...)
    fromstring(string, dtype=int, count=-1) returns a new 1d array initialized from the raw binary data in string.  If count is positive, the new array will have count elements, otherwise it's size is determined by the size of string.

gca(**kwargs)
    Return the current axis instance.  This can be used to control
    axis properties either using set or the Axes methods.

    Example:

      plot(t,s)
      set(gca(), 'xlim', [0,10])  # set the x axis limits

    or

      plot(t,s)
      a = gca()
      a.set_xlim([0,10])          # does the same

gcf()
    Return a handle to the current figure

gci()
    get the current ScalarMappable instance (image or patch
    collection), or None if no images or patch collecitons have been
    defined.  The commands imshow and figimage create images
    instances, and the commands pcolor and scatter create patch
    collection instances

get_current_fig_manager()

get_plot_commands()

getbuffer(...)
    getbuffer(obj [,offset[, size]]) create a buffer object from the given object
     referencing a slice of length size starting at offset.  Default
    is the entire buffer. A read-write buffer is attempted followed by a read-only buffer.

gray()
    set the default colormap to gray and apply to current image if any.  See help(colormaps) for more information

grid(*args, **kwargs)
    Set the axes grids on or off; b is a boolean
    if b is None, toggle the grid state

hist(*args, **kwargs)
    HIST(x, bins=10, normed=0, bottom=0, orientiation='vertical', **kwargs)
    Compute the histogram of x.  bins is either an integer number of
    bins or a sequence giving the bins.  x are the data to be binned.
    The return values is (n, bins, patches)
    If normed is true, the first element of the return tuple will
    be the counts normalized to form a probability density, ie,
    n/(len(x)*dbin)
    orientation = 'horizontal' | 'vertical'.  If horizontal, barh
    will be used and the "bottom" kwarg will be the left.
    width: the width of the bars.  If None, automatically compute
    the width.
    kwargs are used to update the properties of the
    hist bars

    Addition kwargs: hold = [True|False] overrides default hold state

hlines(*args, **kwargs)
    HLINES(y, xmin, xmax, fmt='k-')
    plot horizontal lines at each y from xmin to xmax.  xmin or xmax can
    be scalars or len(x) numpy arrays.  If they are scalars, then the
    respective values are constant, else the widths of the lines are
    determined by xmin and xmax
    fmt is a plot format string, eg 'g--'
    kwargs are matplotlib.lines.Line2D kwargs
    Returns a list of line instances that were added

    Addition kwargs: hold = [True|False] overrides default hold state

hold(b=None)
    Set the hold state.  If hold is None (default), toggle the
    hold state.  Else set the hold state to boolean value b.

    Eg
    hold()      # toggle hold
    hold(True)  # hold is on
    hold(False) # hold is off

    When hold is True, subsequent plot commands will be added to the
    current axes.  When hold is False, the current axes and figure
    will be cleared on the next plot command

hot()
    set the default colormap to hot and apply to current image if any.  See help(colormaps) for more information

hsv()
    set the default colormap to hsv and apply to current image if any.  See help(colormaps) for more information

imread(*args, **kwargs)
    return image file in fname as numerix array
    Return value is a MxNx4 array of 0-1 normalized floats

imshow(*args, **kwargs)
    IMSHOW(X, cmap=None, norm=None, aspect=None, interpolation=None,
           alpha=1.0, vmin=None, vmax=None, origin=None, extent=None)
    IMSHOW(X) - plot image X to current axes, resampling to scale to axes
                size (X may be numarray/Numeric array or PIL image)
    IMSHOW(X, **kwargs) - Use keyword args to control image scaling,
    colormapping etc. See below for details
    Display the image in X to current axes.  X may be a float array, a
    UInt8 array or a PIL image. If X is an array, X can have the following
    shapes:
        MxN    : luminance (grayscale, float array only)
        MxNx3  : RGB (float or UInt8 array)
        MxNx4  : RGBA (float or UInt8 array)
    The value for each component of MxNx3 and MxNx4 float arrays should be
    in the range 0.0 to 1.0; MxN float arrays may be normalised.
    A matplotlib.image.AxesImage instance is returned
    The following kwargs are allowed:
      * cmap is a cm colormap instance, eg cm.jet.  If None, default to rc
        image.cmap value (Ignored when X has RGB(A) information)
      * aspect is one of: free or preserve.  if None, default to rc
        image.aspect value
      * interpolation is one of:
        'nearest', 'bilinear', 'bicubic', 'spline16', 'spline36',
    'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',
    'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc',
    'lanczos', 'blackman'
        if interpolation is None, default to rc
        image.interpolation.  See also th the filternorm and
        filterrad parameters
      * norm is a matplotlib.colors.normalize instance; default is
        normalization().  This scales luminance -> 0-1 (only used for an
        MxN float array).
      * vmin and vmax are used to scale a luminance image to 0-1.  If
        either is None, the min and max of the luminance values will be
        used.  Note if you pass a norm instance, the settings for vmin and
        vmax will be ignored.
      * alpha = 1.0 : the alpha blending value
      * origin is either upper or lower, which indicates where the [0,0]
        index of the array is in the upper left or lower left corner of
        the axes.  If None, default to rc image.origin
      * extent is a data xmin, xmax, ymin, ymax for making image plots
        registered with data plots.  Default is the image dimensions
        in pixels
      * shape is for raw buffer images
      * filternorm is a parameter for the antigrain image resize
        filter.  From the antigrain documentation, if normalize=1,
        the filter normalizes integer values and corrects the
        rounding errors. It doesn't do anything with the source
        floating point values, it corrects only integers according
        to the rule of 1.0 which means that any sum of pixel
        weights must be equal to 1.0.  So, the filter function
        must produce a graph of the proper shape.
     * filterrad: the filter radius for filters that have a radius
       parameter, ie when interpolation is one of: 'sinc',
       'lanczos' or 'blackman'

    Addition kwargs: hold = [True|False] overrides default hold state

inner(...)
    inner(a,b) returns the dot product of two arrays, which has
    shape a.shape[:-1] + b.shape[:-1] with elements computed by
    the product of the elements from the last dimensions of a and b.

innerproduct = inner(...)
    inner(a,b) returns the dot product of two arrays, which has
    shape a.shape[:-1] + b.shape[:-1] with elements computed by
    the product of the elements from the last dimensions of a and b.

ioff()
    turn interactive mode off

ion()
    turn interactive mode on

ishold()
    Return the hold status of the current axes

isinteractive()
    Return the interactive status

jet()
    set the default colormap to jet and apply to current image if any.  See help(colormaps) for more information

legend(*args, **kwargs)
    LEGEND(*args, **kwargs)
    Place a legend on the current axes at location loc.  Labels are a
    sequence of strings and loc can be a string or an integer specifying
    the legend location
    USAGE:
      Make a legend with existing lines
      >>> legend()
      legend by itself will try and build a legend using the label
      property of the lines/patches/collections.  You can set the label of
      a line by doing plot(x, y, label='my data') or line.set_label('my
      data'). If label is set to '_nolegend_', the item will not be shown
      in legend.
        # automatically generate the legend from labels
        legend( ('label1', 'label2', 'label3') )
        # Make a legend for a list of lines and labels
        legend( (line1, line2, line3), ('label1', 'label2', 'label3') )
        # Make a legend at a given location, using a location argument
        # legend( LABELS, LOC )  or
        # legend( LINES, LABELS, LOC )
        legend( ('label1', 'label2', 'label3'), loc='upper left')
        legend( (line1, line2, line3),  ('label1', 'label2', 'label3'), loc=2)
    The location codes are
      'best' : 0,
      'upper right'  : 1, (default)
      'upper left'   : 2,
      'lower left'   : 3,
      'lower right'  : 4,
      'right'        : 5,
      'center left'  : 6,
      'center right' : 7,
      'lower center' : 8,
      'upper center' : 9,
      'center'       : 10,
    If none of these are suitable, loc can be a 2-tuple giving x,y
    in axes coords, ie,
      loc = 0, 1 is left top
      loc = 0.5, 0.5 is center, center
    and so on.  The following kwargs are supported
      numpoints = 4         # the number of points in the legend line
      prop = FontProperties('smaller')  # the font properties
      pad = 0.2             # the fractional whitespace inside the legend border
      # The kwarg dimensions are in axes coords
      labelsep = 0.005     # the vertical space between the legend entries
      handlelen = 0.05     # the length of the legend lines
      handletextsep = 0.02 # the space between the legend line and legend text
      axespad = 0.02       # the border between the axes and legend edge
      shadow = False       # if True, draw a shadow behind legend

lexsort(...)
    lexsort(keys=, axis=-1) returns an array of indexes similar to argsort except the sorting is done using the provided sorting keys.  First the sort is done using key[0], then the resulting list of indexes is further manipulated by sorting on key[0].  And so forth The result is a sort on multiple keys.  If the keys represented columns of a spread-sheet, for example, this would sort using multiple columns. The keys argument must be a tuple of things that can be converted to  arrays of the same shape.

load(fname, comments='%', delimiter=None, converters=None, skiprows=0)
    Load ASCII data from fname into an array and return the array.

    The data must be regular, same number of values in every row

    fname can be a filename or a file handle.  Support for gzipped files is
    automatic, if the filename ends in .gz

    matfile data is not currently supported, but see
    Nigel Wade's matfile ftp://ion.le.ac.uk/matfile/matfile.tar.gz

    Example usage:

    X = load('test.dat')  # data in two columns
    t = X[:,0]
    y = X[:,1]

    Alternatively, you can do

    t,y = transpose(load('test.dat')) # for  two column data


    X = load('test.dat')    # a matrix of data

    x = load('test.dat')    # a single column of data

    comments is the character used to indicate the start of a comment
    in the file

    delimiter is a string-like character used to seperate values in the
    file. If delimiter is unspecified or none, any whitespace string is
    a separator.

    converters, if not None, is a dictionary mapping column number to
    a function that will convert that column to a float.  Eg, if
    column 0 is a date string: converters={0:datestr2num}

    skiprows is the number of rows from the top to skip

loads(...)
    loads(string) -- Load a pickle from the given string

loglog(*args, **kwargs)
    LOGLOG(*args, **kwargs)
    Make a loglog plot with log scaling on the a and y axis.  The args
    to semilog x are the same as the args to plot.  See help plot for
    more info.
    Optional keyword args supported are any of the kwargs
    supported by plot or set_xscale or set_yscale.  Notable, for
    log scaling:
      * basex: base of the x logarithm
      * subsx: the location of the minor ticks; None defaults to autosubs,
        which depend on the number of decades in the plot
      * basey: base of the y logarithm
      * subsy: the location of the minor yticks; None defaults to autosubs,
        which depend on the number of decades in the plot

    Addition kwargs: hold = [True|False] overrides default hold state

matrixmultiply = dot(...)
    dot(a,v) returns matrix-multiplication between a and b.
    The product-sum is over the last dimension of a and the
    second-to-last dimension of b.

matshow(*args, **kw)
    Display an array as a matrix in a new figure window.

    The origin is set at the upper left hand corner and rows (first dimension
    of the array) are displayed horizontally.  The aspect ratio of the figure
    window is that of the array, as long as it is possible to fit it within
    your screen with no stretching.  If the window dimensions can't accomodate
    this (extremely tall/wide arrays), some stretching will inevitably occur.

    Tick labels for the xaxis are placed on top by default.

    matshow() calls imshow() with args and **kwargs, but by default it sets
    interpolation='nearest' (unless you override it).  All other arguments and
    keywords are passed to imshow(), so see its docstring for further details.

    Special keyword arguments which are NOT passed to imshow():

      - fignum(None): by default, matshow() creates a new figure window with
      automatic numbering.  If fignum is given as an integer, the created
      figure will use this figure number.  Because of how matshow() tries to
      set the figure aspect ratio to be the one of the array, if you provide
      the number of an already existing figure, strange things may happen.

      - returnall(False): by default, the return value is a figure instance.
      With 'returnall=True', a (figure, axes, image) tuple is returned.


    Example usage:

    def samplemat(dims):
        aa = zeros(dims)
        for i in range(min(dims)):
            aa[i,i] = i
        return aa

    dimlist = [(12,12),(128,64),(64,512),(2048,256)]

    for d in dimlist:
        fig, ax, im = matshow(samplemat(d))
    show()

max(...)
    max(sequence) -> value
    max(a, b, c, ...) -> value

    With a single sequence argument, return its largest item.
    With two or more arguments, return the largest argument.

min(...)
    min(sequence) -> value
    min(a, b, c, ...) -> value

    With a single sequence argument, return its smallest item.
    With two or more arguments, return the smallest argument.

newbuffer(...)
    newbuffer(size) return a new uninitialized buffer object of size bytes

over(func, *args, **kwargs)
    Call func(*args, **kwargs) with hold(True) and then restore the hold state

pcolor(*args, **kwargs)
    PCOLOR(*args, **kwargs)
    Function signatures
      PCOLOR(C) - make a pseudocolor plot of matrix C
      PCOLOR(X, Y, C) - a pseudo color plot of C on the matrices X and Y
      PCOLOR(C, **kwargs) - Use keywork args to control colormapping and
                            scaling; see below
    X,Y and C may be masked arrays.  If either C[i,j], or one
    of the vertices surrounding C[i,j] (X or Y at [i,j],[i+1,j],
    [i,j+1],[i=1,j+1]) is masked, nothing is plotted.
    Optional keywork args are shown with their defaults below (you must
    use kwargs for these):
      * cmap = cm.jet : a cm Colormap instance from matplotlib.cm.
        defaults to cm.jet
      * norm = normalize() : matplotlib.colors.normalize is used to scale
        luminance data to 0,1.
      * vmin=None and vmax=None : vmin and vmax are used in conjunction
        with norm to normalize luminance data.  If either are None, the
        min and max of the color array C is used.  If you pass a norm
        instance, vmin and vmax will be None
      * shading = 'flat' : or 'faceted'.  If 'faceted', a black grid is
        drawn around each rectangle; if 'flat', edge colors are same as
        face colors
      * alpha=1.0 : the alpha blending value
    Return value is a matplotlib.collections.PatchCollection
    object
    Grid Orientation
        The behavior of meshgrid in matlab(TM) is a bit counterintuitive for
        x and y arrays.  For example,
            x = arange(7)
            y = arange(5)
            X, Y = meshgrid(x,y)
            Z = rand( len(x), len(y))
            pcolor(X, Y, Z)
        will fail in matlab and pylab.  You will probably be
        happy with
            pcolor(X, Y, transpose(Z))
        Likewise, for nonsquare Z,
            pcolor(transpose(Z))
        will make the x and y axes in the plot agree with the numrows and
        numcols of Z

    Addition kwargs: hold = [True|False] overrides default hold state

pcolor_classic(*args, **kwargs)
    PCOLOR_CLASSIC(self, *args, **kwargs)
    Function signatures
        pcolor(C) - make a pseudocolor plot of matrix C
        pcolor(X, Y, C) - a pseudo color plot of C on the matrices X and Y
        pcolor(C, cmap=cm.jet) - make a pseudocolor plot of matrix C using
          rectangle patches using a colormap jet.  Colormaps are avalible
          in matplotlib.cm.  You must pass this as a kwarg.
        pcolor(C, norm=normalize()) - the normalization function used
    `     to scale your color data to 0-1.  must be passed as a kwarg.
        pcolor(C, alpha=0.5) - set the alpha of the pseudocolor plot.
          Must be used as a kwarg
    Shading:
        The optional keyword arg shading ('flat' or 'faceted') will
        determine whether a black grid is drawn around each pcolor square.
        Default 'faceteted' e.g., pcolor(C, shading='flat') pcolor(X, Y,
        C, shading='faceted')
    Return value is a list of patch objects.
    Grid orientation
        The behavior of meshgrid in matlab(TM) is a bit counterintuitive for x
        and y arrays.  For example,
              x = arange(7)
              y = arange(5)
              X, Y = meshgrid(x,y)
              Z = rand( len(x), len(y))
              pcolor(X, Y, Z)
        will fail in matlab and matplotlib.  You will probably be
        happy with
            pcolor(X, Y, transpose(Z))
        Likewise, for nonsquare Z,
            pcolor(transpose(Z))
        will make the x and y axes in the plot agree with the numrows
        and numcols of Z

    Addition kwargs: hold = [True|False] overrides default hold state

pcolormesh(*args, **kwargs)
    PCOLORMESH(*args, **kwargs)
    Function signatures
      PCOLORMESH(C) - make a pseudocolor plot of matrix C
      PCOLORMESH(X, Y, C) - a pseudo color plot of C on the matrices X and Y
      PCOLORMESH(C, **kwargs) - Use keyword args to control colormapping and
                            scaling; see below
    X,Y and C may not be masked arrays, unlike with pcolor().
    Optional keyword args are shown with their defaults below (you must
    use kwargs for these):
      * cmap = cm.jet : a cm Colormap instance from matplotlib.cm.
        defaults to cm.jet
      * norm = normalize() : matplotlib.colors.normalize is used to scale
        luminance data to 0,1.
      * vmin=None and vmax=None : vmin and vmax are used in conjunction
        with norm to normalize luminance data.  If either are None, the
        min and max of the color array C is used.  If you pass a norm
        instance, vmin and vmax will be None
      * shading = 'flat' : or 'faceted'.  If 'faceted', a black grid is
        drawn around each rectangle; if 'flat', edge colors are same as
        face colors
      * alpha=1.0 : the alpha blending value
    Return value is a matplotlib.collections.PatchCollection
    object
    Grid Orientation
        The behavior of meshgrid in matlab(TM) is a bit counterintuitive for
        x and y arrays.  For example,
            x = arange(7)
            y = arange(5)
            X, Y = meshgrid(x,y)
            Z = rand( len(x), len(y))
            pcolor(X, Y, Z)
        will fail in matlab and pylab.  You will probably be
        happy with
            pcolor(X, Y, transpose(Z))
        Likewise, for nonsquare Z,
            pcolor(transpose(Z))
        will make the x and y axes in the plot agree with the numrows and
        numcols of Z

    Addition kwargs: hold = [True|False] overrides default hold state

pie(*args, **kwargs)
    PIE(x, explode=None, labels=None,
        colors=('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'),
        autopct=None, shadow=False)
    Make a pie chart of array x.  The fractional area of each wedge is
    given by x/sum(x).  If sum(x)<=1, then the values of x give the
    fractional area directly and the array will not be normalized.
      - explode, if not None, is a len(x) array which specifies the
        fraction of the radius to offset that wedge.
      - colors is a sequence of matplotlib color args that the pie chart
        will cycle.
      - labels, if not None, is a len(x) list of labels.
      - autopct, if not None, is a string or function used to label the
        wedges with their numeric value.  The label will be placed inside
        the wedge.  If it is a format string, the label will be fmt%pct.
        If it is a function, it will be called
      - shadow, if True, will draw a shadow beneath the pie.
    The pie chart will probably look best if the figure and axes are
    square.  Eg,
      figure(figsize=(8,8))
      ax = axes([0.1, 0.1, 0.8, 0.8])
    Return value:
      If autopct is None, return a list of (patches, texts), where patches
      is a sequence of matplotlib.patches.Wedge instances and texts is a
      list of the label Text instnaces
      If autopct is not None, return (patches, texts, autotexts), where
      patches and texts are as above, and autotexts is a list of text
      instances for the numeric labels

    Addition kwargs: hold = [True|False] overrides default hold state

pink()
    set the default colormap to pink and apply to current image if any.  See help(colormaps) for more information

plot(*args, **kwargs)
    PLOT(*args, **kwargs)
    Plot lines and/or markers to the Axes.  *args is a variable length
    argument, allowing for multiple x,y pairs with an optional format
    string.  For example, each of the following is legal
        plot(x,y)            # plot x and y using the default line style and color
        plot(x,y, 'bo')      # plot x and y using blue circle markers
        plot(y)              # plot y using x as index array 0..N-1
        plot(y, 'r+')        # ditto, but with red plusses
    An arbitrary number of x, y, fmt groups can be specified, as in
        a.plot(x1, y1, 'g^', x2, y2, 'g-')
    Return value is a list of lines that were added.
    The following line styles are supported:
        -     : solid line
        --    : dashed line
        -.    : dash-dot line
        :     : dotted line
        .     : points
        ,     : pixels
        o     : circle symbols
        ^     : triangle up symbols
        v     : triangle down symbols
        <     : triangle left symbols
        >     : triangle right symbols
        s     : square symbols
        +     : plus symbols
        x     : cross symbols
        D     : diamond symbols
        d     : thin diamond symbols
        1     : tripod down symbols
        2     : tripod up symbols
        3     : tripod left symbols
        4     : tripod right symbols
        h     : hexagon symbols
        H     : rotated hexagon symbols
        p     : pentagon symbols
        |     : vertical line symbols
        _     : horizontal line symbols
        steps : use gnuplot style 'steps' # kwarg only
    The following color strings are supported
        b  : blue
        g  : green
        r  : red
        c  : cyan
        m  : magenta
        y  : yellow
        k  : black
        w  : white
    Line styles and colors are combined in a single format string, as in
    'bo' for blue circles.
    The **kwargs can be used to set line properties (any property that has
    a set_* method).  You can use this to set a line label (for auto
    legends), linewidth, anitialising, marker face color, etc.  Here is an
    example:
        plot([1,2,3], [1,2,3], 'go-', label='line 1', linewidth=2)
        plot([1,2,3], [1,4,9], 'rs',  label='line 2')
        axis([0, 4, 0, 10])
        legend()
    If you make multiple lines with one plot command, the kwargs apply
    to all those lines, eg
        plot(x1, y1, x2, y2, antialised=False)
    Neither line will be antialiased.

    Addition kwargs: hold = [True|False] overrides default hold state

plot_date(*args, **kwargs)
    PLOT_DATE(x, y, fmt='bo', tz=None, xdate=True, ydate=False, **kwargs)
    Similar to the plot() command, except the x or y (or both) data
    is considered to be dates, and the axis is labeled accordingly.
    x or y (or both) can be a sequence of dates represented as
    float days since 0001-01-01 UTC.
    fmt is a plot format string.
    tz is the time zone to use in labelling dates.  Defaults to rc value.
    If xdate is True, the x-axis will be labeled with dates.
    If ydate is True, the y-axis will be labeled with dates.
    kwargs are passed on to plot.  See plot for more information.
    See matplotlib.dates for helper functions date2num, num2date
    and drange for help on creating the required floating point dates

    Addition kwargs: hold = [True|False] overrides default hold state

plotting()
    Plotting commands
    axes     - Create a new axes
    axis     - Set or return the current axis limits
    bar      - make a bar chart
    boxplot  - make a box and whiskers chart
    cla      - clear current axes
    clabel   - label a contour plot
    clf      - clear a figure window
    close    - close a figure window
    colorbar - add a colorbar to the current figure
    cohere   - make a plot of coherence
    contour  - make a contour plot
    contourf  - make a filled contour plot
    csd      - make a plot of cross spectral density
    draw     - force a redraw of the current figure
    errorbar - make an errorbar graph
    figlegend - add a legend to the figure
    figimage - add an image to the figure, w/o resampling
    figtext  - add text in figure coords
    figure   - create or change active figure
    fill     - make filled polygons
    gca      - return the current axes
    gcf      - return the current figure
    gci      - get the current image, or None
    get      - get a handle graphics property
    hist     - make a histogram
    hold     - set the hold state on current axes
    legend   - add a legend to the axes
    loglog   - a log log plot
    imread   - load image file into array
    imshow   - plot image data
    matshow  - display a matrix in a new figure preserving aspect
    pcolor   - make a pseudocolor plot
    plot     - make a line plot
    psd      - make a plot of power spectral density
    quiver   - make a direction field (arrows) plot
    rc       - control the default params
    savefig  - save the current figure
    scatter  - make a scatter plot
    set      - set a handle graphics property
    semilogx - log x axis
    semilogy - log y axis
    show     - show the figures
    specgram - a spectrogram plot
    stem     - make a stem plot
    subplot  - make a subplot (numrows, numcols, axesnum)
    table    - add a table to the axes
    text     - add some text at location x,y to the current axes
    title    - add a title to the current axes
    xlabel   - add an xlabel to the current axes
    ylabel   - add a ylabel to the current axes

    autumn - set the default colormap to autumn
    bone   - set the default colormap to bone
    cool   - set the default colormap to cool
    copper - set the default colormap to copper
    flag   - set the default colormap to flag
    gray   - set the default colormap to gray
    hot    - set the default colormap to hot
    hsv    - set the default colormap to hsv
    jet    - set the default colormap to jet
    pink   - set the default colormap to pink
    prism  - set the default colormap to prism
    spring - set the default colormap to spring
    summer - set the default colormap to summer
    winter - set the default colormap to winter

polar(*args, **kwargs)
    POLAR(theta, r)

    Make a polar plot.  Multiple theta, r arguments are supported,
    with format strings, as in plot.

prism()
    set the default colormap to prism and apply to current image if any.  See help(colormaps) for more information

psd(*args, **kwargs)
    PSD(x, NFFT=256, Fs=2, detrend=detrend_none,
        window=window_hanning, noverlap=0, **kwargs)
    The power spectral density by Welches average periodogram method.  The
    vector x is divided into NFFT length segments.  Each segment is
    detrended by function detrend and windowed by function window.
    noperlap gives the length of the overlap between segments.  The
    absolute(fft(segment))**2 of each segment are averaged to compute Pxx,
    with a scaling to correct for power loss due to windowing.  Fs is the
    sampling frequency.
        NFFT is the length of the fft segment; must be a power of 2
        Fs is the sampling frequency.
        detrend - the function applied to each segment before fft-ing,
          designed to remove the mean or linear trend.  Unlike in matlab,
          where the detrend parameter is a vector, in matplotlib is it a
          function.  The mlab module defines detrend_none, detrend_mean,
          detrend_linear, but you can use a custom function as well.
        window - the function used to window the segments.  window is a
          function, unlike in matlab(TM) where it is a vector.  mlab defines
          window_none, window_hanning, but you can use a custom function
          as well.
        noverlap gives the length of the overlap between segments.
        kwargs are passed to plot to control line props
    Returns the tuple Pxx, freqs
    For plotting, the power is plotted as 10*log10(pxx)) for decibels,
    though pxx itself is returned
    Refs:
      Bendat & Piersol -- Random Data: Analysis and Measurement
      Procedures, John Wiley & Sons (1986)

    Addition kwargs: hold = [True|False] overrides default hold state

pymax = max(...)
    max(sequence) -> value
    max(a, b, c, ...) -> value

    With a single sequence argument, return its largest item.
    With two or more arguments, return the largest argument.

pymin = min(...)
    min(sequence) -> value
    min(a, b, c, ...) -> value

    With a single sequence argument, return its smallest item.
    With two or more arguments, return the smallest argument.

quiver(*args, **kwargs)
    QUIVER( X, Y, U, V )
    QUIVER( U, V )
    QUIVER( X, Y, U, V, S)
    QUIVER( U, V, S )
    QUIVER( ..., color=None, width=1.0, cmap=None,norm=None )
    Make a vector plot (U, V) with arrows on a grid (X, Y)

    The optional arguments color and width are used to specify the color
    and width of the arrow. color can be an array of colors in which case
    the arrows can be colored according to another dataset.

    If cm is specied and color is None, the colormap is used to give a color
    according to the vector's length.

    If color is a scalar field, the colormap is used to map the scalar to a
    color

    If a colormap is specified and color is an array of color triplets,
    then the colormap is ignored

    width is a scalar that controls the width of the arrows

    if S is specified it is used to scale the vectors. Use S=0 to disable
    automatic scaling.

    If S!=0, vectors are scaled to fit within the grid and then are
    multiplied by S.

    Addition kwargs: hold = [True|False] overrides default hold state

raise_msg_to_str(msg)
    msg is a return arg from a raise.  Join with new lines

rand(...)
    Return an array of the given dimensions which is initialized to
    random numbers from a uniform distribution in the range [0,1).

    rand(d0, d1, ..., dn) -> random values

randn(...)
    Returns zero-mean, unit-variance Gaussian random numbers in an
    array of shape (d0, d1, ..., dn).

    randn(d0, d1, ..., dn) -> random values

rc(*args, **kwargs)
    Set the current rc params.  Group is the grouping for the rc, eg
    for lines.linewidth the group is 'lines', for axes.facecolor, the
    group is 'axes', and so on.  Group may also be a list or tuple
    of group names, eg ('xtick','ytick').  kwargs is a list of
    attribute name/value pairs, eg
      rc('lines', linewidth=2, color='r')
    sets the current rc params and is equivalent to
      rcParams['lines.linewidth'] = 2
      rcParams['lines.color'] = 'r'
    The following aliases are available to save typing for interactive
    users
        'lw'  : 'linewidth'
        'ls'  : 'linestyle'
        'c'   : 'color'
        'fc'  : 'facecolor'
        'ec'  : 'edgecolor'
        'mfc' : 'markerfacecolor'
        'mec' : 'markeredgecolor'
        'mew' : 'markeredgewidth'
        'aa'  : 'antialiased'
    Thus you could abbreviate the above rc command as
          rc('lines', lw=2, c='r')
    Note you can use python's kwargs dictionary facility to store
    dictionaries of default parameters.  Eg, you can customize the
    font rc as follows
      font = {'family' : 'monospace',
              'weight' : 'bold',
              'size'   : 'larger',
             }
      rc('font', **font)  # pass in the font dict as kwargs
    This enables you to easily switch between several configurations.
    Use rcdefaults to restore the default rc params after changes.

rcdefaults()
    Restore the default rc params - the ones that were created at
    matplotlib load time

register_dtype(...)
    register_dtype(a) registers a new type object -- gives it a typenum

rgrids(*args, **kwargs)
    Set/Get the radial locations of the gridlines and ticklabels

    With no args, simply return lines, labels where lines is an
    array of radial gridlines (Line2D instances) and labels is an
    array of tick labels (Text instances).

      lines, labels = rgrids()

    With arguments, the syntax is

      lines, labels = RGRIDS(radii, labels=None, angle=22.5, **kwargs)

    The labels will appear at radial distances radii at angle

      labels, if not None, is a len(radii) list of strings of the
      labels to use at each angle.

      if labels is None, the self.rformatter will be used

    Return value is a list of lines, labels where the lines are
    matplotlib.Line2D instances and the labels are matplotlib.Text
    instances.  Note that on input the labels argument is a list of
    strings, and on output it is a list of Text instances

    Examples
      # set the locations of the radial gridlines and labels
      lines, labels = rgrids( (0.25, 0.5, 1.0) )

      # set the locations and labels of the radial gridlines and labels
      lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' )

save(fname, X, fmt='%.18e', delimiter=' ')
    Save the data in X to file fname using fmt string to convert the
    data to strings

    fname can be a filename or a file handle.  If the filename ends in .gz,
    the file is automatically saved in compressed gzip format.  The load()
    command understands gzipped files transparently.

    Example usage:

    save('test.out', X)         # X is an array
    save('test1.out', (x,y,z))  # x,y,z equal sized 1D arrays
    save('test2.out', x)        # x is 1D
    save('test3.out', x, fmt='%1.4e')  # use exponential notation

    delimiter is used to separate the fields, eg delimiter ',' for
    comma-separated values

savefig(*args, **kwargs)
    SAVEFIG(fname, dpi=150, facecolor='w', edgecolor='w',
    orientation='portrait'):
    Save the current figure to filename fname.  dpi is the resolution
    in dots per inch.
    Output file types currently supported are jpeg and png and will be
    deduced by the extension to fname
    facecolor and edgecolor are the colors os the figure rectangle
    orientation is either 'landscape' or 'portrait' - not supported on
    all backends; currently only on postscript output.

scatter(*args, **kwargs)
    SCATTER(x, y, s=20, c='b', marker='o', cmap=None, norm=None,
            vmin=None, vmax=None, alpha=1.0, linewidths=None,
            faceted=True, **kwargs)
        Supported function signatures:
            SCATTER(x, y) - make a scatter plot of x vs y
            SCATTER(x, y, s) - make a scatter plot of x vs y with size in area
              given by s
            SCATTER(x, y, s, c) - make a scatter plot of x vs y with size in area
              given by s and colors given by c
            SCATTER(x, y, s, c, **kwargs) - control colormapping and scaling
              with keyword args; see below
        Make a scatter plot of x versus y.  s is a size in points^2 a scalar
        or an array of the same length as x or y.  c is a color and can be a
        single color format string or an length(x) array of intensities which
        will be mapped by the matplotlib.colors.colormap instance cmap
        The marker can be one of
            's' : square
            'o' : circle
            '^' : triangle up
            '>' : triangle right
            'v' : triangle down
            '<' : triangle left
            'd' : diamond
            'p' : pentagram
            'h' : hexagon
            '8' : octagon
        s is a size argument in points squared.
        Any or all of x, y, s, and c may be masked arrays, in which
        case all masks will be combined and only unmasked points
        will be plotted.
        Other keyword args; the color mapping and normalization arguments will
        on be used if c is an array of floats
          * cmap = cm.jet : a cm Colormap instance from matplotlib.cm.
            defaults to rc image.cmap
          * norm = normalize() : matplotlib.colors.normalize is used to
            scale luminance data to 0,1.
          * vmin=None and vmax=None : vmin and vmax are used in conjunction
            with norm to normalize luminance data.  If either are None, the
            min and max of the color array C is used.  Note if you pass a norm
            instance, your settings for vmin and vmax will be ignored
          * alpha =1.0 : the alpha value for the patches
          * linewidths, if None, defaults to (lines.linewidth,).  Note
            that this is a tuple, and if you set the linewidths
            argument you must set it as a sequence of floats, as
            required by PolyCollection -- see
            matplotlib.collections.PolyCollection for details
         * faceted: if True, will use the default edgecolor for the
           markers.  If False, will set the edgecolors to be the same
           as the facecolors

    Addition kwargs: hold = [True|False] overrides default hold state

scatter_classic(*args, **kwargs)
    SCATTER_CLASSIC(x, y, s=None, c='b')
    Make a scatter plot of x versus y.  s is a size (in data coords) and
    can be either a scalar or an array of the same length as x or y.  c is
    a color and can be a single color format string or an length(x) array
    of intensities which will be mapped by the colormap jet.
    If size is None a default size will be used

    Addition kwargs: hold = [True|False] overrides default hold state

semilogx(*args, **kwargs)
    SEMILOGX(*args, **kwargs)
    Make a semilog plot with log scaling on the x axis.  The args to
    semilog x are the same as the args to plot.  See help plot for more
    info.
    Optional keyword args supported are any of the kwargs supported by
    plot or set_xscale.  Notable, for log scaling:
        * basex: base of the logarithm
        * subsx: the location of the minor ticks; None defaults to autosubs,
        which depend on the number of decades in the plot

    Addition kwargs: hold = [True|False] overrides default hold state

semilogy(*args, **kwargs)
    SEMILOGY(*args, **kwargs):
    Make a semilog plot with log scaling on the y axis.  The args to
    semilogy are the same as the args to plot.  See help plot for more
    info.
    Optional keyword args supported are any of the kwargs supported by
    plot or set_yscale.  Notable, for log scaling:
        * basey: base of the logarithm
        * subsy: the location of the minor ticks; None defaults to autosubs,
        which depend on the number of decades in the plot

    Addition kwargs: hold = [True|False] overrides default hold state

set_numeric_ops(...)
    set_numeric_ops(op=func, ...) sets some or all of the number methods for all array objects.  Don't forget **dict can be used as the argument list.  Returns the functions that were replaced -- can be stored and set later.

set_string_function(...)
    set_string_function(f, repr=1) sets the python function f to be the function used to obtain a pretty printable string version of a array whenever a array is printed.  f(M) should expect a array argument M, and should return a string consisting of the desired representation of M for printing.

setp(*args, **kwargs)
    matplotlib supports the use of setp ("set property") and getp to set and get object properties, as well as to do
    introspection on the object For example, to set the linestyle of a
    line to be dashed, you can do

      >>> line, = plot([1,2,3])
      >>> setp(line, linestyle='--')

    If you want to know the valid types of arguments, you can provide the
    name of the property you want to set without a value

      >>> setp(line, 'linestyle')
          linestyle: [ '-' | '--' | '-.' | ':' | 'steps' | 'None' ]

    If you want to see all the properties that can be set, and their
    possible values, you can do


      >>> setp(line)
          ... long output listing omitted'

    setp operates on a single instance or a list of instances.  If you are
    in quey mode introspecting the possible values, only the first
    instance in the sequnce is used.  When actually setting values, all
    the instances will be set.  Eg, suppose you have a list of two lines,
    the following will make both lines thicker and red

        >>> x = arange(0,1.0,0.01)
        >>> y1 = sin(2*pi*x)
        >>> y2 = sin(4*pi*x)
        >>> lines = plot(x, y1, x, y2)
        >>> setp(lines, linewidth=2, color='r')

    Set works with the matlab(TM) style string/value pairs or with
    python kwargs.  For example, the following are equivalent

        >>> setp(lines, 'linewidth', 2, 'color', r')  # matlab style
        >>> setp(lines, linewidth=2, color='r')       # python style

specgram(*args, **kwargs)
    SPECGRAM(x, NFFT=256, Fs=2, detrend=detrend_none,
             window=window_hanning, noverlap=128,
             cmap=None, xextent=None)
    Compute a spectrogram of data in x.  Data are split into NFFT length
    segements and the PSD of each section is computed.  The windowing
    function window is applied to each segment, and the amount of overlap
    of each segment is specified with noverlap.
        * cmap is a colormap; if None use default determined by rc
        * xextent is the image extent in the xaxes xextent=xmin, xmax -
          default 0, max(bins), 0, max(freqs) where bins is the return
          value from matplotlib.matplotlib.mlab.specgram
        * See help(psd) for information on the other keyword arguments.
    Return value is (Pxx, freqs, bins, im), where
        bins are the time points the spectrogram is calculated over
        freqs is an array of frequencies
        Pxx is a len(times) x len(freqs) array of power
        im is a matplotlib.image.AxesImage.

    Addition kwargs: hold = [True|False] overrides default hold state

spring()
    set the default colormap to spring and apply to current image if any.  See help(colormaps) for more information

spy(*args, **kwargs)
    SPY(Z, **kwrags) plots the sparsity pattern of the matrix S
    using plot markers.
    kwargs give the marker properties - see help(plot) for more
    information on marker properties
    The line handles are returned

    Addition kwargs: hold = [True|False] overrides default hold state

spy2(*args, **kwargs)
    SPY2(Z) plots the sparsity pattern of the matrix S as an image
    The image instance is returned

    Addition kwargs: hold = [True|False] overrides default hold state

stem(*args, **kwargs)
    STEM(x, y, linefmt='b-', markerfmt='bo', basefmt='r-')
    A stem plot plots vertical lines (using linefmt) at each x location
    from the baseline to y, and places a marker there using markerfmt.  A
    horizontal line at 0 is is plotted using basefmt
    Return value is (markerline, stemlines, baseline) .
    See
    http://www.mathworks.com/access/helpdesk/help/techdoc/ref/stem.html
    for details and examples/stem_plot.py for a demo.

    Addition kwargs: hold = [True|False] overrides default hold state

subplot(*args, **kwargs)
    Create a subplot command, creating axes with

      subplot(numRows, numCols, plotNum)

    where plotNum=1 is the first plot number and increasing plotNums
    fill rows first.  max(plotNum)==numRows*numCols

    You can leave out the commas if numRows<=numCols<=plotNum<10, as
    in

      subplot(211)    # 2 rows, 1 column, first (upper) plot

    subplot(111) is the default axis

    The background color of the subplot can be specified via keyword
    argument 'axisbg', which takes a color string or gdk.Color as value, as in

    subplot(211, axisbg='y')

    See help(axes) for additional information on axes and subplot
    keyword arguments.

    New subplots that overlap old will delete the old axes.  If you do
    not want this behavior, use fig.add_subplot or the axes command.  Eg

      from pylab import *
      plot([1,2,3])  # implicitly creates subplot(111)
      subplot(211)   # overlaps, subplot(111) is killed
      plot(rand(12), rand(12))

subplot_tool(targetfig=None)
    Launch a subplot tool window for targetfig (default gcf)

    A matplotlib.widgets.SubplotTool instance is returned

subplots_adjust(*args, **kwargs)
    subplots_adjust(left=None, right=None, bottom=None, top=None, wspace=0.2, hspace=0.2)

    Tune the subplot layout via the figure.SubplotParams mechanism.
    The parameter meanings (and suggested defaults) are

      left  = 0.125  # the left side of the subplots of the figure
      right = 0.9    # the right side of the subplots of the figure
      bottom = 0.1   # the bottom of the subplots of the figure
      top = 0.9      # the top of the subplots of the figure
      wspace = 0.2   # the amount of width reserved for blank space between subplots
      hspace = 0.2   # the amount of height reserved for white space between subplots

    The actual defaults are controlled by the rc file

summer()
    set the default colormap to summer and apply to current image if any.  See help(colormaps) for more information

switch_backend(newbackend)
    Swtich the default backend to newbackend.  This feature is
    EXPERIMENTAL, and is only expected to work switching to an image
    backend.  Eg, if you have a bunch of PS scripts that you want to
    run from an interactive ipython session, yuo may want to switch to
    the PS backend before running them to avoid having a bunch of GUI
    windows popup.  If you try to interactively switch from one GUI
    backend to another, you will explode.

    Calling this command will close all open windows.

table(*args, **kwargs)
    TABLE(cellText=None, cellColours=None,
          cellLoc='right', colWidths=None,
          rowLabels=None, rowColours=None, rowLoc='left',
          colLabels=None, colColours=None, colLoc='center',
          loc='bottom', bbox=None):
    Add a table to the current axes.  Returns a table instance.  For
    finer grained control over tables, use the Table class and add it
    to the axes with add_table.
    Thanks to John Gill for providing the class and table.

text(*args, **kwargs)
    TEXT(x, y, s, fontdict=None, **kwargs)
    Add text in string s to axis at location x,y (data coords)
      fontdict is a dictionary to override the default text properties.
      If fontdict is None, the defaults are determined by your rc
      parameters.
      withdash=True will create a TextWithDash instance instead
      of a Text instance.
    Individual keyword arguemnts can be used to override any given
    parameter
        text(x, y, s, fontsize=12)
    The default transform specifies that text is in data coords,
    alternatively, you can specify text in axis coords (0,0 lower left and
    1,1 upper right).  The example below places text in the center of the
    axes
        text(0.5, 0.5,'matplotlib',
             horizontalalignment='center',
             verticalalignment='center',
             transform = ax.transAxes,
        )

thetagrids(*args, **kwargs)
    Set/Get the theta locations of the gridlines and ticklabels

    If no arguments are passed, return lines, labels where lines is an
    array of radial gridlines (Line2D instances) and labels is an
    array of tick labels (Text instances).

      lines, labels = thetagrids()

    Otherwise the syntax is

      lines, labels = THETAGRIDS(angles, labels=None, fmt='%d', frac = 1.1)

    set the angles at which to place the theta grids (these gridlines
    are equal along the theta dimension).  angles is in degrees

      labels, if not None, is a len(angles) list of strings of the
      labels to use at each angle.

      if labels is None, the labels with be fmt%angle

      frac is the fraction of the polar axes radius at which to place
      the label (1 is the edge).Eg 1.05 isd outside the axes and 0.95
      is inside the axes

    Return value is a list of lines, labels where the lines are
    matplotlib.Line2D instances and the labels are matplotlib.Text
    instances.  Note that on input the labels argument is a list of
    strings, and on output it is a list of Text instances

    Examples:

      # set the locations of the radial gridlines and labels
      lines, labels = thetagrids( range(45,360,90) )

      # set the locations and labels of the radial gridlines and labels
      lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )

title(s, *args, **kwargs)
    Set the title of the current axis to s

    Default font override is:
      override = {
        'fontsize'            : 'medium',
        'verticalalignment'   : 'bottom',
        'horizontalalignment' : 'center'
      }

    See the text docstring for information of how override and the
    optional args work

twinx(ax=None)
    Make a second axes overlay ax (or the current axes if ax is None)
    sharing the xaxis.  The ticks for ax2 will be placed on the right,
    and the ax2 instance is returned.  See examples/two_scales.py

update_use_defaults(...)

vlines(*args, **kwargs)
    VLINES(x, ymin, ymax, color='k')
    Plot vertical lines at each x from ymin to ymax.  ymin or ymax can be
    scalars or len(x) numpy arrays.  If they are scalars, then the
    respective values are constant, else the heights of the lines are
    determined by ymin and ymax
    fmt is a plot format string, eg 'g--'
    kwargs are matplotlib.lines.Line2D kwargs
    Returns a list of lines that were added

    Addition kwargs: hold = [True|False] overrides default hold state

where(...)
    where(condition, | x, y) is shaped like condition and has elements of x and y where condition is respectively true or false.  If x or y are not given, then it is equivalent to nonzero(condition).

winter()
    set the default colormap to winter and apply to current image if any.  See help(colormaps) for more information

xlabel(s, *args, **kwargs)
    Set the x axis label of the current axis to s

    Default override is

      override = {
          'fontsize'            : 'small',
          'verticalalignment'   : 'top',
          'horizontalalignment' : 'center'
          }

    See the text docstring for information of how override and
    the optional args work

xlim(*args, **kwargs)
    Set/Get the xlimits of the current axes

    xmin, xmax = xlim()   : return the current xlim
    xlim( (xmin, xmax) )  : set the xlim to xmin, xmax
    xlim( xmin, xmax )    : set the xlim to xmin, xmax

    If you do not specify args, you can pass the xmin and xmax as
    kwargs, eg

      xlim(xmax=3) # adjust the max leaving min unchanged
      xlim(xmin=1) # adjust the min leaving max unchanged

    The new axis limits are returned as a length 2 tuple

xticks(*args, **kwargs)
    Set/Get the xlimits of the current ticklocs, labels

    # return locs, labels where locs is an array of tick locations and
    # labels is an array of tick labels.
    locs, labels = xticks()

    # set the locations of the xticks
    xticks( arange(6) )

    # set the locations and labels of the xticks
    xticks( arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue') )

    The keyword args, if any, are text properties; see text for more
    information on text properties.

ylabel(s, *args, **kwargs)
    Set the y axis label of the current axis to s

    Defaults override is

        override = {
           'fontsize'            : 'small',
           'verticalalignment'   : 'center',
           'horizontalalignment' : 'right',
           'rotation'='vertical' : }

    See the text docstring for information of how override and the
    optional args work

ylim(*args, **kwargs)
    Set/Get the ylimits of the current axes

    ymin, ymax = ylim()   : return the current ylim
    ylim( (ymin, ymax) )  : set the ylim to ymin, ymax
    ylim( ymin, ymax )    : set the ylim to ymin, ymax

    If you do not specify args, you can pass the ymin and ymax as
    kwargs, eg

      ylim(ymax=3) # adjust the max leaving min unchanged
      ylim(ymin=1) # adjust the min leaving max unchanged

    The new axis limits are returned as a length 2 tuple

yticks(*args, **kwargs)
    Set/Get the ylimits of the current ticklocs, labels

    # return locs, labels where locs is an array of tick locations and
    # labels is an array of tick labels.
    locs, labels = yticks()

    # set the locations of the yticks
    yticks( arange(6) )

    # set the locations and labels of the yticks
    yticks( arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue') )

    The keyword args, if any, are text properties; see text for more
    information on text properties.

zeros(...)
    zeros((d1,...,dn),dtype=int,fortran=0) will return a new array of shape (d1,...,dn) and type typecode with all it's entries initialized to zero.


Data
      	  	Bool = '?'
Character = 'S1'
Complex = 'D'
Complex0 = 'D'
Complex32 = 'F'
Complex64 = 'D'
DAILY = 3
ERR_CALL = 3
ERR_DEFAULT = 0
ERR_IGNORE = 0
ERR_RAISE = 2
ERR_WARN = 1
FLOATING_POINT_SUPPORT = 1
FPE_DIVIDEBYZERO = 1
FPE_INVALID = 8
FPE_OVERFLOW = 2
FPE_UNDERFLOW = 4
FR = FR
False_ = False
Float = 'd'
Float0 = 'd'
Float32 = 'f'
Float64 = 'd'
HOURLY = 4
Inf = inf
Infinity = inf
Int = 'l'
Int0 = 'l'
Int16 = 'h'
Int32 = 'i'
Int64 = 'q'
Int8 = 'b'
LittleEndian = True
MINUTELY = 5
MO = MO
MONTHLY = 1
NAN = nan
NINF = -inf
NZERO = -0.0
NaN = nan
NewAxis = None
PINF = inf
PZERO = 0.0
PyObject = 'O'
SA = SA
SECONDLY = 6
SHIFT_DIVIDEBYZERO = 0
SHIFT_INVALID = 6
SHIFT_OVERFLOW = 2
SHIFT_UNDERFLOW = 4
SU = SU
ScalarType = (<type 'int'>, <type 'float'>, <type 'complex'>, <type 'long'>, <type 'bool'>, <type 'str'>, <type 'unicode'>, <type 'buffer'>, <type 'int64_arrtype'>, <type 'int16_arrtype'>, <type 'float64_arrtype'>, <type 'float32_arrtype'>, <type 'float96_arrtype'>, <type 'uint32_arrtype'>, <type 'bool_arrtype'>, <type 'int32_arrtype'>, <type 'complex192_arrtype'>, <type 'string_arrtype'>, <type 'uint32_arrtype'>, <type 'int32_arrtype'>, ...)
TH = TH
TU = TU
True_ = True
UFUNC_BUFSIZE_DEFAULT = 10000
UFUNC_PYVALS_NAME = 'UFUNC_PYVALS'
UInt16 = 'H'
UInt32 = 'I'
UInt64 = 'Q'
UInt8 = 'B'
UnsignedInt = 'L'
UnsignedInt16 = 'H'
UnsignedInt64 = 'Q'
UnsignedInt8 = 'B'
WE = WE
WEEKLY = 2
YEARLY = 0
__dates_all__ = ('date2num', 'num2date', 'drange', 'epoch2num', 'num2epoch', 'mx2num', 'DateFormatter', 'IndexDateFormatter', 'DateLocator', 'RRuleLocator', 'YearLocator', 'MonthLocator', 'WeekdayLocator', 'DayLocator', 'HourLocator', 'MinuteLocator', 'SecondLocator', 'rrule', 'MO', 'TU', ...)
absolute = <ufunc 'absolute'>
add = <ufunc 'add'>
arccos = <ufunc 'arccos'>
arccosh = <ufunc 'arccosh'>
arcsin = <ufunc 'arcsin'>
arcsinh = <ufunc 'arcsinh'>
arctan = <ufunc 'arctan'>
arctan2 = <ufunc 'arctan2'>
arctanh = <ufunc 'arctanh'>
arraytypes = {'complex': [<type 'complex64_arrtype'>, <type 'complex128_arrtype'>], 'float': [<type 'float32_arrtype'>, <type 'float64_arrtype'>, <type 'float96_arrtype'>], 'int': [<type 'int8_arrtype'>, <type 'int16_arrtype'>, <type 'int32_arrtype'>, <type 'int64_arrtype'>], 'others': [<type 'bool'>, <type 'object'>, <type 'str'>, <type 'unicode'>, <type 'void_arrtype'>], 'uint': [<type 'uint8_arrtype'>, <type 'uint16_arrtype'>, <type 'uint32_arrtype'>, <type 'uint64_arrtype'>]}
bitwise_and = <ufunc 'bitwise_and'>
bitwise_or = <ufunc 'bitwise_or'>
bitwise_xor = <ufunc 'bitwise_xor'>
cast = {<type 'int64_arrtype'>: <function <lambda> at 0...t64_arrtype'>: <function <lambda> at 0xb7cfe7d4>}
ceil = <ufunc 'ceil'>
conj = <ufunc 'conjugate'>
conjugate = <ufunc 'conjugate'>
cos = <ufunc 'cos'>
cosh = <ufunc 'cosh'>
divide = <ufunc 'divide'>
e = 2.7182818284590451
equal = <ufunc 'equal'>
exp = <ufunc 'exp'>
expm1 = <ufunc 'expm1'>
fabs = <ufunc 'fabs'>
floor = <ufunc 'floor'>
floor_divide = <ufunc 'floor_divide'>
fmod = <ufunc 'fmod'>
frexp = <ufunc 'frexp'>
greater = <ufunc 'greater'>
greater_equal = <ufunc 'greater_equal'>
hypot = <ufunc 'hypot'>
inf = inf
infty = inf
invert = <ufunc 'invert'>
isfinite = <ufunc 'isfinite'>
isinf = <ufunc 'isinf'>
isnan = <ufunc 'isnan'>
ldexp = <ufunc 'ldexp'>
left_shift = <ufunc 'left_shift'>
less = <ufunc 'less'>
less_equal = <ufunc 'less_equal'>
little_endian = True
log = <ufunc 'log'>
log10 = <ufunc 'log10'>
log1p = <ufunc 'log1p'>
logical_and = <ufunc 'logical_and'>
logical_not = <ufunc 'logical_not'>
logical_or = <ufunc 'logical_or'>
logical_xor = <ufunc 'logical_xor'>
maximum = <ufunc 'maximum'>
minimum = <ufunc 'minimum'>
mod = <ufunc 'remainder'>
modf = <ufunc 'modf'>
multiply = <ufunc 'multiply'>
nan = nan
nbytes = {<type 'int64_arrtype'>: 8, <type 'int16_arrtype...lex128_arrtype'>: 16, <type 'object_arrtype'>: 4}
negative = <ufunc 'negative'>
newaxis = None
not_equal = <ufunc 'not_equal'>
pi = 3.1415926535897931
power = <ufunc 'power'>
rcParams = {'axes.edgecolor': 'black', 'axes.facecolor': 'white', 'axes.grid': False, 'axes.hold': True, 'axes.labelcolor': 'black', 'axes.labelsize': 12.0, 'axes.linewidth': 1.0, 'axes.titlesize': 14.0, 'backend': 'GTKAgg', 'datapath': '/usr/lib/python2.4/site-packages/matplotlib/mpl-data', ...}
rcParamsDefault = {'axes.edgecolor': 'black', 'axes.facecolor': 'white', 'axes.grid': False, 'axes.hold': True, 'axes.labelcolor': 'black', 'axes.labelsize': 12.0, 'axes.linewidth': 1.0, 'axes.titlesize': 14.0, 'backend': 'GTKAgg', 'datapath': '/usr/lib/python2.4/site-packages/matplotlib/mpl-data', ...}
remainder = <ufunc 'remainder'>
right_shift = <ufunc 'right_shift'>
sign = <ufunc 'sign'>
signbit = <ufunc 'signbit'>
sin = <ufunc 'sin'>
sinh = <ufunc 'sinh'>
sqrt = <ufunc 'sqrt'>
subtract = <ufunc 'subtract'>
tan = <ufunc 'tan'>
tanh = <ufunc 'tanh'>
true_divide = <ufunc 'true_divide'>
typeDict = {0: <type 'bool_arrtype'>, 1: <type 'int8_arrtype'>, 2: <type 'uint8_arrtype'>, 3: <type 'int16_arrtype'>, 4: <type 'uint16_arrtype'>, 5: <type 'int32_arrtype'>, 6: <type 'uint32_arrtype'>, 7: <type 'int32_arrtype'>, 8: <type 'uint32_arrtype'>, 9: <type 'int64_arrtype'>, ...}
typeNA = {'?': 'Bool', 'B': 'UInt8', 'Bool': <type 'bool_arrtype'>, 'Complex32': <type 'complex64_arrtype'>, 'Complex64': <type 'complex128_arrtype'>, 'Complex96': <type 'complex192_arrtype'>, 'D': 'Complex64', 'F': 'Complex32', 'Float32': <type 'float32_arrtype'>, 'Float64': <type 'float64_arrtype'>, ...}
typecodes = {'All': '?bhilqpBHILQPfdgFDGSUVO', 'AllFloat': 'fdgFDG', 'AllInteger': 'bBhHiIlLqQpP', 'Character': 'S1', 'Complex': 'FDG', 'Float': 'fdg', 'Integer': 'bhilqp', 'UnsignedInteger': 'BHILQP'}
which = ('numpy', 'rc')

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

---------------------------------------------------------------------------
axes


    Add an axes at position rect specified by:

    - ``axes()`` by itself creates a default full ``subplot(111)`` window axis.

    - ``axes(rect, axisbg='w')`` where *rect* = [left, bottom, width,
      height] in normalized (0, 1) units.  *axisbg* is the background
      color for the axis, default white.

    - ``axes(h)`` where *h* is an axes instance makes *h* the current
      axis.  An :class:`~matplotlib.axes.Axes` instance is returned.

    =======   ============   ================================================
    kwarg     Accepts        Desctiption
    =======   ============   ================================================
    axisbg    color          the axes background color
    frameon   [True|False]   display the frame?
    sharex    otherax        current axes shares xaxis attribute with otherax
    sharey    otherax        current axes shares yaxis attribute with otherax
    polar     [True|False]   use a polar axes?
    =======   ============   ================================================

    Examples:

    * :file:`examples/pylab_examples/axes_demo.py` places custom axes.
    * :file:`examples/pylab_examples/shared_axis_demo.py` uses
      *sharex* and *sharey*.


---------------------------------------------------------------------------
axhline

call signature::

  axhline(y=0, xmin=0, xmax=1, **kwargs)

Axis Horizontal Line

Draw a horizontal line at *y* from *xmin* to *xmax*.  With the
default values of *xmin* = 0 and *xmax* = 1, this line will
always span the horizontal extent of the axes, regardless of
the xlim settings, even if you change them, eg. with the
:meth:`set_xlim` command.  That is, the horizontal extent is
in axes coords: 0=left, 0.5=middle, 1.0=right but the *y*
location is in data coordinates.

Return value is the :class:`~matplotlib.lines.Line2D`
instance.  kwargs are the same as kwargs to plot, and can be
used to control the line properties.  Eg.,

* draw a thick red hline at *y* = 0 that spans the xrange

    >>> axhline(linewidth=4, color='r')

* draw a default hline at *y* = 1 that spans the xrange

    >>> axhline(y=1)

* draw a default hline at *y* = .5 that spans the the middle half of
  the xrange

    >>> axhline(y=.5, xmin=0.25, xmax=0.75)

Valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

.. seealso::

    :meth:`axhspan`
        for example plot and source code

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
axhspan

call signature::

  axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs)

Axis Horizontal Span.

*y* coords are in data units and *x* coords are in axes (relative
0-1) units.

Draw a horizontal span (rectangle) from *ymin* to *ymax*.
With the default values of *xmin* = 0 and *xmax* = 1, this
always spans the xrange, regardless of the xlim settings, even
if you change them, eg. with the :meth:`set_xlim` command.
That is, the horizontal extent is in axes coords: 0=left,
0.5=middle, 1.0=right but the *y* location is in data
coordinates.

Return value is a :class:`matplotlib.patches.Polygon`
instance.

Examples:

* draw a gray rectangle from *y* = 0.25-0.75 that spans the
  horizontal extent of the axes

    >>> axhspan(0.25, 0.75, facecolor='0.5', alpha=0.5)

Valid kwargs are :class:`~matplotlib.patches.Polygon` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]  or None for default
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function
  edgecolor or ec: mpl color spec, or None for default, or 'none' for no color
  facecolor or fc: mpl color spec, or None for default, or 'none' for no color
  figure: a :class:`matplotlib.figure.Figure` instance
  fill: [True | False]
  gid: an id string
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
  label: any string
  linestyle or ls: ['solid' | 'dashed' | 'dashdot' | 'dotted']
  linewidth or lw: float or None for default
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/axhspan_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
axis


    Set/Get the axis properties:

      >>> axis()

    returns the current axes limits ``[xmin, xmax, ymin, ymax]``.

      >>> axis(v)

    sets the min and max of the x and y axes, with
    ``v = [xmin, xmax, ymin, ymax]``.

      >>> axis('off')

    turns off the axis lines and labels.

      >>> axis('equal')

    changes limits of *x* or *y* axis so that equal increments of *x*
    and *y* have the same length; a circle is circular.

      >>> axis('scaled')

    achieves the same result by changing the dimensions of the plot box instead
    of the axis data limits.

      >>> axis('tight')

    changes *x* and *y* axis limits such that all data is shown. If
    all data is already shown, it will move it to the center of the
    figure without modifying (*xmax* - *xmin*) or (*ymax* -
    *ymin*). Note this is slightly different than in matlab.

      >>> axis('image')

    is 'scaled' with the axis limits equal to the data limits.

      >>> axis('auto')

    and

      >>> axis('normal')

    are deprecated. They restore default behavior; axis limits are automatically
    scaled to make the data fit comfortably within the plot box.

    if ``len(*v)==0``, you can pass in *xmin*, *xmax*, *ymin*, *ymax*
    as kwargs selectively to alter just those limits without changing
    the others.

    The xmin, xmax, ymin, ymax tuple is returned

    .. seealso::

        :func:`xlim`, :func:`ylim`
           For setting the x- and y-limits individually.

---------------------------------------------------------------------------
axvline

call signature::

  axvline(x=0, ymin=0, ymax=1, **kwargs)

Axis Vertical Line

Draw a vertical line at *x* from *ymin* to *ymax*.  With the
default values of *ymin* = 0 and *ymax* = 1, this line will
always span the vertical extent of the axes, regardless of the
ylim settings, even if you change them, eg. with the
:meth:`set_ylim` command.  That is, the vertical extent is in
axes coords: 0=bottom, 0.5=middle, 1.0=top but the *x* location
is in data coordinates.

Return value is the :class:`~matplotlib.lines.Line2D`
instance.  kwargs are the same as kwargs to plot, and can be
used to control the line properties.  Eg.,

* draw a thick red vline at *x* = 0 that spans the yrange

    >>> axvline(linewidth=4, color='r')

* draw a default vline at *x* = 1 that spans the yrange

    >>> axvline(x=1)

* draw a default vline at *x* = .5 that spans the the middle half of
  the yrange

    >>> axvline(x=.5, ymin=0.25, ymax=0.75)

Valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

.. seealso::

    :meth:`axhspan`
        for example plot and source code

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
axvspan

call signature::

  axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs)

Axis Vertical Span.

*x* coords are in data units and *y* coords are in axes (relative
0-1) units.

Draw a vertical span (rectangle) from *xmin* to *xmax*.  With
the default values of *ymin* = 0 and *ymax* = 1, this always
spans the yrange, regardless of the ylim settings, even if you
change them, eg. with the :meth:`set_ylim` command.  That is,
the vertical extent is in axes coords: 0=bottom, 0.5=middle,
1.0=top but the *y* location is in data coordinates.

Return value is the :class:`matplotlib.patches.Polygon`
instance.

Examples:

* draw a vertical green translucent rectangle from x=1.25 to 1.55 that
  spans the yrange of the axes

    >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)

Valid kwargs are :class:`~matplotlib.patches.Polygon`
properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]  or None for default
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function
  edgecolor or ec: mpl color spec, or None for default, or 'none' for no color
  facecolor or fc: mpl color spec, or None for default, or 'none' for no color
  figure: a :class:`matplotlib.figure.Figure` instance
  fill: [True | False]
  gid: an id string
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
  label: any string
  linestyle or ls: ['solid' | 'dashed' | 'dashdot' | 'dotted']
  linewidth or lw: float or None for default
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

.. seealso::

    :meth:`axhspan`
        for example plot and source code

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
bar

call signature::

  bar(left, height, width=0.8, bottom=0,
      color=None, edgecolor=None, linewidth=None,
      yerr=None, xerr=None, ecolor=None, capsize=3,
      align='edge', orientation='vertical', log=False)

Make a bar plot with rectangles bounded by:

  *left*, *left* + *width*, *bottom*, *bottom* + *height*
        (left, right, bottom and top edges)

*left*, *height*, *width*, and *bottom* can be either scalars
or sequences

Return value is a list of
:class:`matplotlib.patches.Rectangle` instances.

Required arguments:

  ========   ===============================================
  Argument   Description
  ========   ===============================================
  *left*     the x coordinates of the left sides of the bars
  *height*   the heights of the bars
  ========   ===============================================

Optional keyword arguments:

  ===============   ==========================================
  Keyword           Description
  ===============   ==========================================
  *width*           the widths of the bars
  *bottom*          the y coordinates of the bottom edges of
                    the bars
  *color*           the colors of the bars
  *edgecolor*       the colors of the bar edges
  *linewidth*       width of bar edges; None means use default
                    linewidth; 0 means don't draw edges.
  *xerr*            if not None, will be used to generate
                    errorbars on the bar chart
  *yerr*            if not None, will be used to generate
                    errorbars on the bar chart
  *ecolor*          specifies the color of any errorbar
  *capsize*         (default 3) determines the length in
                    points of the error bar caps
  *align*           'edge' (default) | 'center'
  *orientation*     'vertical' | 'horizontal'
  *log*             [False|True] False (default) leaves the
                    orientation axis as-is; True sets it to
                    log scale
  ===============   ==========================================

For vertical bars, *align* = 'edge' aligns bars by their left
edges in left, while *align* = 'center' interprets these
values as the *x* coordinates of the bar centers. For
horizontal bars, *align* = 'edge' aligns bars by their bottom
edges in bottom, while *align* = 'center' interprets these
values as the *y* coordinates of the bar centers.

The optional arguments *color*, *edgecolor*, *linewidth*,
*xerr*, and *yerr* can be either scalars or sequences of
length equal to the number of bars.  This enables you to use
bar as the basis for stacked bar charts, or candlestick plots.

Other optional kwargs:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]  or None for default
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function
  edgecolor or ec: mpl color spec, or None for default, or 'none' for no color
  facecolor or fc: mpl color spec, or None for default, or 'none' for no color
  figure: a :class:`matplotlib.figure.Figure` instance
  fill: [True | False]
  gid: an id string
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
  label: any string
  linestyle or ls: ['solid' | 'dashed' | 'dashdot' | 'dotted']
  linewidth or lw: float or None for default
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

**Example:** A stacked bar chart.

.. plot:: mpl_examples/pylab_examples/bar_stacked.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
barh

call signature::

  barh(bottom, width, height=0.8, left=0, **kwargs)

Make a horizontal bar plot with rectangles bounded by:

  *left*, *left* + *width*, *bottom*, *bottom* + *height*
        (left, right, bottom and top edges)

*bottom*, *width*, *height*, and *left* can be either scalars
or sequences

Return value is a list of
:class:`matplotlib.patches.Rectangle` instances.

Required arguments:

  ========   ======================================================
  Argument   Description
  ========   ======================================================
  *bottom*   the vertical positions of the bottom edges of the bars
  *width*    the lengths of the bars
  ========   ======================================================

Optional keyword arguments:

  ===============   ==========================================
  Keyword           Description
  ===============   ==========================================
  *height*          the heights (thicknesses) of the bars
  *left*            the x coordinates of the left edges of the
                    bars
  *color*           the colors of the bars
  *edgecolor*       the colors of the bar edges
  *linewidth*       width of bar edges; None means use default
                    linewidth; 0 means don't draw edges.
  *xerr*            if not None, will be used to generate
                    errorbars on the bar chart
  *yerr*            if not None, will be used to generate
                    errorbars on the bar chart
  *ecolor*          specifies the color of any errorbar
  *capsize*         (default 3) determines the length in
                    points of the error bar caps
  *align*           'edge' (default) | 'center'
  *log*             [False|True] False (default) leaves the
                    horizontal axis as-is; True sets it to log
                    scale
  ===============   ==========================================

Setting *align* = 'edge' aligns bars by their bottom edges in
bottom, while *align* = 'center' interprets these values as
the *y* coordinates of the bar centers.

The optional arguments *color*, *edgecolor*, *linewidth*,
*xerr*, and *yerr* can be either scalars or sequences of
length equal to the number of bars.  This enables you to use
barh as the basis for stacked bar charts, or candlestick
plots.

other optional kwargs:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]  or None for default
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function
  edgecolor or ec: mpl color spec, or None for default, or 'none' for no color
  facecolor or fc: mpl color spec, or None for default, or 'none' for no color
  figure: a :class:`matplotlib.figure.Figure` instance
  fill: [True | False]
  gid: an id string
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
  label: any string
  linestyle or ls: ['solid' | 'dashed' | 'dashdot' | 'dotted']
  linewidth or lw: float or None for default
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
box


    Turn the axes box on or off according to *on*.

    If *on* is *None*, toggle state.

---------------------------------------------------------------------------
boxplot

call signature::

  boxplot(x, notch=0, sym='+', vert=1, whis=1.5,
          positions=None, widths=None)

Make a box and whisker plot for each column of *x* or each
vector in sequence *x*.  The box extends from the lower to
upper quartile values of the data, with a line at the median.
The whiskers extend from the box to show the range of the
data.  Flier points are those past the end of the whiskers.

- *notch* = 0 (default) produces a rectangular box plot.
- *notch* = 1 will produce a notched box plot

*sym* (default 'b+') is the default symbol for flier points.
Enter an empty string ('') if you don't want to show fliers.

- *vert* = 1 (default) makes the boxes vertical.
- *vert* = 0 makes horizontal boxes.  This seems goofy, but
  that's how Matlab did it.

*whis* (default 1.5) defines the length of the whiskers as
a function of the inner quartile range.  They extend to the
most extreme data point within ( ``whis*(75%-25%)`` ) data range.

*positions* (default 1,2,...,n) sets the horizontal positions of
the boxes. The ticks and limits are automatically set to match
the positions.

*widths* is either a scalar or a vector and sets the width of
each box. The default is 0.5, or ``0.15*(distance between extreme
positions)`` if that is smaller.

*x* is an array or a sequence of vectors.

Returns a dictionary mapping each component of the boxplot
to a list of the :class:`matplotlib.lines.Line2D`
instances created.

**Example:**

.. plot:: pyplots/boxplot_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
cla

Clear the current axes
---------------------------------------------------------------------------
clabel

call signature::

  clabel(cs, **kwargs)

adds labels to line contours in *cs*, where *cs* is a
:class:`~matplotlib.contour.ContourSet` object returned by
contour.

::

  clabel(cs, v, **kwargs)

only labels contours listed in *v*.

Optional keyword arguments:

  *fontsize*:
    See http://matplotlib.sf.net/fonts.html

  *colors*:
    - if *None*, the color of each label matches the color of
      the corresponding contour

    - if one string color, e.g. *colors* = 'r' or *colors* =
      'red', all labels will be plotted in this color

    - if a tuple of matplotlib color args (string, float, rgb, etc),
      different labels will be plotted in different colors in the order
      specified

  *inline*:
    controls whether the underlying contour is removed or
    not. Default is *True*.

  *inline_spacing*:
    space in pixels to leave on each side of label when
    placing inline.  Defaults to 5.  This spacing will be
    exact for labels at locations where the contour is
    straight, less so for labels on curved contours.

  *fmt*:
    a format string for the label. Default is '%1.3f'
    Alternatively, this can be a dictionary matching contour
    levels with arbitrary strings to use for each contour level
    (i.e., fmt[level]=string)

  *manual*:
    if *True*, contour labels will be placed manually using
    mouse clicks.  Click the first button near a contour to
    add a label, click the second button (or potentially both
    mouse buttons at once) to finish adding labels.  The third
    button can be used to remove the last label added, but
    only if labels are not inline.  Alternatively, the keyboard
    can be used to select label locations (enter to end label
    placement, delete or backspace act like the third mouse button,
    and any other key will select a label location).

  *rightside_up*:
    if *True* (default), label rotations will always be plus
    or minus 90 degrees from level.

.. plot:: mpl_examples/pylab_examples/contour_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
clf


    Clear the current figure

---------------------------------------------------------------------------
clim


    Set the color limits of the current image

    To apply clim to all axes images do::

      clim(0, 0.5)

    If either *vmin* or *vmax* is None, the image min/max respectively
    will be used for color scaling.

    If you want to set the clim of multiple images,
    use, for example::

      for im in gca().get_images():
          im.set_clim(0, 0.05)


---------------------------------------------------------------------------
close


    Close a figure window

    ``close()`` by itself closes the current figure

    ``close(num)`` closes figure number *num*

    ``close(h)`` where *h* is a :class:`Figure` instance, closes that figure

    ``close('all')`` closes all the figure windows

---------------------------------------------------------------------------
cohere

call signature::

  cohere(x, y, NFFT=256, Fs=2, Fc=0, detrend = mlab.detrend_none,
         window = mlab.window_hanning, noverlap=0, pad_to=None,
         sides='default', scale_by_freq=None, **kwargs)

cohere the coherence between *x* and *y*.  Coherence is the normalized
cross spectral density:

.. math::

  C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}

Keyword arguments:

  *NFFT*: integer
      The number of data points used in each block for the FFT.
      Must be even; a power 2 is most efficient.  The default value is 256.

  *Fs*: scalar
      The sampling frequency (samples per time unit).  It is used
      to calculate the Fourier frequencies, freqs, in cycles per time
      unit. The default value is 2.

  *detrend*: callable
      The function applied to each segment before fft-ing,
      designed to remove the mean or linear trend.  Unlike in
      matlab, where the *detrend* parameter is a vector, in
      matplotlib is it a function.  The :mod:`~matplotlib.pylab`
      module defines :func:`~matplotlib.pylab.detrend_none`,
      :func:`~matplotlib.pylab.detrend_mean`, and
      :func:`~matplotlib.pylab.detrend_linear`, but you can use
      a custom function as well.

  *window*: callable or ndarray
      A function or a vector of length *NFFT*. To create window
      vectors see :func:`window_hanning`, :func:`window_none`,
      :func:`numpy.blackman`, :func:`numpy.hamming`,
      :func:`numpy.bartlett`, :func:`scipy.signal`,
      :func:`scipy.signal.get_window`, etc. The default is
      :func:`window_hanning`.  If a function is passed as the
      argument, it must take a data segment as an argument and
      return the windowed version of the segment.

  *noverlap*: integer
      The number of points of overlap between blocks.  The default value
      is 0 (no overlap).

  *pad_to*: integer
      The number of points to which the data segment is padded when
      performing the FFT.  This can be different from *NFFT*, which
      specifies the number of data points used.  While not increasing
      the actual resolution of the psd (the minimum distance between
      resolvable peaks), this can give more points in the plot,
      allowing for more detail. This corresponds to the *n* parameter
      in the call to fft(). The default is None, which sets *pad_to*
      equal to *NFFT*

  *sides*: [ 'default' | 'onesided' | 'twosided' ]
      Specifies which sides of the PSD to return.  Default gives the
      default behavior, which returns one-sided for real data and both
      for complex data.  'onesided' forces the return of a one-sided PSD,
      while 'twosided' forces two-sided.

  *scale_by_freq*: boolean
      Specifies whether the resulting density values should be scaled
      by the scaling frequency, which gives density in units of Hz^-1.
      This allows for integration over the returned frequency values.
      The default is True for MatLab compatibility.

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

The return value is a tuple (*Cxy*, *f*), where *f* are the
frequencies of the coherence vector.

kwargs are applied to the lines.

References:

  * Bendat & Piersol -- Random Data: Analysis and Measurement
    Procedures, John Wiley & Sons (1986)

kwargs control the :class:`~matplotlib.lines.Line2D`
properties of the coherence plot:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/cohere_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
colorbar



Add a colorbar to a plot.

Function signatures for the :mod:`~matplotlib.pyplot` interface; all
but the first are also method signatures for the
:meth:`~matplotlib.figure.Figure.colorbar` method::

  colorbar(**kwargs)
  colorbar(mappable, **kwargs)
  colorbar(mappable, cax=cax, **kwargs)
  colorbar(mappable, ax=ax, **kwargs)

arguments:

  *mappable*
    the :class:`~matplotlib.image.Image`,
    :class:`~matplotlib.contour.ContourSet`, etc. to
    which the colorbar applies; this argument is mandatory for the
    :meth:`~matplotlib.figure.Figure.colorbar` method but optional for the
    :func:`~matplotlib.pyplot.colorbar` function, which sets the
    default to the current image.

keyword arguments:

  *cax*
    None | axes object into which the colorbar will be drawn
  *ax*
    None | parent axes object from which space for a new
    colorbar axes will be stolen


Additional keyword arguments are of two kinds:

  axes properties:


    ============= ====================================================
    Property      Description
    ============= ====================================================
    *orientation* vertical or horizontal
    *fraction*    0.15; fraction of original axes to use for colorbar
    *pad*         0.05 if vertical, 0.15 if horizontal; fraction
                  of original axes between colorbar and new image axes
    *shrink*      1.0; fraction by which to shrink the colorbar
    *aspect*      20; ratio of long to short dimensions
    ============= ====================================================


  colorbar properties:


    ===========   ====================================================
    Property      Description
    ===========   ====================================================
    *extend*      [ 'neither' | 'both' | 'min' | 'max' ]
                  If not 'neither', make pointed end(s) for out-of-
                  range values.  These are set for a given colormap
                  using the colormap set_under and set_over methods.
    *spacing*     [ 'uniform' | 'proportional' ]
                  Uniform spacing gives each discrete color the same
                  space; proportional makes the space proportional to
                  the data interval.
    *ticks*       [ None | list of ticks | Locator object ]
                  If None, ticks are determined automatically from the
                  input.
    *format*      [ None | format string | Formatter object ]
                  If None, the
                  :class:`~matplotlib.ticker.ScalarFormatter` is used.
                  If a format string is given, e.g. '%.3f', that is
                  used. An alternative
                  :class:`~matplotlib.ticker.Formatter` object may be
                  given instead.
    *drawedges*   [ False | True ] If true, draw lines at color
                  boundaries.
    ===========   ====================================================

    The following will probably be useful only in the context of
    indexed colors (that is, when the mappable has norm=NoNorm()),
    or other unusual circumstances.

    ============   ===================================================
    Property       Description
    ============   ===================================================
    *boundaries*   None or a sequence
    *values*       None or a sequence which must be of length 1 less
                   than the sequence of *boundaries*. For each region
                   delimited by adjacent entries in *boundaries*, the
                   color mapped to the corresponding value in values
                   will be used.
    ============   ===================================================



If *mappable* is a :class:`~matplotlib.contours.ContourSet`, its *extend*
kwarg is included automatically.

Note that the *shrink* kwarg provides a simple way to keep a vertical
colorbar, for example, from being taller than the axes of the mappable
to which the colorbar is attached; but it is a manual method requiring
some trial and error. If the colorbar is too tall (or a horizontal
colorbar is too wide) use a smaller value of *shrink*.

For more precise control, you can manually specify the positions of
the axes objects in which the mappable and the colorbar are drawn.  In
this case, do not use any of the axes properties kwargs.

returns:
    :class:`~matplotlib.colorbar.Colorbar` instance; see also its base class,
    :class:`~matplotlib.colorbar.ColorbarBase`.  Call the
    :meth:`~matplotlib.colorbar.ColorbarBase.set_label` method
    to label the colorbar.


---------------------------------------------------------------------------
contour

:func:`~matplotlib.pyplot.contour` and
:func:`~matplotlib.pyplot.contourf` draw contour lines and
filled contours, respectively.  Except as noted, function
signatures and return values are the same for both versions.

:func:`~matplotlib.pyplot.contourf` differs from the Matlab
(TM) version in that it does not draw the polygon edges,
because the contouring engine yields simply connected regions
with branch cuts.  To draw the edges, add line contours with
calls to :func:`~matplotlib.pyplot.contour`.


call signatures::

  contour(Z)

make a contour plot of an array *Z*. The level values are chosen
automatically.

::

  contour(X,Y,Z)

*X*, *Y* specify the (*x*, *y*) coordinates of the surface

::

  contour(Z,N)
  contour(X,Y,Z,N)

contour *N* automatically-chosen levels.

::

  contour(Z,V)
  contour(X,Y,Z,V)

draw contour lines at the values specified in sequence *V*

::

  contourf(..., V)

fill the (len(*V*)-1) regions between the values in *V*

::

  contour(Z, **kwargs)

Use keyword args to control colors, linewidth, origin, cmap ... see
below for more details.

*X*, *Y*, and *Z* must be arrays with the same dimensions.

*Z* may be a masked array, but filled contouring may not
handle internal masked regions correctly.

``C = contour(...)`` returns a
:class:`~matplotlib.contour.ContourSet` object.

Optional keyword arguments:

  *colors*: [ None | string | (mpl_colors) ]
    If *None*, the colormap specified by cmap will be used.

    If a string, like 'r' or 'red', all levels will be plotted in this
    color.

    If a tuple of matplotlib color args (string, float, rgb, etc),
    different levels will be plotted in different colors in the order
    specified.

  *alpha*: float
    The alpha blending value

  *cmap*: [ None | Colormap ]
    A cm :class:`~matplotlib.cm.Colormap` instance or
    *None*. If *cmap* is *None* and *colors* is *None*, a
    default Colormap is used.

  *norm*: [ None | Normalize ]
    A :class:`matplotlib.colors.Normalize` instance for
    scaling data values to colors. If *norm* is *None* and
    *colors* is *None*, the default linear scaling is used.

  *origin*: [ None | 'upper' | 'lower' | 'image' ]
    If *None*, the first value of *Z* will correspond to the
    lower left corner, location (0,0). If 'image', the rc
    value for ``image.origin`` will be used.

    This keyword is not active if *X* and *Y* are specified in
    the call to contour.

  *extent*: [ None | (x0,x1,y0,y1) ]

    If *origin* is not *None*, then *extent* is interpreted as
    in :func:`matplotlib.pyplot.imshow`: it gives the outer
    pixel boundaries. In this case, the position of Z[0,0]
    is the center of the pixel, not a corner. If *origin* is
    *None*, then (*x0*, *y0*) is the position of Z[0,0], and
    (*x1*, *y1*) is the position of Z[-1,-1].

    This keyword is not active if *X* and *Y* are specified in
    the call to contour.

  *locator*: [ None | ticker.Locator subclass ]
    If *locator* is None, the default
    :class:`~matplotlib.ticker.MaxNLocator` is used. The
    locator is used to determine the contour levels if they
    are not given explicitly via the *V* argument.

  *extend*: [ 'neither' | 'both' | 'min' | 'max' ]
    Unless this is 'neither', contour levels are automatically
    added to one or both ends of the range so that all data
    are included. These added ranges are then mapped to the
    special colormap values which default to the ends of the
    colormap range, but can be set via
    :meth:`matplotlib.cm.Colormap.set_under` and
    :meth:`matplotlib.cm.Colormap.set_over` methods.

contour-only keyword arguments:

  *linewidths*: [ None | number | tuple of numbers ]
    If *linewidths* is *None*, the default width in
    ``lines.linewidth`` in ``matplotlibrc`` is used.

    If a number, all levels will be plotted with this linewidth.

    If a tuple, different levels will be plotted with different
    linewidths in the order specified

  *linestyles*: [None | 'solid' | 'dashed' | 'dashdot' | 'dotted' ]
    If *linestyles* is *None*, the 'solid' is used.

    *linestyles* can also be an iterable of the above strings
    specifying a set of linestyles to be used. If this
    iterable is shorter than the number of contour levels
    it will be repeated as necessary.

    If contour is using a monochrome colormap and the contour
    level is less than 0, then the linestyle specified
    in ``contour.negative_linestyle`` in ``matplotlibrc``
    will be used.

contourf-only keyword arguments:

  *antialiased*: [ True | False ]
    enable antialiasing

  *nchunk*: [ 0 | integer ]
    If 0, no subdivision of the domain. Specify a positive integer to
    divide the domain into subdomains of roughly *nchunk* by *nchunk*
    points. This may never actually be advantageous, so this option may
    be removed. Chunking introduces artifacts at the chunk boundaries
    unless *antialiased* is *False*.

**Example:**

.. plot:: mpl_examples/pylab_examples/contour_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
contourf

:func:`~matplotlib.pyplot.contour` and
:func:`~matplotlib.pyplot.contourf` draw contour lines and
filled contours, respectively.  Except as noted, function
signatures and return values are the same for both versions.

:func:`~matplotlib.pyplot.contourf` differs from the Matlab
(TM) version in that it does not draw the polygon edges,
because the contouring engine yields simply connected regions
with branch cuts.  To draw the edges, add line contours with
calls to :func:`~matplotlib.pyplot.contour`.


call signatures::

  contour(Z)

make a contour plot of an array *Z*. The level values are chosen
automatically.

::

  contour(X,Y,Z)

*X*, *Y* specify the (*x*, *y*) coordinates of the surface

::

  contour(Z,N)
  contour(X,Y,Z,N)

contour *N* automatically-chosen levels.

::

  contour(Z,V)
  contour(X,Y,Z,V)

draw contour lines at the values specified in sequence *V*

::

  contourf(..., V)

fill the (len(*V*)-1) regions between the values in *V*

::

  contour(Z, **kwargs)

Use keyword args to control colors, linewidth, origin, cmap ... see
below for more details.

*X*, *Y*, and *Z* must be arrays with the same dimensions.

*Z* may be a masked array, but filled contouring may not
handle internal masked regions correctly.

``C = contour(...)`` returns a
:class:`~matplotlib.contour.ContourSet` object.

Optional keyword arguments:

  *colors*: [ None | string | (mpl_colors) ]
    If *None*, the colormap specified by cmap will be used.

    If a string, like 'r' or 'red', all levels will be plotted in this
    color.

    If a tuple of matplotlib color args (string, float, rgb, etc),
    different levels will be plotted in different colors in the order
    specified.

  *alpha*: float
    The alpha blending value

  *cmap*: [ None | Colormap ]
    A cm :class:`~matplotlib.cm.Colormap` instance or
    *None*. If *cmap* is *None* and *colors* is *None*, a
    default Colormap is used.

  *norm*: [ None | Normalize ]
    A :class:`matplotlib.colors.Normalize` instance for
    scaling data values to colors. If *norm* is *None* and
    *colors* is *None*, the default linear scaling is used.

  *origin*: [ None | 'upper' | 'lower' | 'image' ]
    If *None*, the first value of *Z* will correspond to the
    lower left corner, location (0,0). If 'image', the rc
    value for ``image.origin`` will be used.

    This keyword is not active if *X* and *Y* are specified in
    the call to contour.

  *extent*: [ None | (x0,x1,y0,y1) ]

    If *origin* is not *None*, then *extent* is interpreted as
    in :func:`matplotlib.pyplot.imshow`: it gives the outer
    pixel boundaries. In this case, the position of Z[0,0]
    is the center of the pixel, not a corner. If *origin* is
    *None*, then (*x0*, *y0*) is the position of Z[0,0], and
    (*x1*, *y1*) is the position of Z[-1,-1].

    This keyword is not active if *X* and *Y* are specified in
    the call to contour.

  *locator*: [ None | ticker.Locator subclass ]
    If *locator* is None, the default
    :class:`~matplotlib.ticker.MaxNLocator` is used. The
    locator is used to determine the contour levels if they
    are not given explicitly via the *V* argument.

  *extend*: [ 'neither' | 'both' | 'min' | 'max' ]
    Unless this is 'neither', contour levels are automatically
    added to one or both ends of the range so that all data
    are included. These added ranges are then mapped to the
    special colormap values which default to the ends of the
    colormap range, but can be set via
    :meth:`matplotlib.cm.Colormap.set_under` and
    :meth:`matplotlib.cm.Colormap.set_over` methods.

contour-only keyword arguments:

  *linewidths*: [ None | number | tuple of numbers ]
    If *linewidths* is *None*, the default width in
    ``lines.linewidth`` in ``matplotlibrc`` is used.

    If a number, all levels will be plotted with this linewidth.

    If a tuple, different levels will be plotted with different
    linewidths in the order specified

  *linestyles*: [None | 'solid' | 'dashed' | 'dashdot' | 'dotted' ]
    If *linestyles* is *None*, the 'solid' is used.

    *linestyles* can also be an iterable of the above strings
    specifying a set of linestyles to be used. If this
    iterable is shorter than the number of contour levels
    it will be repeated as necessary.

    If contour is using a monochrome colormap and the contour
    level is less than 0, then the linestyle specified
    in ``contour.negative_linestyle`` in ``matplotlibrc``
    will be used.

contourf-only keyword arguments:

  *antialiased*: [ True | False ]
    enable antialiasing

  *nchunk*: [ 0 | integer ]
    If 0, no subdivision of the domain. Specify a positive integer to
    divide the domain into subdomains of roughly *nchunk* by *nchunk*
    points. This may never actually be advantageous, so this option may
    be removed. Chunking introduces artifacts at the chunk boundaries
    unless *antialiased* is *False*.

**Example:**

.. plot:: mpl_examples/pylab_examples/contour_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
csd

call signature::

  csd(x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
      window=mlab.window_hanning, noverlap=0, pad_to=None,
      sides='default', scale_by_freq=None, **kwargs)

The cross spectral density :math:`P_{xy}` by Welch's average
periodogram method.  The vectors *x* and *y* are divided into
*NFFT* length segments.  Each segment is detrended by function
*detrend* and windowed by function *window*.  The product of
the direct FFTs of *x* and *y* are averaged over each segment
to compute :math:`P_{xy}`, with a scaling to correct for power
loss due to windowing.

Returns the tuple (*Pxy*, *freqs*).  *P* is the cross spectrum
(complex valued), and :math:`10\log_{10}|P_{xy}|` is
plotted.

Keyword arguments:

  *NFFT*: integer
      The number of data points used in each block for the FFT.
      Must be even; a power 2 is most efficient.  The default value is 256.

  *Fs*: scalar
      The sampling frequency (samples per time unit).  It is used
      to calculate the Fourier frequencies, freqs, in cycles per time
      unit. The default value is 2.

  *detrend*: callable
      The function applied to each segment before fft-ing,
      designed to remove the mean or linear trend.  Unlike in
      matlab, where the *detrend* parameter is a vector, in
      matplotlib is it a function.  The :mod:`~matplotlib.pylab`
      module defines :func:`~matplotlib.pylab.detrend_none`,
      :func:`~matplotlib.pylab.detrend_mean`, and
      :func:`~matplotlib.pylab.detrend_linear`, but you can use
      a custom function as well.

  *window*: callable or ndarray
      A function or a vector of length *NFFT*. To create window
      vectors see :func:`window_hanning`, :func:`window_none`,
      :func:`numpy.blackman`, :func:`numpy.hamming`,
      :func:`numpy.bartlett`, :func:`scipy.signal`,
      :func:`scipy.signal.get_window`, etc. The default is
      :func:`window_hanning`.  If a function is passed as the
      argument, it must take a data segment as an argument and
      return the windowed version of the segment.

  *noverlap*: integer
      The number of points of overlap between blocks.  The default value
      is 0 (no overlap).

  *pad_to*: integer
      The number of points to which the data segment is padded when
      performing the FFT.  This can be different from *NFFT*, which
      specifies the number of data points used.  While not increasing
      the actual resolution of the psd (the minimum distance between
      resolvable peaks), this can give more points in the plot,
      allowing for more detail. This corresponds to the *n* parameter
      in the call to fft(). The default is None, which sets *pad_to*
      equal to *NFFT*

  *sides*: [ 'default' | 'onesided' | 'twosided' ]
      Specifies which sides of the PSD to return.  Default gives the
      default behavior, which returns one-sided for real data and both
      for complex data.  'onesided' forces the return of a one-sided PSD,
      while 'twosided' forces two-sided.

  *scale_by_freq*: boolean
      Specifies whether the resulting density values should be scaled
      by the scaling frequency, which gives density in units of Hz^-1.
      This allows for integration over the returned frequency values.
      The default is True for MatLab compatibility.

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

References:
  Bendat & Piersol -- Random Data: Analysis and Measurement
  Procedures, John Wiley & Sons (1986)

kwargs control the Line2D properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/csd_demo.py

.. seealso:

    :meth:`psd`
        For a description of the optional parameters.

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
delaxes


    ``delaxes(ax)``: remove *ax* from the current figure.  If *ax*
    doesn't exist, an error will be raised.

    ``delaxes()``: delete the current axes

---------------------------------------------------------------------------
draw

redraw the current figure
---------------------------------------------------------------------------
errorbar

call signature::

  errorbar(x, y, yerr=None, xerr=None,
           fmt='-', ecolor=None, elinewidth=None, capsize=3,
           barsabove=False, lolims=False, uplims=False,
           xlolims=False, xuplims=False)

Plot *x* versus *y* with error deltas in *yerr* and *xerr*.
Vertical errorbars are plotted if *yerr* is not *None*.
Horizontal errorbars are plotted if *xerr* is not *None*.

*x*, *y*, *xerr*, and *yerr* can all be scalars, which plots a
single error bar at *x*, *y*.

Optional keyword arguments:

  *xerr*/*yerr*: [ scalar | N, Nx1, or 2xN array-like ]
    If a scalar number, len(N) array-like object, or an Nx1 array-like
    object, errorbars are drawn +/- value.

    If a rank-1, 2xN numpy array, errorbars are drawn at -row1 and
    +row2

  *fmt*: '-'
    The plot format symbol for *y*. If *fmt* is *None*, just plot the
    errorbars with no line symbols.  This can be useful for creating a
    bar plot with errorbars.

  *ecolor*: [ None | mpl color ]
    a matplotlib color arg which gives the color the errorbar lines; if
    *None*, use the marker color.

  *elinewidth*: scalar
    the linewidth of the errorbar lines. If *None*, use the linewidth.

  *capsize*: scalar
    the size of the error bar caps in points

  *barsabove*: [ True | False ]
    if *True*, will plot the errorbars above the plot
    symbols. Default is below.

  *lolims*/*uplims*/*xlolims*/*xuplims*: [ False | True ]
    These arguments can be used to indicate that a value gives
    only upper/lower limits. In that case a caret symbol is
    used to indicate this. lims-arguments may be of the same
    type as *xerr* and *yerr*.

All other keyword arguments are passed on to the plot command for the
markers, so you can add additional key=value pairs to control the
errorbar markers.  For example, this code makes big red squares with
thick green edges::

  x,y,yerr = rand(3,10)
  errorbar(x, y, yerr, marker='s',
           mfc='red', mec='green', ms=20, mew=4)

where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
property names, *markerfacecolor*, *markeredgecolor*, *markersize*
and *markeredgewith*.

valid kwargs for the marker properties are

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

Return value is a length 3 tuple.  The first element is the
:class:`~matplotlib.lines.Line2D` instance for the *y* symbol
lines.  The second element is a list of error bar cap lines,
the third element is a list of
:class:`~matplotlib.collections.LineCollection` instances for
the horizontal and vertical error ranges.

**Example:**

.. plot:: mpl_examples/pylab_examples/errorbar_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
figimage

call signatures::

  figimage(X, **kwargs)

adds a non-resampled array *X* to the figure.

::

  figimage(X, xo, yo)

with pixel offsets *xo*, *yo*,

*X* must be a float array:

* If *X* is MxN, assume luminance (grayscale)
* If *X* is MxNx3, assume RGB
* If *X* is MxNx4, assume RGBA

Optional keyword arguments:

  =========   ==========================================================
  Keyword     Description
  =========   ==========================================================
  xo or yo    An integer, the *x* and *y* image offset in pixels
  cmap        a :class:`matplotlib.cm.ColorMap` instance, eg cm.jet.
              If None, default to the rc ``image.cmap`` value
  norm        a :class:`matplotlib.colors.Normalize` instance. The
              default is normalization().  This scales luminance -> 0-1
  vmin|vmax   are used to scale a luminance image to 0-1.  If either is
              None, the min and max of the luminance values will be
              used.  Note if you pass a norm instance, the settings for
              *vmin* and *vmax* will be ignored.
  alpha       the alpha blending value, default is 1.0
  origin      [ 'upper' | 'lower' ] Indicates where the [0,0] index of
              the array is in the upper left or lower left corner of
              the axes. Defaults to the rc image.origin value
  =========   ==========================================================

figimage complements the axes image
(:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled
to fit the current axes.  If you want a resampled image to
fill the entire figure, you can define an
:class:`~matplotlib.axes.Axes` with size [0,1,0,1].

An :class:`matplotlib.image.FigureImage` instance is returned.

.. plot:: mpl_examples/pylab_examples/figimage_demo.py
Addition kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
figlegend


    Place a legend in the figure.

    *labels*
      a sequence of strings

    *handles*
      a sequence of :class:`~matplotlib.lines.Line2D` or
      :class:`~matplotlib.patches.Patch` instances

    *loc*
      can be a string or an integer specifying the legend
      location

    A :class:`matplotlib.legend.Legend` instance is returned.

    Example::

      figlegend( (line1, line2, line3),
                 ('label1', 'label2', 'label3'),
                 'upper right' )

    .. seealso::

       :func:`~matplotlib.pyplot.legend`


---------------------------------------------------------------------------
figtext

Call signature::

  figtext(x, y, s, fontdict=None, **kwargs)

Add text to figure at location *x*, *y* (relative 0-1
coords). See :func:`~matplotlib.pyplot.text` for the meaning
of the other arguments.

kwargs control the :class:`~matplotlib.text.Text` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  backgroundcolor: any matplotlib color
  bbox: rectangle prop dict
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: any matplotlib color
  contains: a callable function
  family or fontfamily or fontname or name: [ FONTNAME | 'serif' | 'sans-serif' | 'cursive' | 'fantasy' | 'monospace' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fontproperties or font_properties: a :class:`matplotlib.font_manager.FontProperties` instance
  gid: an id string
  horizontalalignment or ha: [ 'center' | 'right' | 'left' ]
  label: any string
  linespacing: float (multiple of font size)
  lod: [True | False]
  multialignment: ['left' | 'right' | 'center' ]
  picker: [None|float|boolean|callable]
  position: (x,y)
  rasterized: [True | False | None]
  rotation: [ angle in degrees | 'vertical' | 'horizontal' ]
  rotation_mode: unknown
  size or fontsize: [ size in points | 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' ]
  snap: unknown
  stretch or fontstretch: [ a numeric value in range 0-1000 | 'ultra-condensed' | 'extra-condensed' | 'condensed' | 'semi-condensed' | 'normal' | 'semi-expanded' | 'expanded' | 'extra-expanded' | 'ultra-expanded' ]
  style or fontstyle: [ 'normal' | 'italic' | 'oblique']
  text: string or anything printable with '%s' conversion.
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  variant or fontvariant: [ 'normal' | 'small-caps' ]
  verticalalignment or va or ma: [ 'center' | 'top' | 'bottom' | 'baseline' ]
  visible: [True | False]
  weight or fontweight: [ a numeric value in range 0-1000 | 'ultralight' | 'light' | 'normal' | 'regular' | 'book' | 'medium' | 'roman' | 'semibold' | 'demibold' | 'demi' | 'bold' | 'heavy' | 'extra bold' | 'black' ]
  x: float
  y: float
  zorder: any number
---------------------------------------------------------------------------
figure


    call signature::

      figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')


    Create a new figure and return a :class:`matplotlib.figure.Figure`
    instance.  If *num* = *None*, the figure number will be incremented and
    a new figure will be created.  The returned figure objects have a
    *number* attribute holding this number.

    If *num* is an integer, and ``figure(num)`` already exists, make it
    active and return a reference to it.  If ``figure(num)`` does not exist
    it will be created.  Numbering starts at 1, matlab style::

      figure(1)

    If you are creating many figures, make sure you explicitly call "close"
    on the figures you are not using, because this will enable pylab
    to properly clean up the memory.

    Optional keyword arguments:

      =========   =======================================================
      Keyword     Description
      =========   =======================================================
      figsize     width x height in inches; defaults to rc figure.figsize
      dpi         resolution; defaults to rc figure.dpi
      facecolor   the background color; defaults to rc figure.facecolor
      edgecolor   the border color; defaults to rc figure.edgecolor
      =========   =======================================================

    rcParams defines the default values, which can be modified in the
    matplotlibrc file

    *FigureClass* is a :class:`~matplotlib.figure.Figure` or derived
    class that will be passed on to :meth:`new_figure_manager` in the
    backends which allows you to hook custom Figure classes into the
    pylab interface.  Additional kwargs will be passed on to your
    figure init function.

---------------------------------------------------------------------------
fill

call signature::

  fill(*args, **kwargs)

Plot filled polygons.  *args* is a variable length argument,
allowing for multiple *x*, *y* pairs with an optional color
format string; see :func:`~matplotlib.pyplot.plot` for details
on the argument parsing.  For example, to plot a polygon with
vertices at *x*, *y* in blue.::

  ax.fill(x,y, 'b' )

An arbitrary number of *x*, *y*, *color* groups can be specified::

  ax.fill(x1, y1, 'g', x2, y2, 'r')

Return value is a list of :class:`~matplotlib.patches.Patch`
instances that were added.

The same color strings that :func:`~matplotlib.pyplot.plot`
supports are supported by the fill format string.

If you would like to fill below a curve, eg. shade a region
between 0 and *y* along *x*, use :meth:`fill_between`

The *closed* kwarg will close the polygon when *True* (default).

kwargs control the Polygon properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]  or None for default
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function
  edgecolor or ec: mpl color spec, or None for default, or 'none' for no color
  facecolor or fc: mpl color spec, or None for default, or 'none' for no color
  figure: a :class:`matplotlib.figure.Figure` instance
  fill: [True | False]
  gid: an id string
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
  label: any string
  linestyle or ls: ['solid' | 'dashed' | 'dashdot' | 'dotted']
  linewidth or lw: float or None for default
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/fill_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
gca


    Return the current axis instance.  This can be used to control
    axis properties either using set or the
    :class:`~matplotlib.axes.Axes` methods, for example, setting the
    xaxis range::

      plot(t,s)
      set(gca(), 'xlim', [0,10])

    or::

      plot(t,s)
      a = gca()
      a.set_xlim([0,10])


---------------------------------------------------------------------------
gcf

Return a reference to the current figure.
---------------------------------------------------------------------------
gci


    Get the current :class:`~matplotlib.cm.ScalarMappable` instance
    (image or patch collection), or *None* if no images or patch
    collections have been defined.  The commands
    :func:`~matplotlib.pyplot.imshow` and
    :func:`~matplotlib.pyplot.figimage` create
    :class:`~matplotlib.image.Image` instances, and the commands
    :func:`~matplotlib.pyplot.pcolor` and
    :func:`~matplotlib.pyplot.scatter` create
    :class:`~matplotlib.collections.Collection` instances.

---------------------------------------------------------------------------
getp


    Return the value of handle property.  property is an optional string
    for the property you want to return

    Example usage::

        getp(o)  # get all the object properties
        getp(o, 'linestyle')  # get the linestyle property

    *o* is a :class:`Artist` instance, eg
    :class:`~matplotllib.lines.Line2D` or an instance of a
    :class:`~matplotlib.axes.Axes` or :class:`matplotlib.text.Text`.
    If the *property* is 'somename', this function returns

      o.get_somename()

    :func:`getp` can be used to query all the gettable properties with
    ``getp(o)``. Many properties have aliases for shorter typing, e.g.
    'lw' is an alias for 'linewidth'.  In the output, aliases and full
    property names will be listed as:

      property or alias = value

    e.g.:

      linewidth or lw = 2

---------------------------------------------------------------------------
grid

call signature::

  grid(self, b=None, **kwargs)

Set the axes grids on or off; *b* is a boolean

If *b* is *None* and ``len(kwargs)==0``, toggle the grid state.  If
*kwargs* are supplied, it is assumed that you want a grid and *b*
is thus set to *True*

*kawrgs* are used to set the grid line properties, eg::

  ax.grid(color='r', linestyle='-', linewidth=2)

Valid :class:`~matplotlib.lines.Line2D` kwargs are

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number
---------------------------------------------------------------------------
hist

call signature::

  hist(x, bins=10, range=None, normed=False, cumulative=False,
       bottom=None, histtype='bar', align='mid',
       orientation='vertical', rwidth=None, log=False, **kwargs)

Compute and draw the histogram of *x*. The return value is a
tuple (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*,
[*patches0*, *patches1*,...]) if the input contains multiple
data.

Keyword arguments:

  *bins*:
    Either an integer number of bins or a sequence giving the
    bins.  *x* are the data to be binned. *x* can be an array,
    a 2D array with multiple data in its columns, or a list of
    arrays with data of different length.  Note, if *bins*
    is an integer input argument=numbins, *bins* + 1 bin edges
    will be returned, compatible with the semantics of
    :func:`numpy.histogram` with the *new* = True argument.
    Unequally spaced bins are supported if *bins* is a sequence.

  *range*:
    The lower and upper range of the bins. Lower and upper outliers
    are ignored. If not provided, *range* is (x.min(), x.max()).
    Range has no effect if *bins* is a sequence.

    If *bins* is a sequence or *range* is specified, autoscaling is
    set off (*autoscale_on* is set to *False*) and the xaxis limits
    are set to encompass the full specified bin range.

  *normed*:
    If *True*, the first element of the return tuple will
    be the counts normalized to form a probability density, i.e.,
    ``n/(len(x)*dbin)``.  In a probability density, the integral of
    the histogram should be 1; you can verify that with a
    trapezoidal integration of the probability density function::

      pdf, bins, patches = ax.hist(...)
      print np.sum(pdf * np.diff(bins))

  *weights*
    An array of weights, of the same shape as *x*.  Each value in
    *x* only contributes its associated weight towards the bin
    count (instead of 1).  If *normed* is True, the weights are
    normalized, so that the integral of the density over the range
    remains 1.

  *cumulative*:
    If *True*, then a histogram is computed where each bin
    gives the counts in that bin plus all bins for smaller values.
    The last bin gives the total number of datapoints.  If *normed*
    is also *True* then the histogram is normalized such that the
    last bin equals 1. If *cumulative* evaluates to less than 0
    (e.g. -1), the direction of accumulation is reversed.  In this
    case, if *normed* is also *True*, then the histogram is normalized
    such that the first bin equals 1.

  *histtype*: [ 'bar' | 'barstacked' | 'step' | 'stepfilled' ]
    The type of histogram to draw.

      - 'bar' is a traditional bar-type histogram.  If multiple data
        are given the bars are aranged side by side.

      - 'barstacked' is a bar-type histogram where multiple
        data are stacked on top of each other.

      - 'step' generates a lineplot that is by default
        unfilled.

      - 'stepfilled' generates a lineplot that is by default
        filled.

  *align*: ['left' | 'mid' | 'right' ]
    Controls how the histogram is plotted.

      - 'left': bars are centered on the left bin edges.

      - 'mid': bars are centered between the bin edges.

      - 'right': bars are centered on the right bin edges.

  *orientation*: [ 'horizontal' | 'vertical' ]
    If 'horizontal', :func:`~matplotlib.pyplot.barh` will be
    used for bar-type histograms and the *bottom* kwarg will be
    the left edges.

  *rwidth*:
    The relative width of the bars as a fraction of the bin
    width.  If *None*, automatically compute the width. Ignored
    if *histtype* = 'step' or 'stepfilled'.

  *log*:
    If *True*, the histogram axis will be set to a log scale.
    If *log* is *True* and *x* is a 1D array, empty bins will
    be filtered out and only the non-empty (*n*, *bins*,
    *patches*) will be returned.

kwargs are used to update the properties of the hist
:class:`~matplotlib.patches.Rectangle` instances:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]  or None for default
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: matplotlib color arg or sequence of rgba tuples
  contains: a callable function
  edgecolor or ec: mpl color spec, or None for default, or 'none' for no color
  facecolor or fc: mpl color spec, or None for default, or 'none' for no color
  figure: a :class:`matplotlib.figure.Figure` instance
  fill: [True | False]
  gid: an id string
  hatch: [ '/' | '\\' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*' ]
  label: any string
  linestyle or ls: ['solid' | 'dashed' | 'dashdot' | 'dotted']
  linewidth or lw: float or None for default
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

You can use labels for your histogram, and only the first
:class:`~matplotlib.patches.Rectangle` gets the label (the
others get the magic string '_nolegend_'.  This will make the
histograms work in the intuitive way for bar charts::

    ax.hist(10+2*np.random.randn(1000), label='men')
    ax.hist(12+3*np.random.randn(1000), label='women', alpha=0.5)
    ax.legend()

label can also be a sequence of strings. If multiple data is
provided in *x*, the labels are asigned sequentially to the
histograms.

**Example:**

.. plot:: mpl_examples/pylab_examples/histogram_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
hold


    Set the hold state.  If *b* is None (default), toggle the
    hold state, else set the hold state to boolean value *b*::

      hold()      # toggle hold
      hold(True)  # hold is on
      hold(False) # hold is off

    When *hold* is *True*, subsequent plot commands will be added to
    the current axes.  When *hold* is *False*, the current axes and
    figure will be cleared on the next plot command.

---------------------------------------------------------------------------
imread

Return image file in *fname* as :class:`numpy.array`.

Return value is a :class:`numpy.array`.  For grayscale images, the
return array is MxN.  For RGB images, the return value is MxNx3.
For RGBA images the return value is MxNx4.

matplotlib can only read PNGs natively, but if `PIL
<http://www.pythonware.com/products/pil/>`_ is installed, it will
use it to load the image and return an array (if possible) which
can be used with :func:`~matplotlib.pyplot.imshow`.
---------------------------------------------------------------------------
imshow

call signature::

  imshow(X, cmap=None, norm=None, aspect=None, interpolation=None,
         alpha=1.0, vmin=None, vmax=None, origin=None, extent=None,
         **kwargs)

Display the image in *X* to current axes.  *X* may be a float
array, a uint8 array or a PIL image. If *X* is an array, *X*
can have the following shapes:

* MxN -- luminance (grayscale, float array only)
* MxNx3 -- RGB (float or uint8 array)
* MxNx4 -- RGBA (float or uint8 array)

The value for each component of MxNx3 and MxNx4 float arrays should be
in the range 0.0 to 1.0; MxN float arrays may be normalised.

An :class:`matplotlib.image.AxesImage` instance is returned.

Keyword arguments:

  *cmap*: [ None | Colormap ]
    A :class:`matplotlib.cm.Colormap` instance, eg. cm.jet.
    If *None*, default to rc ``image.cmap`` value.

    *cmap* is ignored when *X* has RGB(A) information

  *aspect*: [ None | 'auto' | 'equal' | scalar ]
    If 'auto', changes the image aspect ratio to match that of the axes

    If 'equal', and *extent* is *None*, changes the axes
    aspect ratio to match that of the image. If *extent* is
    not *None*, the axes aspect ratio is changed to match that
    of the extent.

    If *None*, default to rc ``image.aspect`` value.

  *interpolation*:

    Acceptable values are *None*, 'nearest', 'bilinear',
      'bicubic', 'spline16', 'spline36', 'hanning', 'hamming',
      'hermite', 'kaiser', 'quadric', 'catrom', 'gaussian',
      'bessel', 'mitchell', 'sinc', 'lanczos',


    If *interpolation* is *None*, default to rc
    ``image.interpolation``. See also the *filternorm* and
    *filterrad* parameters

  *norm*: [ None | Normalize ]
    An :class:`matplotlib.colors.Normalize` instance; if
    *None*, default is ``normalization()``.  This scales
    luminance -> 0-1

    *norm* is only used for an MxN float array.

  *vmin*/*vmax*: [ None | scalar ]
    Used to scale a luminance image to 0-1.  If either is
    *None*, the min and max of the luminance values will be
    used.  Note if *norm* is not *None*, the settings for
    *vmin* and *vmax* will be ignored.

  *alpha*: scalar
    The alpha blending value, between 0 (transparent) and 1 (opaque)

  *origin*: [ None | 'upper' | 'lower' ]
    Place the [0,0] index of the array in the upper left or lower left
    corner of the axes. If *None*, default to rc ``image.origin``.

  *extent*: [ None | scalars (left, right, bottom, top) ]
    Data limits for the axes.  The default assigns zero-based row,
    column indices to the *x*, *y* centers of the pixels.

  *shape*: [ None | scalars (columns, rows) ]
    For raw buffer images

  *filternorm*:
    A parameter for the antigrain image resize filter.  From the
    antigrain documentation, if *filternorm* = 1, the filter normalizes
    integer values and corrects the rounding errors. It doesn't do
    anything with the source floating point values, it corrects only
    integers according to the rule of 1.0 which means that any sum of
    pixel weights must be equal to 1.0.  So, the filter function must
    produce a graph of the proper shape.

  *filterrad*:
    The filter radius for filters that have a radius
    parameter, i.e. when interpolation is one of: 'sinc',
    'lanczos' or 'blackman'

Additional kwargs are :class:`~matplotlib.artist.Artist` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  contains: a callable function
  figure: a :class:`matplotlib.figure.Figure` instance
  gid: an id string
  label: any string
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/image_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
ioff

Turn interactive mode off.
---------------------------------------------------------------------------
ion

Turn interactive mode on.
---------------------------------------------------------------------------
ishold


    Return the hold status of the current axes

---------------------------------------------------------------------------
isinteractive


    Return the interactive status

---------------------------------------------------------------------------
legend

call signature::

  legend(*args, **kwargs)

Place a legend on the current axes at location *loc*.  Labels are a
sequence of strings and *loc* can be a string or an integer specifying
the legend location.

To make a legend with existing lines::

  legend()

:meth:`legend` by itself will try and build a legend using the label
property of the lines/patches/collections.  You can set the label of
a line by doing::

  plot(x, y, label='my data')

or::

  line.set_label('my data').

If label is set to '_nolegend_', the item will not be shown in
legend.

To automatically generate the legend from labels::

  legend( ('label1', 'label2', 'label3') )

To make a legend for a list of lines and labels::

  legend( (line1, line2, line3), ('label1', 'label2', 'label3') )

To make a legend at a given location, using a location argument::

  legend( ('label1', 'label2', 'label3'), loc='upper left')

or::

  legend( (line1, line2, line3),  ('label1', 'label2', 'label3'), loc=2)

The location codes are

  ===============   =============
  Location String   Location Code
  ===============   =============
  'best'            0
  'upper right'     1
  'upper left'      2
  'lower left'      3
  'lower right'     4
  'right'           5
  'center left'     6
  'center right'    7
  'lower center'    8
  'upper center'    9
  'center'          10
  ===============   =============


Users can specify any arbitrary location for the legend using the
*bbox_to_anchor* keyword argument. bbox_to_anchor can be an instance
of BboxBase(or its derivatives) or a tuple of 2 or 4 floats.
For example,

  loc = 'upper right', bbox_to_anchor = (0.5, 0.5)

will place the legend so that the upper right corner of the legend at
the center of the axes.

The legend location can be specified in other coordinate, by using the
*bbox_transform* keyword.

The loc itslef can be a 2-tuple giving x,y of the lower-left corner of
the legend in axes coords (*bbox_to_anchor* is ignored).


Keyword arguments:

  *prop*: [ None | FontProperties | dict ]
    A :class:`matplotlib.font_manager.FontProperties`
    instance. If *prop* is a dictionary, a new instance will be
    created with *prop*. If *None*, use rc settings.

  *numpoints*: integer
    The number of points in the legend for line

  *scatterpoints*: integer
    The number of points in the legend for scatter plot

  *scatteroffsets*: list of floats
    a list of yoffsets for scatter symbols in legend

  *markerscale*: [ None | scalar ]
    The relative size of legend markers vs. original. If *None*, use rc
    settings.

  *fancybox*: [ None | False | True ]
    if True, draw a frame with a round fancybox.  If None, use rc

  *shadow*: [ None | False | True ]
    If *True*, draw a shadow behind legend. If *None*, use rc settings.

  *ncol* : integer
    number of columns. default is 1

  *mode* : [ "expand" | None ]
    if mode is "expand", the legend will be horizontally expanded
    to fill the axes area (or *bbox_to_anchor*)

  *bbox_to_anchor* : an instance of BboxBase or a tuple of 2 or 4 floats
    the bbox that the legend will be anchored.

  *bbox_transform* : [ an instance of Transform | None ]
    the transform for the bbox. transAxes if None.

  *title* : string
    the legend title

Padding and spacing between various elements use following keywords
parameters. The dimensions of these values are given as a fraction
of the fontsize. Values from rcParams will be used if None.

================   ==================================================================
Keyword            Description
================   ==================================================================
borderpad          the fractional whitespace inside the legend border
labelspacing       the vertical space between the legend entries
handlelength       the length of the legend handles
handletextpad      the pad between the legend handle and text
borderaxespad      the pad between the axes and legend border
columnspacing      the spacing between columns
================   ==================================================================


**Example:**

.. plot:: mpl_examples/api/legend_demo.py

Also see :ref:`plotting-guide-legend`.
---------------------------------------------------------------------------
loglog

call signature::

  loglog(*args, **kwargs)

Make a plot with log scaling on the *x* and *y* axis.

:func:`~matplotlib.pyplot.loglog` supports all the keyword
arguments of :func:`~matplotlib.pyplot.plot` and
:meth:`matplotlib.axes.Axes.set_xscale` /
:meth:`matplotlib.axes.Axes.set_yscale`.

Notable keyword arguments:

  *basex*/*basey*: scalar > 1
    base of the *x*/*y* logarithm

  *subsx*/*subsy*: [ None | sequence ]
    the location of the minor *x*/*y* ticks; *None* defaults
    to autosubs, which depend on the number of decades in the
    plot; see :meth:`matplotlib.axes.Axes.set_xscale` /
    :meth:`matplotlib.axes.Axes.set_yscale` for details

  *nonposx*/*nonposy*: ['mask' | 'clip' ]
    non-positive values in *x* or *y* can be masked as
    invalid, or clipped to a very small positive number

The remaining valid kwargs are
:class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/log_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
matshow


    Display an array as a matrix in a new figure window.

    The origin is set at the upper left hand corner and rows (first
    dimension of the array) are displayed horizontally.  The aspect
    ratio of the figure window is that of the array, unless this would
    make an excessively short or narrow figure.

    Tick labels for the xaxis are placed on top.

    With the exception of fignum, keyword arguments are passed to
    :func:`~matplotlib.pyplot.imshow`.


    *fignum*: [ None | integer | False ]
      By default, :func:`matshow` creates a new figure window with
      automatic numbering.  If *fignum* is given as an integer, the
      created figure will use this figure number.  Because of how
      :func:`matshow` tries to set the figure aspect ratio to be the
      one of the array, if you provide the number of an already
      existing figure, strange things may happen.

      If *fignum* is *False* or 0, a new figure window will **NOT** be created.

---------------------------------------------------------------------------
pcolor

call signatures::

  pcolor(C, **kwargs)
  pcolor(X, Y, C, **kwargs)

Create a pseudocolor plot of a 2-D array.

*C* is the array of color values.

*X* and *Y*, if given, specify the (*x*, *y*) coordinates of
the colored quadrilaterals; the quadrilateral for C[i,j] has
corners at::

  (X[i,   j],   Y[i,   j]),
  (X[i,   j+1], Y[i,   j+1]),
  (X[i+1, j],   Y[i+1, j]),
  (X[i+1, j+1], Y[i+1, j+1]).

Ideally the dimensions of *X* and *Y* should be one greater
than those of *C*; if the dimensions are the same, then the
last row and column of *C* will be ignored.

Note that the the column index corresponds to the
*x*-coordinate, and the row index corresponds to *y*; for
details, see the :ref:`Grid Orientation
<axes-pcolor-grid-orientation>` section below.

If either or both of *X* and *Y* are 1-D arrays or column vectors,
they will be expanded as needed into the appropriate 2-D arrays,
making a rectangular grid.

*X*, *Y* and *C* may be masked arrays.  If either C[i, j], or one
of the vertices surrounding C[i,j] (*X* or *Y* at [i, j], [i+1, j],
[i, j+1],[i+1, j+1]) is masked, nothing is plotted.

Keyword arguments:

  *cmap*: [ None | Colormap ]
    A :class:`matplotlib.cm.Colormap` instance. If *None*, use
    rc settings.

  norm: [ None | Normalize ]
    An :class:`matplotlib.colors.Normalize` instance is used
    to scale luminance data to 0,1. If *None*, defaults to
    :func:`normalize`.

  *vmin*/*vmax*: [ None | scalar ]
    *vmin* and *vmax* are used in conjunction with *norm* to
    normalize luminance data.  If either are *None*, the min
    and max of the color array *C* is used.  If you pass a
    *norm* instance, *vmin* and *vmax* will be ignored.

  *shading*: [ 'flat' | 'faceted' ]
    If 'faceted', a black grid is drawn around each rectangle; if
    'flat', edges are not drawn. Default is 'flat', contrary to
    Matlab(TM).

    This kwarg is deprecated; please use 'edgecolors' instead:
      * shading='flat' -- edgecolors='None'
      * shading='faceted  -- edgecolors='k'

  *edgecolors*: [ None | 'None' | color | color sequence]
    If *None*, the rc setting is used by default.

    If 'None', edges will not be visible.

    An mpl color or sequence of colors will set the edge color

  *alpha*: 0 <= scalar <= 1
    the alpha blending value

Return value is a :class:`matplotlib.collection.Collection`
instance.

.. _axes-pcolor-grid-orientation:

The grid orientation follows the Matlab(TM) convention: an
array *C* with shape (*nrows*, *ncolumns*) is plotted with
the column number as *X* and the row number as *Y*, increasing
up; hence it is plotted the way the array would be printed,
except that the *Y* axis is reversed.  That is, *C* is taken
as *C*(*y*, *x*).

Similarly for :func:`~matplotlib.pyplot.meshgrid`::

  x = np.arange(5)
  y = np.arange(3)
  X, Y = meshgrid(x,y)

is equivalent to:

  X = array([[0, 1, 2, 3, 4],
             [0, 1, 2, 3, 4],
             [0, 1, 2, 3, 4]])

  Y = array([[0, 0, 0, 0, 0],
             [1, 1, 1, 1, 1],
             [2, 2, 2, 2, 2]])

so if you have::

  C = rand( len(x), len(y))

then you need::

  pcolor(X, Y, C.T)

or::

  pcolor(C.T)

Matlab :func:`pcolor` always discards the last row and column
of *C*, but matplotlib displays the last row and column if *X* and
*Y* are not specified, or if *X* and *Y* have one more row and
column than *C*.

kwargs can be used to control the
:class:`~matplotlib.collection.PolyCollection` properties:

  alpha: float
  animated: [True | False]
  antialiased or antialiaseds: Boolean or sequence of booleans
  array: unknown
  axes: an :class:`~matplotlib.axes.Axes` instance
  clim: a length 2 sequence of floats
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  cmap: a colormap or registered colormap name
  color: matplotlib color arg or sequence of rgba tuples
  colorbar: unknown
  contains: a callable function
  edgecolor or edgecolors: matplotlib color arg or sequence of rgba tuples
  facecolor or facecolors: matplotlib color arg or sequence of rgba tuples
  figure: a :class:`matplotlib.figure.Figure` instance
  gid: an id string
  label: any string
  linestyle or linestyles or dashes: ['solid' | 'dashed', 'dashdot', 'dotted' |         (offset, on-off-dash-seq) ]
  linewidth or lw or linewidths: float or sequence of floats
  lod: [True | False]
  norm: unknown
  offsets: float or sequence of floats
  picker: [None|float|boolean|callable]
  pickradius: unknown
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  urls: unknown
  visible: [True | False]
  zorder: any number

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
pcolormesh

call signatures::

  pcolormesh(C)
  pcolormesh(X, Y, C)
  pcolormesh(C, **kwargs)

*C* may be a masked array, but *X* and *Y* may not.  Masked
array support is implemented via *cmap* and *norm*; in
contrast, :func:`~matplotlib.pyplot.pcolor` simply does not
draw quadrilaterals with masked colors or vertices.

Keyword arguments:

  *cmap*: [ None | Colormap ]
    A :class:`matplotlib.cm.Colormap` instance. If None, use
    rc settings.

  *norm*: [ None | Normalize ]
    A :class:`matplotlib.colors.Normalize` instance is used to
    scale luminance data to 0,1. If None, defaults to
    :func:`normalize`.

  *vmin*/*vmax*: [ None | scalar ]
    *vmin* and *vmax* are used in conjunction with *norm* to
    normalize luminance data.  If either are *None*, the min
    and max of the color array *C* is used.  If you pass a
    *norm* instance, *vmin* and *vmax* will be ignored.

  *shading*: [ 'flat' | 'faceted' ]
    If 'faceted', a black grid is drawn around each rectangle; if
    'flat', edges are not drawn. Default is 'flat', contrary to
    Matlab(TM).

    This kwarg is deprecated; please use 'edgecolors' instead:
      * shading='flat' -- edgecolors='None'
      * shading='faceted  -- edgecolors='k'

  *edgecolors*: [ None | 'None' | color | color sequence]
    If None, the rc setting is used by default.

    If 'None', edges will not be visible.

    An mpl color or sequence of colors will set the edge color

  *alpha*: 0 <= scalar <= 1
    the alpha blending value

Return value is a :class:`matplotlib.collection.QuadMesh`
object.

kwargs can be used to control the
:class:`matplotlib.collections.QuadMesh`
properties:

  alpha: float
  animated: [True | False]
  antialiased or antialiaseds: Boolean or sequence of booleans
  array: unknown
  axes: an :class:`~matplotlib.axes.Axes` instance
  clim: a length 2 sequence of floats
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  cmap: a colormap or registered colormap name
  color: matplotlib color arg or sequence of rgba tuples
  colorbar: unknown
  contains: a callable function
  edgecolor or edgecolors: matplotlib color arg or sequence of rgba tuples
  facecolor or facecolors: matplotlib color arg or sequence of rgba tuples
  figure: a :class:`matplotlib.figure.Figure` instance
  gid: an id string
  label: any string
  linestyle or linestyles or dashes: ['solid' | 'dashed', 'dashdot', 'dotted' |         (offset, on-off-dash-seq) ]
  linewidth or lw or linewidths: float or sequence of floats
  lod: [True | False]
  norm: unknown
  offsets: float or sequence of floats
  picker: [None|float|boolean|callable]
  pickradius: unknown
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  urls: unknown
  visible: [True | False]
  zorder: any number

.. seealso::

    :func:`~matplotlib.pyplot.pcolor`
        For an explanation of the grid orientation and the
        expansion of 1-D *X* and/or *Y* to 2-D arrays.

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
pie

call signature::

  pie(x, explode=None, labels=None,
      colors=('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'),
      autopct=None, pctdistance=0.6, labeldistance=1.1, shadow=False)

Make a pie chart of array *x*.  The fractional area of each
wedge is given by x/sum(x).  If sum(x) <= 1, then the values
of x give the fractional area directly and the array will not
be normalized.

Keyword arguments:

  *explode*: [ None | len(x) sequence ]
    If not *None*, is a len(*x*) array which specifies the
    fraction of the radius with which to offset each wedge.

  *colors*: [ None | color sequence ]
    A sequence of matplotlib color args through which the pie chart
    will cycle.

  *labels*: [ None | len(x) sequence of strings ]
    A sequence of strings providing the labels for each wedge

  *autopct*: [ None | format string | format function ]
    If not *None*, is a string or function used to label the
    wedges with their numeric value.  The label will be placed inside
    the wedge.  If it is a format string, the label will be ``fmt%pct``.
    If it is a function, it will be called.

  *pctdistance*: scalar
    The ratio between the center of each pie slice and the
    start of the text generated by *autopct*.  Ignored if
    *autopct* is *None*; default is 0.6.

  *labeldistance*: scalar
    The radial distance at which the pie labels are drawn

  *shadow*: [ False | True ]
    Draw a shadow beneath the pie.

The pie chart will probably look best if the figure and axes are
square.  Eg.::

  figure(figsize=(8,8))
  ax = axes([0.1, 0.1, 0.8, 0.8])

Return value:
  If *autopct* is None, return the tuple (*patches*, *texts*):

    - *patches* is a sequence of
      :class:`matplotlib.patches.Wedge` instances

    - *texts* is a list of the label
      :class:`matplotlib.text.Text` instances.

  If *autopct* is not *None*, return the tuple (*patches*,
  *texts*, *autotexts*), where *patches* and *texts* are as
  above, and *autotexts* is a list of
  :class:`~matplotlib.text.Text` instances for the numeric
  labels.

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
plot

Plot lines and/or markers to the
:class:`~matplotlib.axes.Axes`.  *args* is a variable length
argument, allowing for multiple *x*, *y* pairs with an
optional format string.  For example, each of the following is
legal::

    plot(x, y)         # plot x and y using default line style and color
    plot(x, y, 'bo')   # plot x and y using blue circle markers
    plot(y)            # plot y using x as index array 0..N-1
    plot(y, 'r+')      # ditto, but with red plusses

If *x* and/or *y* is 2-dimensional, then the corresponding columns
will be plotted.

An arbitrary number of *x*, *y*, *fmt* groups can be
specified, as in::

    a.plot(x1, y1, 'g^', x2, y2, 'g-')

Return value is a list of lines that were added.

The following format string characters are accepted to control
the line style or marker:

================    ===============================
character           description
================    ===============================
``'-'``             solid line style
``'--'``            dashed line style
``'-.'``            dash-dot line style
``':'``             dotted line style
``'.'``             point marker
``','``             pixel marker
``'o'``             circle marker
``'v'``             triangle_down marker
``'^'``             triangle_up marker
``'<'``             triangle_left marker
``'>'``             triangle_right marker
``'1'``             tri_down marker
``'2'``             tri_up marker
``'3'``             tri_left marker
``'4'``             tri_right marker
``'s'``             square marker
``'p'``             pentagon marker
``'*'``             star marker
``'h'``             hexagon1 marker
``'H'``             hexagon2 marker
``'+'``             plus marker
``'x'``             x marker
``'D'``             diamond marker
``'d'``             thin_diamond marker
``'|'``             vline marker
``'_'``             hline marker
================    ===============================


The following color abbreviations are supported:

==========  ========
character   color
==========  ========
'b'         blue
'g'         green
'r'         red
'c'         cyan
'm'         magenta
'y'         yellow
'k'         black
'w'         white
==========  ========

In addition, you can specify colors in many weird and
wonderful ways, including full names (``'green'``), hex
strings (``'#008000'``), RGB or RGBA tuples (``(0,1,0,1)``) or
grayscale intensities as a string (``'0.8'``).  Of these, the
string specifications can be used in place of a ``fmt`` group,
but the tuple forms can be used only as ``kwargs``.

Line styles and colors are combined in a single format string, as in
``'bo'`` for blue circles.

The *kwargs* can be used to set line properties (any property that has
a ``set_*`` method).  You can use this to set a line label (for auto
legends), linewidth, anitialising, marker face color, etc.  Here is an
example::

    plot([1,2,3], [1,2,3], 'go-', label='line 1', linewidth=2)
    plot([1,2,3], [1,4,9], 'rs',  label='line 2')
    axis([0, 4, 0, 10])
    legend()

If you make multiple lines with one plot command, the kwargs
apply to all those lines, e.g.::

    plot(x1, y1, x2, y2, antialised=False)

Neither line will be antialiased.

You do not need to use format strings, which are just
abbreviations.  All of the line properties can be controlled
by keyword arguments.  For example, you can set the color,
marker, linestyle, and markercolor with::

    plot(x, y, color='green', linestyle='dashed', marker='o',
         markerfacecolor='blue', markersize=12).  See
         :class:`~matplotlib.lines.Line2D` for details.

The kwargs are :class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

kwargs *scalex* and *scaley*, if defined, are passed on to
:meth:`~matplotlib.axes.Axes.autoscale_view` to determine
whether the *x* and *y* axes are autoscaled; the default is
*True*.

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
plot_date

call signature::

  plot_date(x, y, fmt='bo', tz=None, xdate=True, ydate=False, **kwargs)

Similar to the :func:`~matplotlib.pyplot.plot` command, except
the *x* or *y* (or both) data is considered to be dates, and the
axis is labeled accordingly.

*x* and/or *y* can be a sequence of dates represented as float
days since 0001-01-01 UTC.

Keyword arguments:

  *fmt*: string
    The plot format string.

  *tz*: [ None | timezone string ]
    The time zone to use in labeling dates. If *None*, defaults to rc
    value.

  *xdate*: [ True | False ]
    If *True*, the *x*-axis will be labeled with dates.

  *ydate*: [ False | True ]
    If *True*, the *y*-axis will be labeled with dates.

Note if you are using custom date tickers and formatters, it
may be necessary to set the formatters/locators after the call
to :meth:`plot_date` since :meth:`plot_date` will set the
default tick locator to
:class:`matplotlib.dates.AutoDateLocator` (if the tick
locator is not already set to a
:class:`matplotlib.dates.DateLocator` instance) and the
default tick formatter to
:class:`matplotlib.dates.AutoDateFormatter` (if the tick
formatter is not already set to a
:class:`matplotlib.dates.DateFormatter` instance).

Valid kwargs are :class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

.. seealso::

    :mod:`~matplotlib.dates`
        for helper functions

    :func:`~matplotlib.dates.date2num`,
    :func:`~matplotlib.dates.num2date` and
    :func:`~matplotlib.dates.drange`
        for help on creating the required floating point
        dates.

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
polar


    call signature::

      polar(theta, r, **kwargs)

    Make a polar plot.  Multiple *theta*, *r* arguments are supported,
    with format strings, as in :func:`~matplotlib.pyplot.plot`.

    An optional kwarg *resolution* sets the number of vertices to
    interpolate between each pair of points.  The default is 1,
    which disables interpolation.

---------------------------------------------------------------------------
psd

call signature::

  psd(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
      window=mlab.window_hanning, noverlap=0, pad_to=None,
      sides='default', scale_by_freq=None, **kwargs)

The power spectral density by Welch's average periodogram
method.  The vector *x* is divided into *NFFT* length
segments.  Each segment is detrended by function *detrend* and
windowed by function *window*.  *noverlap* gives the length of
the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
of each segment :math:`i` are averaged to compute *Pxx*, with a
scaling to correct for power loss due to windowing.  *Fs* is the
sampling frequency.

Keyword arguments:

  *NFFT*: integer
      The number of data points used in each block for the FFT.
      Must be even; a power 2 is most efficient.  The default value is 256.

  *Fs*: scalar
      The sampling frequency (samples per time unit).  It is used
      to calculate the Fourier frequencies, freqs, in cycles per time
      unit. The default value is 2.

  *detrend*: callable
      The function applied to each segment before fft-ing,
      designed to remove the mean or linear trend.  Unlike in
      matlab, where the *detrend* parameter is a vector, in
      matplotlib is it a function.  The :mod:`~matplotlib.pylab`
      module defines :func:`~matplotlib.pylab.detrend_none`,
      :func:`~matplotlib.pylab.detrend_mean`, and
      :func:`~matplotlib.pylab.detrend_linear`, but you can use
      a custom function as well.

  *window*: callable or ndarray
      A function or a vector of length *NFFT*. To create window
      vectors see :func:`window_hanning`, :func:`window_none`,
      :func:`numpy.blackman`, :func:`numpy.hamming`,
      :func:`numpy.bartlett`, :func:`scipy.signal`,
      :func:`scipy.signal.get_window`, etc. The default is
      :func:`window_hanning`.  If a function is passed as the
      argument, it must take a data segment as an argument and
      return the windowed version of the segment.

  *noverlap*: integer
      The number of points of overlap between blocks.  The default value
      is 0 (no overlap).

  *pad_to*: integer
      The number of points to which the data segment is padded when
      performing the FFT.  This can be different from *NFFT*, which
      specifies the number of data points used.  While not increasing
      the actual resolution of the psd (the minimum distance between
      resolvable peaks), this can give more points in the plot,
      allowing for more detail. This corresponds to the *n* parameter
      in the call to fft(). The default is None, which sets *pad_to*
      equal to *NFFT*

  *sides*: [ 'default' | 'onesided' | 'twosided' ]
      Specifies which sides of the PSD to return.  Default gives the
      default behavior, which returns one-sided for real data and both
      for complex data.  'onesided' forces the return of a one-sided PSD,
      while 'twosided' forces two-sided.

  *scale_by_freq*: boolean
      Specifies whether the resulting density values should be scaled
      by the scaling frequency, which gives density in units of Hz^-1.
      This allows for integration over the returned frequency values.
      The default is True for MatLab compatibility.

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the x extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

Returns the tuple (*Pxx*, *freqs*).

For plotting, the power is plotted as
:math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
is returned.

References:
  Bendat & Piersol -- Random Data: Analysis and Measurement
  Procedures, John Wiley & Sons (1986)

kwargs control the :class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

**Example:**

.. plot:: mpl_examples/pylab_examples/psd_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
quiver


Plot a 2-D field of arrows.

call signatures::

  quiver(U, V, **kw)
  quiver(U, V, C, **kw)
  quiver(X, Y, U, V, **kw)
  quiver(X, Y, U, V, C, **kw)

Arguments:

  *X*, *Y*:

    The x and y coordinates of the arrow locations (default is tail of
    arrow; see *pivot* kwarg)

  *U*, *V*:

    give the *x* and *y* components of the arrow vectors

  *C*:
    an optional array used to map colors to the arrows

All arguments may be 1-D or 2-D arrays or sequences. If *X* and *Y*
are absent, they will be generated as a uniform grid.  If *U* and *V*
are 2-D arrays but *X* and *Y* are 1-D, and if len(*X*) and len(*Y*)
match the column and row dimensions of *U*, then *X* and *Y* will be
expanded with :func:`numpy.meshgrid`.

*U*, *V*, *C* may be masked arrays, but masked *X*, *Y* are not
supported at present.

Keyword arguments:

  *units*: ['width' | 'height' | 'dots' | 'inches' | 'x' | 'y' ]
    arrow units; the arrow dimensions *except for length* are in
    multiples of this unit.

    * 'width' or 'height': the width or height of the axes

    * 'dots' or 'inches': pixels or inches, based on the figure dpi

    * 'x' or 'y': *X* or *Y* data units

    The arrows scale differently depending on the units.  For
    'x' or 'y', the arrows get larger as one zooms in; for other
    units, the arrow size is independent of the zoom state.  For
    'width or 'height', the arrow size increases with the width and
    height of the axes, respectively, when the the window is resized;
    for 'dots' or 'inches', resizing does not change the arrows.

   *angles*: ['uv' | 'xy' | array]
    With the default 'uv', the arrow aspect ratio is 1, so that
    if *U*==*V* the angle of the arrow on the plot is 45 degrees
    CCW from the *x*-axis.
    With 'xy', the arrow points from (x,y) to (x+u, y+v).
    Alternatively, arbitrary angles may be specified as an array
    of values in degrees, CCW from the *x*-axis.

  *scale*: [ None | float ]
    data units per arrow unit, e.g. m/s per plot width; a smaller
    scale parameter makes the arrow longer.  If *None*, a simple
    autoscaling algorithm is used, based on the average vector length
    and the number of vectors.

  *width*:
    shaft width in arrow units; default depends on choice of units,
    above, and number of vectors; a typical starting value is about
    0.005 times the width of the plot.

  *headwidth*: scalar
    head width as multiple of shaft width, default is 3

  *headlength*: scalar
    head length as multiple of shaft width, default is 5

  *headaxislength*: scalar
    head length at shaft intersection, default is 4.5

  *minshaft*: scalar
    length below which arrow scales, in units of head length. Do not
    set this to less than 1, or small arrows will look terrible!
    Default is 1

  *minlength*: scalar
    minimum length as a multiple of shaft width; if an arrow length
    is less than this, plot a dot (hexagon) of this diameter instead.
    Default is 1.

  *pivot*: [ 'tail' | 'middle' | 'tip' ]
    The part of the arrow that is at the grid point; the arrow rotates
    about this point, hence the name *pivot*.

  *color*: [ color | color sequence ]
    This is a synonym for the
    :class:`~matplotlib.collections.PolyCollection` facecolor kwarg.
    If *C* has been set, *color* has no effect.

The defaults give a slightly swept-back arrow; to make the head a
triangle, make *headaxislength* the same as *headlength*. To make the
arrow more pointed, reduce *headwidth* or increase *headlength* and
*headaxislength*. To make the head smaller relative to the shaft,
scale down all the head parameters. You will probably do best to leave
minshaft alone.

linewidths and edgecolors can be used to customize the arrow
outlines. Additional :class:`~matplotlib.collections.PolyCollection`
keyword arguments:

  alpha: float
  animated: [True | False]
  antialiased or antialiaseds: Boolean or sequence of booleans
  array: unknown
  axes: an :class:`~matplotlib.axes.Axes` instance
  clim: a length 2 sequence of floats
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  cmap: a colormap or registered colormap name
  color: matplotlib color arg or sequence of rgba tuples
  colorbar: unknown
  contains: a callable function
  edgecolor or edgecolors: matplotlib color arg or sequence of rgba tuples
  facecolor or facecolors: matplotlib color arg or sequence of rgba tuples
  figure: a :class:`matplotlib.figure.Figure` instance
  gid: an id string
  label: any string
  linestyle or linestyles or dashes: ['solid' | 'dashed', 'dashdot', 'dotted' |         (offset, on-off-dash-seq) ]
  linewidth or lw or linewidths: float or sequence of floats
  lod: [True | False]
  norm: unknown
  offsets: float or sequence of floats
  picker: [None|float|boolean|callable]
  pickradius: unknown
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  urls: unknown
  visible: [True | False]
  zorder: any number


Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
rc

Set the current rc params.  Group is the grouping for the rc, eg.
for ``lines.linewidth`` the group is ``lines``, for
``axes.facecolor``, the group is ``axes``, and so on.  Group may
also be a list or tuple of group names, eg. (*xtick*, *ytick*).
*kwargs* is a dictionary attribute name/value pairs, eg::

  rc('lines', linewidth=2, color='r')

sets the current rc params and is equivalent to::

  rcParams['lines.linewidth'] = 2
  rcParams['lines.color'] = 'r'

The following aliases are available to save typing for interactive
users:

=====   =================
Alias   Property
=====   =================
'lw'    'linewidth'
'ls'    'linestyle'
'c'     'color'
'fc'    'facecolor'
'ec'    'edgecolor'
'mew'   'markeredgewidth'
'aa'    'antialiased'
=====   =================

Thus you could abbreviate the above rc command as::

      rc('lines', lw=2, c='r')


Note you can use python's kwargs dictionary facility to store
dictionaries of default parameters.  Eg, you can customize the
font rc as follows::

  font = {'family' : 'monospace',
          'weight' : 'bold',
          'size'   : 'larger'}

  rc('font', **font)  # pass in the font dict as kwargs

This enables you to easily switch between several configurations.
Use :func:`~matplotlib.pyplot.rcdefaults` to restore the default
rc params after changes.
---------------------------------------------------------------------------
rgrids


    Set/Get the radial locations of the gridlines and ticklabels on a
    polar plot.

    call signatures::

      lines, labels = rgrids()
      lines, labels = rgrids(radii, labels=None, angle=22.5, **kwargs)

    When called with no arguments, :func:`rgrid` simply returns the
    tuple (*lines*, *labels*), where *lines* is an array of radial
    gridlines (:class:`~matplotlib.lines.Line2D` instances) and
    *labels* is an array of tick labels
    (:class:`~matplotlib.text.Text` instances). When called with
    arguments, the labels will appear at the specified radial
    distances and angles.

    *labels*, if not *None*, is a len(*radii*) list of strings of the
    labels to use at each angle.

    If *labels* is None, the rformatter will be used

    Examples::

      # set the locations of the radial gridlines and labels
      lines, labels = rgrids( (0.25, 0.5, 1.0) )

      # set the locations and labels of the radial gridlines and labels
      lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' )


---------------------------------------------------------------------------
savefig

call signature::

  savefig(fname, dpi=None, facecolor='w', edgecolor='w',
          orientation='portrait', papertype=None, format=None,
          transparent=False):

Save the current figure.

The output formats available depend on the backend being used.

Arguments:

  *fname*:
    A string containing a path to a filename, or a Python file-like object.

    If *format* is *None* and *fname* is a string, the output
    format is deduced from the extension of the filename.

Keyword arguments:

  *dpi*: [ None | scalar > 0 ]
    The resolution in dots per inch.  If *None* it will default to
    the value ``savefig.dpi`` in the matplotlibrc file.

  *facecolor*, *edgecolor*:
    the colors of the figure rectangle

  *orientation*: [ 'landscape' | 'portrait' ]
    not supported on all backends; currently only on postscript output

  *papertype*:
    One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
    'a10', 'b0' through 'b10'. Only supported for postscript
    output.

  *format*:
    One of the file extensions supported by the active
    backend.  Most backends support png, pdf, ps, eps and svg.

  *transparent*:
    If *True*, the figure patch and axes patches will all be
    transparent.  This is useful, for example, for displaying
    a plot on top of a colored background on a web page.  The
    transparency of these patches will be restored to their
    original values upon exit of this function.

  *bbox_inches*:
    Bbox in inches. Only the given portion of the figure is
    saved. If 'tight', try to figure out the tight bbox of
    the figure.

  *pad_inches*:
    Amount of padding around the figure when bbox_inches is
    'tight'.
---------------------------------------------------------------------------
scatter

call signatures::

  scatter(x, y, s=20, c='b', marker='o', cmap=None, norm=None,
          vmin=None, vmax=None, alpha=1.0, linewidths=None,
          verts=None, **kwargs)

Make a scatter plot of *x* versus *y*, where *x*, *y* are
converted to 1-D sequences which must be of the same length, *N*.

Keyword arguments:

  *s*:
    size in points^2.  It is a scalar or an array of the same
    length as *x* and *y*.

  *c*:
    a color. *c* can be a single color format string, or a
    sequence of color specifications of length *N*, or a
    sequence of *N* numbers to be mapped to colors using the
    *cmap* and *norm* specified via kwargs (see below). Note
    that *c* should not be a single numeric RGB or RGBA
    sequence because that is indistinguishable from an array
    of values to be colormapped.  *c* can be a 2-D array in
    which the rows are RGB or RGBA, however.

  *marker*:
    can be one of:

    =====   ==============
    Value   Description
    =====   ==============
    's'     square
    'o'     circle
    '^'     triangle up
    '>'     triangle right
    'v'     triangle down
    '<'     triangle left
    'd'     diamond
    'p'     pentagram
    'h'     hexagon
    '8'     octagon
    '+'     plus
    'x'     cross
    =====   ==============

    The marker can also be a tuple (*numsides*, *style*,
    *angle*), which will create a custom, regular symbol.

      *numsides*:
        the number of sides

      *style*:
        the style of the regular symbol:

        =====   =============================================
        Value   Description
        =====   =============================================
        0       a regular polygon
        1       a star-like symbol
        2       an asterisk
        3       a circle (*numsides* and *angle* is ignored)
        =====   =============================================

      *angle*:
        the angle of rotation of the symbol

    Finally, *marker* can be (*verts*, 0): *verts* is a
    sequence of (*x*, *y*) vertices for a custom scatter
    symbol.  Alternatively, use the kwarg combination
    *marker* = *None*, *verts* = *verts*.

Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in
which case all masks will be combined and only unmasked points
will be plotted.

Other keyword arguments: the color mapping and normalization
arguments will be used only if *c* is an array of floats.

  *cmap*: [ None | Colormap ]
    A :class:`matplotlib.colors.Colormap` instance or registered
    name. If *None*, defaults to rc ``image.cmap``. *cmap* is
    only used if *c* is an array of floats.

  *norm*: [ None | Normalize ]
    A :class:`matplotlib.colors.Normalize` instance is used to
    scale luminance data to 0, 1. If *None*, use the default
    :func:`normalize`. *norm* is only used if *c* is an array
    of floats.

  *vmin*/*vmax*:
    *vmin* and *vmax* are used in conjunction with norm to
    normalize luminance data.  If either are None, the min and
    max of the color array *C* is used.  Note if you pass a
    *norm* instance, your settings for *vmin* and *vmax* will
    be ignored.

  *alpha*: 0 <= scalar <= 1
    The alpha value for the patches

  *linewidths*: [ None | scalar | sequence ]
    If *None*, defaults to (lines.linewidth,).  Note that this
    is a tuple, and if you set the linewidths argument you
    must set it as a sequence of floats, as required by
    :class:`~matplotlib.collections.RegularPolyCollection`.

Optional kwargs control the
:class:`~matplotlib.collections.Collection` properties; in
particular:

  *edgecolors*:
    'none' to plot faces with no outlines

  *facecolors*:
    'none' to plot unfilled outlines

Here are the standard descriptions of all the
:class:`~matplotlib.collections.Collection` kwargs:

  alpha: float
  animated: [True | False]
  antialiased or antialiaseds: Boolean or sequence of booleans
  array: unknown
  axes: an :class:`~matplotlib.axes.Axes` instance
  clim: a length 2 sequence of floats
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  cmap: a colormap or registered colormap name
  color: matplotlib color arg or sequence of rgba tuples
  colorbar: unknown
  contains: a callable function
  edgecolor or edgecolors: matplotlib color arg or sequence of rgba tuples
  facecolor or facecolors: matplotlib color arg or sequence of rgba tuples
  figure: a :class:`matplotlib.figure.Figure` instance
  gid: an id string
  label: any string
  linestyle or linestyles or dashes: ['solid' | 'dashed', 'dashdot', 'dotted' |         (offset, on-off-dash-seq) ]
  linewidth or lw or linewidths: float or sequence of floats
  lod: [True | False]
  norm: unknown
  offsets: float or sequence of floats
  picker: [None|float|boolean|callable]
  pickradius: unknown
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  urls: unknown
  visible: [True | False]
  zorder: any number

A :class:`~matplotlib.collections.Collection` instance is
returned.

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
semilogx

call signature::

  semilogx(*args, **kwargs)

Make a plot with log scaling on the *x* axis.

:func:`semilogx` supports all the keyword arguments of
:func:`~matplotlib.pyplot.plot` and
:meth:`matplotlib.axes.Axes.set_xscale`.

Notable keyword arguments:

  *basex*: scalar > 1
    base of the *x* logarithm

  *subsx*: [ None | sequence ]
    The location of the minor xticks; *None* defaults to
    autosubs, which depend on the number of decades in the
    plot; see :meth:`~matplotlib.axes.Axes.set_xscale` for
    details.

  *nonposx*: ['mask' | 'clip' ]
    non-positive values in *x* can be masked as
    invalid, or clipped to a very small positive number

The remaining valid kwargs are
:class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

.. seealso::

    :meth:`loglog`
        For example code and figure

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
semilogy

call signature::

  semilogy(*args, **kwargs)

Make a plot with log scaling on the *y* axis.

:func:`semilogy` supports all the keyword arguments of
:func:`~matplotlib.pylab.plot` and
:meth:`matplotlib.axes.Axes.set_yscale`.

Notable keyword arguments:

  *basey*: scalar > 1
    Base of the *y* logarithm

  *subsy*: [ None | sequence ]
    The location of the minor yticks; *None* defaults to
    autosubs, which depend on the number of decades in the
    plot; see :meth:`~matplotlib.axes.Axes.set_yscale` for
    details.

  *nonposy*: ['mask' | 'clip' ]
    non-positive values in *y* can be masked as
    invalid, or clipped to a very small positive number

The remaining valid kwargs are
:class:`~matplotlib.lines.Line2D` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  antialiased or aa: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color or c: any matplotlib color
  contains: a callable function
  dash_capstyle: ['butt' | 'round' | 'projecting']
  dash_joinstyle: ['miter' | 'round' | 'bevel']
  dashes: sequence of on/off ink in points
  data: 2D array
  drawstyle: [ 'default' | 'steps' | 'steps-pre' | 'steps-mid' | 'steps-post' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top']
  gid: an id string
  label: any string
  linestyle or ls: [ '-' | '--' | '-.' | ':' | 'None' | ' ' | '' ] and         any drawstyle in combination with a linestyle, e.g. 'steps--'.
  linewidth or lw: float value in points
  lod: [True | False]
  marker: [ '+' | '*' | ',' | '.' | '1' | '2' | '3' | '4'                  | '<' | '>' | 'D' | 'H' | '^' | '_' | 'd'                  | 'h' | 'o' | 'p' | 's' | 'v' | 'x' | '|'                  | TICKUP | TICKDOWN | TICKLEFT | TICKRIGHT                  | 'None' | ' ' | '' ]
  markeredgecolor or mec: any matplotlib color
  markeredgewidth or mew: float value in points
  markerfacecolor or mfc: any matplotlib color
  markersize or ms: float
  markevery: None | integer | (startind, stride)
  picker: float distance in points or callable pick function         ``fn(artist, event)``
  pickradius: float distance in points
  rasterized: [True | False | None]
  snap: unknown
  solid_capstyle: ['butt' | 'round' |  'projecting']
  solid_joinstyle: ['miter' | 'round' | 'bevel']
  transform: a :class:`matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  xdata: 1D array
  ydata: 1D array
  zorder: any number

.. seealso::

    :meth:`loglog`
        For example code and figure

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
setp


    matplotlib supports the use of :func:`setp` ("set property") and
    :func:`getp` to set and get object properties, as well as to do
    introspection on the object.  For example, to set the linestyle of a
    line to be dashed, you can do::

      >>> line, = plot([1,2,3])
      >>> setp(line, linestyle='--')

    If you want to know the valid types of arguments, you can provide the
    name of the property you want to set without a value::

      >>> setp(line, 'linestyle')
          linestyle: [ '-' | '--' | '-.' | ':' | 'steps' | 'None' ]

    If you want to see all the properties that can be set, and their
    possible values, you can do::

      >>> setp(line)
          ... long output listing omitted

    :func:`setp` operates on a single instance or a list of instances.
    If you are in query mode introspecting the possible values, only
    the first instance in the sequence is used.  When actually setting
    values, all the instances will be set.  E.g., suppose you have a
    list of two lines, the following will make both lines thicker and
    red::

      >>> x = arange(0,1.0,0.01)
      >>> y1 = sin(2*pi*x)
      >>> y2 = sin(4*pi*x)
      >>> lines = plot(x, y1, x, y2)
      >>> setp(lines, linewidth=2, color='r')

    :func:`setp` works with the matlab(TM) style string/value pairs or
    with python kwargs.  For example, the following are equivalent::

      >>> setp(lines, 'linewidth', 2, 'color', r')  # matlab style

      >>> setp(lines, linewidth=2, color='r')       # python style

---------------------------------------------------------------------------
show


    Show all the figures and enter the gtk mainloop

    This should be the last line of your script.  This function sets
    interactive mode to True, as detailed on
    http://matplotlib.sf.net/interactive.html

---------------------------------------------------------------------------
specgram

call signature::

  specgram(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
           window=mlab.window_hanning, noverlap=128,
           cmap=None, xextent=None, pad_to=None, sides='default',
           scale_by_freq=None, **kwargs)

Compute a spectrogram of data in *x*.  Data are split into
*NFFT* length segments and the PSD of each section is
computed.  The windowing function *window* is applied to each
segment, and the amount of overlap of each segment is
specified with *noverlap*.

Keyword arguments:

  *NFFT*: integer
      The number of data points used in each block for the FFT.
      Must be even; a power 2 is most efficient.  The default value is 256.

  *Fs*: scalar
      The sampling frequency (samples per time unit).  It is used
      to calculate the Fourier frequencies, freqs, in cycles per time
      unit. The default value is 2.

  *detrend*: callable
      The function applied to each segment before fft-ing,
      designed to remove the mean or linear trend.  Unlike in
      matlab, where the *detrend* parameter is a vector, in
      matplotlib is it a function.  The :mod:`~matplotlib.pylab`
      module defines :func:`~matplotlib.pylab.detrend_none`,
      :func:`~matplotlib.pylab.detrend_mean`, and
      :func:`~matplotlib.pylab.detrend_linear`, but you can use
      a custom function as well.

  *window*: callable or ndarray
      A function or a vector of length *NFFT*. To create window
      vectors see :func:`window_hanning`, :func:`window_none`,
      :func:`numpy.blackman`, :func:`numpy.hamming`,
      :func:`numpy.bartlett`, :func:`scipy.signal`,
      :func:`scipy.signal.get_window`, etc. The default is
      :func:`window_hanning`.  If a function is passed as the
      argument, it must take a data segment as an argument and
      return the windowed version of the segment.

  *noverlap*: integer
      The number of points of overlap between blocks.  The default value
      is 0 (no overlap).

  *pad_to*: integer
      The number of points to which the data segment is padded when
      performing the FFT.  This can be different from *NFFT*, which
      specifies the number of data points used.  While not increasing
      the actual resolution of the psd (the minimum distance between
      resolvable peaks), this can give more points in the plot,
      allowing for more detail. This corresponds to the *n* parameter
      in the call to fft(). The default is None, which sets *pad_to*
      equal to *NFFT*

  *sides*: [ 'default' | 'onesided' | 'twosided' ]
      Specifies which sides of the PSD to return.  Default gives the
      default behavior, which returns one-sided for real data and both
      for complex data.  'onesided' forces the return of a one-sided PSD,
      while 'twosided' forces two-sided.

  *scale_by_freq*: boolean
      Specifies whether the resulting density values should be scaled
      by the scaling frequency, which gives density in units of Hz^-1.
      This allows for integration over the returned frequency values.
      The default is True for MatLab compatibility.

  *Fc*: integer
    The center frequency of *x* (defaults to 0), which offsets
    the y extents of the plot to reflect the frequency range used
    when a signal is acquired and then filtered and downsampled to
    baseband.

  *cmap*:
    A :class:`matplotlib.cm.Colormap` instance; if *None* use
    default determined by rc

  *xextent*:
    The image extent along the x-axis. xextent = (xmin,xmax)
    The default is (0,max(bins)), where bins is the return
    value from :func:`mlab.specgram`

  *kwargs*:

    Additional kwargs are passed on to imshow which makes the
    specgram image

  Return value is (*Pxx*, *freqs*, *bins*, *im*):

  - *bins* are the time points the spectrogram is calculated over
  - *freqs* is an array of frequencies
  - *Pxx* is a len(times) x len(freqs) array of power
  - *im* is a :class:`matplotlib.image.AxesImage` instance

Note: If *x* is real (i.e. non-complex), only the positive
spectrum is shown.  If *x* is complex, both positive and
negative parts of the spectrum are shown.  This can be
overridden using the *sides* keyword argument.

**Example:**

.. plot:: mpl_examples/pylab_examples/specgram_demo.py

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
spy

call signature::

  spy(Z, precision=0, marker=None, markersize=None,
      aspect='equal', **kwargs)

``spy(Z)`` plots the sparsity pattern of the 2-D array *Z*.

If *precision* is 0, any non-zero value will be plotted;
else, values of :math:`|Z| > precision` will be plotted.

For :class:`scipy.sparse.spmatrix` instances, there is a
special case: if *precision* is 'present', any value present in
the array will be plotted, even if it is identically zero.

The array will be plotted as it would be printed, with
the first index (row) increasing down and the second
index (column) increasing to the right.

By default aspect is 'equal', so that each array element
occupies a square space; set the aspect kwarg to 'auto'
to allow the plot to fill the plot box, or to any scalar
number to specify the aspect ratio of an array element
directly.

Two plotting styles are available: image or marker. Both
are available for full arrays, but only the marker style
works for :class:`scipy.sparse.spmatrix` instances.

If *marker* and *markersize* are *None*, an image will be
returned and any remaining kwargs are passed to
:func:`~matplotlib.pyplot.imshow`; else, a
:class:`~matplotlib.lines.Line2D` object will be returned with
the value of marker determining the marker type, and any
remaining kwargs passed to the
:meth:`~matplotlib.axes.Axes.plot` method.

If *marker* and *markersize* are *None*, useful kwargs include:

* *cmap*
* *alpha*

.. seealso::

    :func:`~matplotlib.pyplot.imshow`
       For image options.

For controlling colors, e.g. cyan background and red marks,
use::

  cmap = mcolors.ListedColormap(['c','r'])

If *marker* or *markersize* is not *None*, useful kwargs include:

* *marker*
* *markersize*
* *color*

Useful values for *marker* include:

* 's'  square (default)
* 'o'  circle
* '.'  point
* ','  pixel

.. seealso::

    :func:`~matplotlib.pyplot.plot`
       For plotting options

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
stem

call signature::

  stem(x, y, linefmt='b-', markerfmt='bo', basefmt='r-')

A stem plot plots vertical lines (using *linefmt*) at each *x*
location from the baseline to *y*, and places a marker there
using *markerfmt*.  A horizontal line at 0 is is plotted using
*basefmt*.

Return value is a tuple (*markerline*, *stemlines*,
*baseline*).

.. seealso::

    `this document`__
       for details

    :file:`examples/pylab_examples/stem_plot.py`
       for a demo

__ http://www.mathworks.com/access/helpdesk/help/techdoc/ref/stem.html

Additional kwargs: hold = [True|False] overrides default hold state
---------------------------------------------------------------------------
subplot


    Create a subplot command, creating axes with::

      subplot(numRows, numCols, plotNum)

    where *plotNum* = 1 is the first plot number and increasing *plotNums*
    fill rows first.  max(*plotNum*) == *numRows* * *numCols*

    You can leave out the commas if *numRows* <= *numCols* <=
    *plotNum* < 10, as in::

      subplot(211)    # 2 rows, 1 column, first (upper) plot

    ``subplot(111)`` is the default axis.

    New subplots that overlap old will delete the old axes.  If you do
    not want this behavior, use
    :meth:`matplotlib.figure.Figure.add_subplot` or the
    :func:`~matplotlib.pyplot.axes` command.  Eg.::

      from pylab import *
      plot([1,2,3])  # implicitly creates subplot(111)
      subplot(211)   # overlaps, subplot(111) is killed
      plot(rand(12), rand(12))
      subplot(212, axisbg='y') # creates 2nd subplot with yellow background

    Keyword arguments:

      *axisbg*:
        The background color of the subplot, which can be any valid
        color specifier.  See :mod:`matplotlib.colors` for more
        information.

      *polar*:
        A boolean flag indicating whether the subplot plot should be
        a polar projection.  Defaults to False.

      *projection*:
        A string giving the name of a custom projection to be used
        for the subplot. This projection must have been previously
        registered. See :func:`matplotlib.projections.register_projection`

    .. seealso::

        :func:`~matplotlib.pyplot.axes`
            For additional information on :func:`axes` and
            :func:`subplot` keyword arguments.

        :file:`examples/pylab_examples/polar_scatter.py`
            For an example

    **Example:**

    .. plot:: mpl_examples/pylab_examples/subplot_demo.py


---------------------------------------------------------------------------
subplot_tool


    Launch a subplot tool window for *targetfig* (default gcf).

    A :class:`matplotlib.widgets.SubplotTool` instance is returned.

---------------------------------------------------------------------------
subplots_adjust


    call signature::

      subplots_adjust(left=None, bottom=None, right=None, top=None,
                      wspace=None, hspace=None)

    Tune the subplot layout via the
    :class:`matplotlib.figure.SubplotParams` mechanism.  The parameter
    meanings (and suggested defaults) are::

      left  = 0.125  # the left side of the subplots of the figure
      right = 0.9    # the right side of the subplots of the figure
      bottom = 0.1   # the bottom of the subplots of the figure
      top = 0.9      # the top of the subplots of the figure
      wspace = 0.2   # the amount of width reserved for blank space between subplots
      hspace = 0.2   # the amount of height reserved for white space between subplots

    The actual defaults are controlled by the rc file

---------------------------------------------------------------------------
table

call signature::

  table(cellText=None, cellColours=None,
        cellLoc='right', colWidths=None,
        rowLabels=None, rowColours=None, rowLoc='left',
        colLabels=None, colColours=None, colLoc='center',
        loc='bottom', bbox=None):

Add a table to the current axes.  Returns a
:class:`matplotlib.table.Table` instance.  For finer grained
control over tables, use the :class:`~matplotlib.table.Table`
class and add it to the axes with
:meth:`~matplotlib.axes.Axes.add_table`.

Thanks to John Gill for providing the class and table.

kwargs control the :class:`~matplotlib.table.Table`
properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  contains: a callable function
  figure: a :class:`matplotlib.figure.Figure` instance
  fontsize: a float in points
  gid: an id string
  label: any string
  lod: [True | False]
  picker: [None|float|boolean|callable]
  rasterized: [True | False | None]
  snap: unknown
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  visible: [True | False]
  zorder: any number
---------------------------------------------------------------------------
text

call signature::

  text(x, y, s, fontdict=None, **kwargs)

Add text in string *s* to axis at location *x*, *y*, data
coordinates.

Keyword arguments:

  *fontdict*:
    A dictionary to override the default text properties.
    If *fontdict* is *None*, the defaults are determined by your rc
    parameters.

  *withdash*: [ False | True ]
    Creates a :class:`~matplotlib.text.TextWithDash` instance
    instead of a :class:`~matplotlib.text.Text` instance.

Individual keyword arguments can be used to override any given
parameter::

    text(x, y, s, fontsize=12)

The default transform specifies that text is in data coords,
alternatively, you can specify text in axis coords (0,0 is
lower-left and 1,1 is upper-right).  The example below places
text in the center of the axes::

    text(0.5, 0.5,'matplotlib',
         horizontalalignment='center',
         verticalalignment='center',
         transform = ax.transAxes)

You can put a rectangular box around the text instance (eg. to
set a background color) by using the keyword *bbox*.  *bbox* is
a dictionary of :class:`matplotlib.patches.Rectangle`
properties.  For example::

 text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))

Valid kwargs are :class:`matplotlib.text.Text` properties:

  alpha: float (0.0 transparent through 1.0 opaque)
  animated: [True | False]
  axes: an :class:`~matplotlib.axes.Axes` instance
  backgroundcolor: any matplotlib color
  bbox: rectangle prop dict
  clip_box: a :class:`matplotlib.transforms.Bbox` instance
  clip_on: [True | False]
  clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]
  color: any matplotlib color
  contains: a callable function
  family or fontfamily or fontname or name: [ FONTNAME | 'serif' | 'sans-serif' | 'cursive' | 'fantasy' | 'monospace' ]
  figure: a :class:`matplotlib.figure.Figure` instance
  fontproperties or font_properties: a :class:`matplotlib.font_manager.FontProperties` instance
  gid: an id string
  horizontalalignment or ha: [ 'center' | 'right' | 'left' ]
  label: any string
  linespacing: float (multiple of font size)
  lod: [True | False]
  multialignment: ['left' | 'right' | 'center' ]
  picker: [None|float|boolean|callable]
  position: (x,y)
  rasterized: [True | False | None]
  rotation: [ angle in degrees | 'vertical' | 'horizontal' ]
  rotation_mode: unknown
  size or fontsize: [ size in points | 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' ]
  snap: unknown
  stretch or fontstretch: [ a numeric value in range 0-1000 | 'ultra-condensed' | 'extra-condensed' | 'condensed' | 'semi-condensed' | 'normal' | 'semi-expanded' | 'expanded' | 'extra-expanded' | 'ultra-expanded' ]
  style or fontstyle: [ 'normal' | 'italic' | 'oblique']
  text: string or anything printable with '%s' conversion.
  transform: :class:`~matplotlib.transforms.Transform` instance
  url: a url string
  variant or fontvariant: [ 'normal' | 'small-caps' ]
  verticalalignment or va or ma: [ 'center' | 'top' | 'bottom' | 'baseline' ]
  visible: [True | False]
  weight or fontweight: [ a numeric value in range 0-1000 | 'ultralight' | 'light' | 'normal' | 'regular' | 'book' | 'medium' | 'roman' | 'semibold' | 'demibold' | 'demi' | 'bold' | 'heavy' | 'extra bold' | 'black' ]
  x: float
  y: float
  zorder: any number
---------------------------------------------------------------------------
thetagrids


    Set/Get the theta locations of the gridlines and ticklabels.

    If no arguments are passed, return a tuple (*lines*, *labels*)
    where *lines* is an array of radial gridlines
    (:class:`~matplotlib.lines.Line2D` instances) and *labels* is an
    array of tick labels (:class:`~matplotlib.text.Text` instances)::

      lines, labels = thetagrids()

    Otherwise the syntax is::

      lines, labels = thetagrids(angles, labels=None, fmt='%d', frac = 1.1)

    set the angles at which to place the theta grids (these gridlines
    are equal along the theta dimension).

    *angles* is in degrees.

    *labels*, if not *None*, is a len(angles) list of strings of the
    labels to use at each angle.

    If *labels* is *None*, the labels will be ``fmt%angle``.

    *frac* is the fraction of the polar axes radius at which to place
    the label (1 is the edge). Eg. 1.05 is outside the axes and 0.95
    is inside the axes.

    Return value is a list of tuples (*lines*, *labels*):

      - *lines* are :class:`~matplotlib.lines.Line2D` instances

      - *labels* are :class:`~matplotlib.text.Text` instances.

    Note that on input, the *labels* argument is a list of strings,
    and on output it is a list of :class:`~matplotlib.text.Text`
    instances.

    Examples::

      # set the locations of the radial gridlines and labels
      lines, labels = thetagrids( range(45,360,90) )

      # set the locations and labels of the radial gridlines and labels
      lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )

---------------------------------------------------------------------------
title


    Set the title of the current axis to *s*.

    Default font override is::

      override = {'fontsize': 'medium',
                  'verticalalignment': 'bottom',
                  'horizontalalignment': 'center'}

    .. seealso::

       :func:`~matplotlib.pyplot.text`
           for information on how override and the optional args work.

---------------------------------------------------------------------------
xlabel


    Set the *x* axis label of the current axis to *s*

    Default override is::

      override = {
          'fontsize'            : 'small',
          'verticalalignment'   : 'top',
          'horizontalalignment' : 'center'
          }

    .. seealso::

        :func:`~matplotlib.pyplot.text`
            For information on how override and the optional args work

---------------------------------------------------------------------------
xlim


    Set/Get the xlimits of the current axes::

      xmin, xmax = xlim()   # return the current xlim
      xlim( (xmin, xmax) )  # set the xlim to xmin, xmax
      xlim( xmin, xmax )    # set the xlim to xmin, xmax

    If you do not specify args, you can pass the xmin and xmax as
    kwargs, eg.::

      xlim(xmax=3) # adjust the max leaving min unchanged
      xlim(xmin=1) # adjust the min leaving max unchanged

    The new axis limits are returned as a length 2 tuple.


---------------------------------------------------------------------------
xticks


    Set/Get the xlimits of the current ticklocs and labels::

      # return locs, labels where locs is an array of tick locations and
      # labels is an array of tick labels.
      locs, labels = xticks()

      # set the locations of the xticks
      xticks( arange(6) )

      # set the locations and labels of the xticks
      xticks( arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue') )

    The keyword args, if any, are :class:`~matplotlib.text.Text`
    properties. For example, to rotate long labels::

      xticks( arange(12), calendar.month_name[1:13], rotation=17 )

---------------------------------------------------------------------------
ylabel


    Set the *y* axis label of the current axis to *s*.

    Defaults override is::

        override = {
           'fontsize'            : 'small',
           'verticalalignment'   : 'center',
           'horizontalalignment' : 'right',
           'rotation'='vertical' : }

    .. seealso::

        :func:`~matplotlib.pyplot.text`
            For information on how override and the optional args
            work.

---------------------------------------------------------------------------
ylim


    Set/Get the ylimits of the current axes::

      ymin, ymax = ylim()   # return the current ylim
      ylim( (ymin, ymax) )  # set the ylim to ymin, ymax
      ylim( ymin, ymax )    # set the ylim to ymin, ymax

    If you do not specify args, you can pass the *ymin* and *ymax* as
    kwargs, eg.::

      ylim(ymax=3) # adjust the max leaving min unchanged
      ylim(ymin=1) # adjust the min leaving max unchanged

    The new axis limits are returned as a length 2 tuple.

---------------------------------------------------------------------------
yticks


    Set/Get the ylimits of the current ticklocs and labels::

      # return locs, labels where locs is an array of tick locations and
      # labels is an array of tick labels.
      locs, labels = yticks()

      # set the locations of the yticks
      yticks( arange(6) )

      # set the locations and labels of the yticks
      yticks( arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue') )

    The keyword args, if any, are :class:`~matplotlib.text.Text`
    properties. For example, to rotate long labels::

      yticks( arange(12), calendar.month_name[1:13], rotation=45 )

