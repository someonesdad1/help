*arduino*

|ard_Serial|
|ard_LiquidCrystal|
|ard_SoftTimers|
|ard_types|
|ard_cli|
|ard_FastLED|
|ard_LiquidCrystal|
|ard_models|
|ard_control_structures|
|ard_string_functions|
|ard_analog_io|
|ard_digital_io|
|ard_other_stuff|
|ard_math|
|ard_characters|
|ard_bits_and_bytes|
|ard_interrupts|
|ard_EEPROM|

----------------------------------------------------------------------
EEPROM                                               *ard_EEPROM*

The EEPROM is typically 1k to 4k bytes in size on the Arduinos.  It is byte-oriented and
each byte has a lifetime of about 1e5 writes; because of this, try to use the EEPROM.put()
method to update EEPROM, as it only writes a byte if the value is changed.

You can use custom structs to store your data, meaning it's one function call to read it
back.  Write your data with EEPROM.put(address, object), get it with EEPROM.get(address,
object).  For important data, you can use a 32 bit CRC given below.

https://docs.arduino.cc/learn/programming/eeprom-guide

#include <EEPROM.h>

Uno, Nano   1 kB of EEPROM storage
Mega        4 kB of EEPROM storage

read()
    byte read(int)
    Locations that have never been written contain 0xff.
write()
    void write(int address, byte value)
    Takes 33 ms to complete and 1e5 write life for each byte.
update()
    void update(int address, byte value)
    Same as write() but only writes data if the new byte is different.
get()
    reference_to_object get(int address, object)
    object can be a primitive type (e.g. float) or a custom structure.
put()
    reference_to_object put(int address, object)
    This uses update() for the data, so an EEPROM byte is not overwritten unless it has
    changed.
EEPROM[]
    reference_to_cell EEPROM[int address]
    Way to read and write EEPROM locations like an array.
length()
    unsigned int length()
    Returns number of cells in EEPROM.

Examples

    - Write data to a specific byte address of the EEPROM memory
        EEPROM.write(address, value);
    - Read data from a specific byte address of the EEPROM memory
        EEPROM.read(address);
    - Clear the EEPROM
        - for loop
            for (int i = 0 ; i < EEPROM.length() ; i++) {
                EEPROM.write(i, 0);
            }
        - while loop
            int i = 0;
            while (i < EEPROM.length()) {
                EEPROM[i] = 0;
                i++;
            }
        - do-while loop
            int i = 0;
            do {
                EEPROM[i] = 0;
                i++;
            } while (i < EEPROM.length());
    - CRC to check EEPROM
        From https://docs.arduino.cc/learn/programming/eeprom-guide/

        #include <Arduino.h>
        #include <EEPROM.h>

        typedef unsigned long ulong;

        void setup() {
            Serial.begin(9600);
            while (!Serial) {}
            // Print length of data to run CRC on
            Serial.print("EEPROM length: ");
            Serial.println(EEPROM.length());
            //Print the result of calling eeprom_crc()
            Serial.print("CRC32 of EEPROM data: 0x");
            Serial.println(eeprom_crc(), HEX);
        }

        void loop() {}

        ulong eeprom_crc(void) {
            const ulong crc_table[16] = {
                0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
                0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
            };
            ulong crc = ~0L;
            for (int index = 0 ; index < EEPROM.length()  ; ++index) {
                crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4);
                crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4);
                crc = ~crc;
            }
            return crc;
        }

    EEPROM get and put methods
        /* This shows how to use the EEPROM.get() method

            To pre-set the EEPROM data, run the example sketch eeprom_put.  This sketch will run without
            it, however, the values shown will be shown from what ever is already on the EEPROM.  This may
            cause the serial object to print out a large string of garbage if there is no null character
            inside one of the strings loaded.  */

        #include <EEPROM.h>

        void setup() {  // Read a float from EEPROM
            float f = 0.0f;
            int eepromAddress = 0;
            Serial.begin(9600);
            while (!Serial) {}
            Serial.print("Read float from EEPROM: ");

            //Get the float data from the EEPROM at position 'eeAddress'
            EEPROM.get(eeAddress, f);

            // This may print 'ovf, nan' if the data inside the EEPROM is not a valid float.
            Serial.println(f, 3);
            // Since get returns a reference, you can also use
            Serial.print(EEPROM.get(eeAddress, f));

            // Get can be used with custom structures too
            CustomStructure();
        }

        struct MyCustomStruct {
            float field1;
            byte field2;
            char name[10];
        };

        void CustomStructure(void) {
            int eeAddress = sizeof(float); // Move address to the next byte after float 'f'.
            MyCustomStruct custom;
            EEPROM.get(eeAddress, customVar);
            Serial.println("Read custom object from EEPROM: ");
            Serial.println(customVar.field1);
            Serial.println(customVar.field2);
            Serial.println(customVar.name);
        }

        void loop() {}
----------------------------------------------------------------------
Liquid Crystal displays                              *ard_LiquidCrystal*

https://docs.arduino.cc/libraries/liquidcrystal/
I've only included the details relevant to the display from Proto Supplies
#include <LiquidCrystal.h>

∇ = optional argument

LiquidCrystal()
    Creates a variable of type LiquidCrystal. The display can be controlled using 4 or 8
    data lines. If the former, omit the pin numbers for d0 to d3 and leave those lines
    unconnected. The RW pin can be tied to ground instead of connected to a pin on the
    Arduino; if so, omit it from this function's parameters.

    LiquidCrystal(rs, enable, d4, d5, d6, d7)
    LiquidCrystal(rs, rw, enable, d4, d5, d6, d7)
    LiquidCrystal(rs, enable, d0, d1, d2, d3, d4, d5, d6, d7)
    LiquidCrystal(rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7)

    rs: the number of the Arduino pin that is connected to the RS pin on the LCD

    rw: the number of the Arduino pin that is connected to the RW pin on the LCD
    (optional)

    enable: the number of the Arduino pin that is connected to the enable pin on the LCD

    d0, d1, d2, d3, d4, d5, d6, d7: the numbers of the Arduino pins that are connected to
    the corresponding data pins on the LCD. d0, d1, d2, and d3 are optional; if omitted,
    the LCD will be controlled using only the four data lines (d4, d5, d6, d7).

begin(num_cols, num_rows, ∇charsize)
    Initializes the interface to the LCD screen, and specifies the dimensions (width and
    height) of the display.  begin() needs to be called before any other LCD library
    commands.

    charsize (optional): the number of dots the display has per character:
        LCD_5x8DOTS for 5x8 [default]
        LCD_5x10DOTS for 5x10

clear()
    Clears the LCD screen and positions the cursor in the upper-left corner.

home()
    Positions the cursor in the upper-left of the LCD. That is, use that location in
    outputting subsequent text to the display. To also clear the display, use the clear()
    function instead.

setCursor(col, row)
    Position the LCD cursor; that is, set the location at which subsequent text written to
    the LCD will be displayed.

write(data)
    Write a character to the LCD.

print(data, ∇BASE)
    Prints text to the LCD.
    data:  char, byte, int, long, or string
    BASE (optional):  BIN, DEC, OCT, HEX

    print("word 1\nword 2") results in one line, not two.  The carriage return is four
    stacked horizontal lines.

cursor()
    Display the LCD cursor: an underscore (line) at the position to which the next
    character will be written.

noCursor()
    Hides the LCD cursor.

blink()
    Display the blinking LCD cursor. If used in combination with the cursor() function,
    the result will depend on the particular display.

noBlink()
    Turns off the blinking LCD cursor.

display()
    Turns on the LCD display, after it's been turned off with noDisplay(). This will
    restore the text (and cursor) that was on the display.

noDisplay()
    Turns off the LCD display, without losing the text currently shown on it.

scrollDisplayLeft()
    Scrolls the contents of the display (text and cursor) one space to the left.

scrollDisplayRight()
    Scrolls the contents of the display (text and cursor) one space to the right.

autoscroll()
    Turns on automatic scrolling of the LCD. This causes each character output to the
    display to push previous characters over by one space. If the current text direction
    is left-to-right (the default), the display scrolls to the left; if the current
    direction is right-to-left, the display scrolls to the right. This has the effect of
    outputting each new character to the same location on the LCD.

noAutoscroll()
    Turns off automatic scrolling of the LCD.

leftToRight()
    Set the direction for text written to the LCD to left-to-right, the default. This
    means that subsequent characters written to the display will go from left to right,
    but does not affect previously-output text.

rightToLeft()
    Set the direction for text written to the LCD to right-to-left (the default is
    left-to-right). This means that subsequent characters written to the display will go
    from right to left, but does not affect previously-output text.

createChar(num, data)

    Create a custom character (glyph) for use on the LCD. Up to eight characters of 5x8
    pixels are supported (numbered 0 to 7). The appearance of each custom character is
    specified by an array of eight bytes, one for each row. The five least significant
    bits of each byte determine the pixels in that row. To display a custom character on
    the screen, write() its number.

    When referencing custom character "0", if it is not in a variable, you need to cast it
    to a byte, otherwise the compiler throws an error.

    num: which character to create (0 to 7)

    data: the character's pixel data

    Example:

            byte smiley[8] = {
                B00000,
                B10001,
                B00000,
                B00000,
                B10001,
                B01110,
                B00000,
            };
            void setup() {
                lcd.createChar(0, smiley);
                lcd.begin(16, 2);  
                lcd.write(byte(0));
            }
            void loop() {
            }

----------------------------------------------------------------------
Soft Timers                                          *ard_SoftTimers*

Simple timers that don't block, don't cause interrupts, and must be polled to find when
they have timed out.

Time is a ulong in ms

millis()
    Is an Arduino timer that returns a ulong in ms since the program started.  Wraps
    around in 2**32/(10**3*3600*24) = 49.71 days.
micros()
    Is an Arduino timer that returns a ulong in μs since the program started.  Wraps
    around in 2**32/(10**6*3600*24) = 71.5828 minutes.  The Arduino documentation
    states that you shouldn't use micros() for longer than a 16 ms delay.

Each instance of SoftTimer() has:
    - Pointer to callback function

Constructors
    SoftTimer() uses the built-in millis() Arduino timer.
    SoftTimer(CounterFunctionPointer iCntFuncPtr)
        Use iCntFuncPtr = &millis() to get a millisecond timer
        Use iCntFuncPtr = &micros() to get a microsecond timer

void reset()     
    Resets the internal counter of the timer:  mStartTime = mCntFuncPtr()();
ulong getElapsedTime()
    Returns ms since last reset
ulong getRemainingTime()
    Returns ms until timer times out
void setTimeOutTime(ulong iTimeOutTime_ms)
    Set time in ms at which hasTimedOut() will return true.
ulong getTimeOutTime()
    Return time in ms which hasTimedOut() will return true.
bool hasTimedOut()
    Return true if elapsed time is >= the set timeout time.
double getProgess()
    Current timer progress fraction on [0, 1].  Note 0 == 1.

Examples
--------

Battery charger:  Run the charging routine once every 24 hours.  Monitor the battery
voltage every hour.

    SoftTimer timer_daily_charging;
    SoftTimer timer_hourly_measure;

    void setup() {
        timer_daily_charging.setTimeOutTime(uint(24*3600*1000));  // 24 hours
        timer_daily_charging.reset();                             // Start the counter
        timer_hourly_measure.setTimeOutTime(uint(3600*1000));     // 1 hour
        timer_hourly_measure.reset();                             // Start the counter
    }
    void loop() {
        if (timer_hourly_measure.hasTimedOut()) {
            Measure_battery_voltage();
            Display_battery_voltage_state();
            timer_hourly_measure.reset();
        }
        if (timer_daily_charging.hasTimedOut()) {
            timer_daily_charging.reset();
            Start_daily_charging_cycle();
            Measure_battery_voltage();
            Display_battery_voltage_state();
            timer_hourly_measure.reset();
    }
    
----------------------------------------------------------------------
Types, constants, conversions, scopes                *ard_types*

Types
    bool    1-byte of memory, true or false
    boolean non-standard type alias for bool
    void    Only for function declarations
    Integers
        1-byte
            byte            1-byte unsigned (0 to 255)
            char            signed, at least 1-byte (-128 to 127)
            unsigned char   unsigned, at least 1-byte
        2-bytes
            short           2-byte signed integer (-32768 to 32767)
            int             2-byte signed integer(-32768 to 32767)
            unsigned int    2-byte unsigned integer (0 to 65536)
            word            2-byte unsigned integer (0 to 65536)
        4-bytes
            long            4-byte signed integer (-2147483648 to 2147483647)
            unsigned long   4-byte unsigned integer (0 to 4294967296)
        size_t              Data type able to represent the size of an object in bytes
    Floating point
        double              4-byte float (same as float)
        float               4-byte float (about 6 decimal digits)
                            range:  ±3.4028235E+38
        For fastest performance, avoid floating point arithmetic.
    Strings
        string          char arrays
        String()        Another string type that takes more memory
    arrays
        int myInts[6];
        int myPins[] = {2, 4, 8, 3, 6};
        int mySensVals[6] = {2, 4, -8, 3, 2};
        char message[6] = "hello";

Constants
    HIGH
        OUTPUT pin:  > 3 V for 5 V boards, > 2 V for 3.3 V boards
        INPUT pin:  5 V on 5 V boards, 3.3 V on 3.3 V boards
    LOW
        OUTPUT pin:  > 3 V for 5 V boards, > 2 V for 3.3 V boards
        INPUT pin:  100 MΩ input R, so a floating input is unpredictable; you need a 10 kΩ 
                    pullup or pulldown
    INPUT
        Pins in high impedance state, 100 MΩ
    OUTPUT
        Low impedance state; can source or sink up to 40 mA.
    INPUT_PULLUP
        Use this as pinMode second argument to use internal pull-ups.  Do not connect these pins
        to negative voltages or voltages above the positive rail.
    LED_BUILTIN
        Usually pin 13.
    true, false
        Boolean values
    Integer constants
        B1111011    Only works with 8-bit values
        07          Octal
        0x7b        Hex
        7u or 7U    Unsigned
        7l or 7L    Long
        7ul or 7UL  Unsigned long

Conversions
    byte(x), char(x), float(x), int(x), long(x), word(x)
    Converts a value x of any type to the indicated type

Variable scope & qualifiers
    const       Makes a variable read-only
    scope       Global, local, and in for loops
    static      Local variables in a function that persist their values between calls.
                Created and initialized the first time the function is called.
    volatile    Variables with this modifier can be changed by things other than the code section
                it appears in.

        For ints and longs, use the ATOMIC_BLOCK macro when changing them to avoid an 
        interrupt changing the location, as the processors are 8-bit.  See the documentation
        details.  Also read about interrupts, ISRs, and the attachInterrupt() function.

Utilities
    PROGMEM
        Modifier to variable declaration to put variable in flash rather than SRAM.  Should only
        be used with datatypes defined in pgmspace.h; it is included automatically in modern IDEs.

        const datatype variable[] PROGMEM = {};     // Use this form
        const PROGMEM datatype variable[] = {};     // Or this form
        const datatype PROGMEM variable[] = {};     // Do not use this form

        See https://reference.arduino.cc/reference/cs/language/variables/utilities/progmem
        for details, as once stored, you also need to read them back out of flash.
    sizeof(variable)
        Returns the number of bytes in a variable type, or the number of bytes occupied by an array.

----------------------------------------------------------------------
Arduino models                                      *ard_models*

Nano
    Logic level                     5 V
    Input voltage (recommended)     7-12 V
    Input voltage (limits)          6-20 V
    Digital I/O pins                14 (6 provide 8-bit PWM)
    Analog input pins               8 (10-bits)
    Analog reference pin            1
    DC current per I/O pin (max)    40 mA
    DC current per I/O pin (rec)    20 mA
    DC current for package          200 mA
    Flash                           16 kB (2 used by bootloader)
    SRAM                            1 kB
    EEPROM                          512 B
    Clock                           16 MHz
    Size                            19x43 mm

Mega 2560
    Logic level                     5 V
    Digital I/O pins                54 (15 provide 8-bit PWM)
    Analog input pins               16 (10-bits)
    Serial ports                    4
    Clock                           16 MHz

Uno
    Logic level                     5 V
    Input voltage (recommended)     7-12 V
    Input voltage (limits)          6-20 V
    Digital I/O pins                14 (6 provide 8-bit PWM)
    Analog input pins               6 (10-bits)
    Analog reference pin            1
    DC current per I/O pin (rec)    20 mA
    DC current for 3.3 V pin        50 mA
    DC current for package          200 mA
    Flash                           32 kB
    SRAM                            2 kB
    EEPROM                          1024 B
    Clock                           16 MHz
    Size                            19x43 mm
    
Fairly good page:
https://www.electroniclinic.com/arduino-uno-vs-nano-vs-mega-pinout-and-technical-specifications/

----------------------------------------------------------------------
Control structures                                  *ard_control_structures*

Same as C:
    if, if/else, for, switch/case, while, do while, break, continue,
    return, goto, #define, #include

Constants
    HIGH, LOW
    INPUT, OUTPUT, INPUT_PULLUP
    LED_BUILTIN
    true, false

Types
    const 
    void 
    boolean (1 byte)
    char, unsigned char (1 byte)
    byte (8-bit unsigned number) e.g.:  byte b = B10010;
    word (16-bit unsigned Uno, 32-bit Due)
    short (16-bit signed)
    float (4 bytes ==> 6-7 decimal digits)
    double (same as float; 8 bytes on Due)

    strings:  null-terminated as in C
    string objects:  more memory, but includes numerous member functions
        (see |ard_string_functions|)

Integers
    Signed are 2's complement
    int and unsigned int (16 bits)
    long and unsigned long (32 bits)

----------------------------------------------------------------------
String Functions                            *ard_string_functions*

String
charAt
compartTo
concat
c_str
endsWith
equals
equalsIgnoreCase
getBytes
indexOf
lastIndexOf
length
remove
replace
reserve
setCharAt
startsWith
substring
toCharArray
toDouble
toInt
toFloat
toLowerCase
toUpperCase
trim

Character tests
    isAlpha()
    isAlphaNumeric()
    isAscii()
    isControl()
    isDigit()
    isGraph()
    isHexadecimalDigit()
    isLowerCase()
    isPrintable()
    isPunct()
    isSpace()
    isUpperCase()
    isWhitespace()

String()
    String(val)
        val:  string char, byte, int, long, unsigned int, unsigned long, float, double
    String(val, base) val must be integer, base DEC HEX BIN OCT
    String(val, decimalPlaces) if val is float or double

charAt()
compartTo()
concat()
c_str()
endsWith()
equals()
equalsIgnoreCase()
getBytes()
indexOf()
lastIndexOf()
length()
remove()
replace()
reserve()
setCharAt()
startsWith()
substring()
toCharArray()
toDouble()
toInt()
toFloat()
toLowerCase()
toUpperCase()
trim()

----------------------------------------------------------------------
Analog I/O                                  *ard_analog_io*

analogRead(pin) --> int
    Read from analog pin, such as A0 or A1.  Returns 10-bit number between
    0 and 1023.

    For best accuracy, use an analog reference between 0 and 5 V on the AREF pin.  
    Then the measured value is reading*AREF/1024.

analogReference(choice) --> void

    Configures the analog reference value; this is the value used as the top of the input
    range.  On Nano, Mega, and Uno.  choice can be
        DEFAULT         5 V
        INTERNAL        A built-in ref, not on Mega
        INTERNAL1V1     Built-in 1.1 V on Mega only
        INTERNAL2V56    Built-in 2.56 V ref on Mega only
        EXTERNAL        On pin AREF (must be 0 to 5 V)

analogWrite(int pin, int value) --> void
    Writes an analog value to a pin, which causes a PWM output.

    PWM functionality
        Uno (R3 & earlier), Nano, Mini:  3, 9, 10, 11: 490 Hz; 5, 6: 980 Hz
        Mega pins:  2-13, 44-46, all 490 Hz
        Value:  duty cycle from 0 (always off) to 255 (always on).

    Warning:  PWM outputs on pins 5 and 6 will have higher than expected
    duty cycles because of some functions that share the internal timer
    used for interrupts.  This will be noticed mostly at low duty cycle
    settings of 0 to 10 or so.

----------------------------------------------------------------------
Digital I/O                                 *ard_digital_io*

pinMode(pin, mode)
    Configure a digital pin.
    mode is INPUT, OUTPUT, INPUT_PULLUP.  INPUT explicitly disables the
    pull-up resistor.  The internal pull-ups are typically 20k to 50k.

    Pins default to inputs = 100 Mohm input impedance state.

    Pins configured as output can provide significant current (up to 40
    mA, but 20 mA recommended with 200 mA package limit).  Good practice
    is to use series resistors of 470 to 1k.

digitalRead(pin)
    Returns HIGH or LOW.

digitalWrite(pin, value)
    Writes HIGH or LOW to indicated pin.

    If pin is configured as an INPUT, it is recommended to use 
    pinMode(pin, INPUT_PULLUP) to enable the pull-up resistor.

    If you do not set a pin to OUTPUT and connect an LED, the LED can be
    dim because digitalWrite() will have enabled the internal pull-up,
    which acts like a current limiting resistor.

----------------------------------------------------------------------
Other stuff                                 *ard_other_stuff*

tone(pin, ulong freq_Hz [, ulong duration_ms])
    Generates a square wave > 31 Hz.
noTone(pin)
    Turns tone off.

pulseIn(int pin, int value [, ulong timeout])
    Reads a HIGH or LOW pulse on a pin.  If value is HIGH, function waits
    for a pin to go from LOW to HIGH, starts timing, then waits for the pin
    to go LOW again; returns a ulong of the length of the pulse in us (or 0
    if it timed out).  Works for 10 us to 3 minutes.

    pulseInLong() has same form, but is used in long pulse and
    interrupt-affected scenarios.  Cannot be used in noInterrupts()
    context.

shiftIn(), shiftOut()   Shifts in or out a byte of data.

delay(ulong ms)
delayMicroseconds(uint us)  Don't use if us > 16383 (use delay() instead)

ulong micros()   Returns us since current program started.  Overflows at
    about 70 minutes.
ulong millis()   Returns ms since current program started.  Overflows at
    about 50 days.

----------------------------------------------------------------------
Math                                        *ard_math*

abs(x)      Absolute value.  Do not use abs(x++).

constrain(x, a, b)  Constrain a number to within a range.  All data types
    allowed.  Do not use other functions in the paretheses.

map(value, fromLow, fromHigh, toLow, toHigh)
    Actual code:
    long map(long x, long in_min, long in_max, long out_min, long out_max) {
        return (x - in_min)*(out_max - out_min)/(in_max - in_min) + out_min;
    }

min(x, y), max(x, y)    Take any data types.  Avoid use of other functions
    in the parentheses when using max.

double pow(float base, float exponent)

sq(x)   Squares number x (can be any data type).  No functions inside
    parentheses.

double sqrt(x)   Square root of x (can be any data type).

double cos(float x)
double sin(float x)
double tan(float x)

long random(max)
long random(min, max)
    Pseudorandom number generator.  min is inclusive, max is exclusive.
randomSeed(ulong seed)

----------------------------------------------------------------------
Characters                                  *ard_characters*

isAlpha()
isAlphaNumeric()
isAscii()
isControl()
isDigit()
isGraph()
isHexadecimalDigit()
isLowerCase()
isPrintable()
isPunct()
isSpace()
isUpperCase()
isWhitespace()

----------------------------------------------------------------------
Bits and Bytes                              *ard_bits_and_bytes*

bit(n)
    Returns 2**n
bitClear(x, n)
    Returns x with bit n cleared
bitRead(x, n)
    Returns 0 or 1 of the value of bit n in x
bitSet(x, n)
    Write a 1 in bit n of x
bitWrite(x, n, b)
    Write b (0 or 1) to bit n of x.  n = 0 is the LSB.
highByte(x)
    Returns the second lowest byte of any type x.
lowByte()
    Returns the lowest byte of any type x.

----------------------------------------------------------------------
Interrupts                                  *ard_interrupts*

Overview:  https://gammon.com.au/interrupts

attachInterrupt()
detachInterrupt()
interrupts()
    Enables interrupts.  Same as sei() (sets interrupt flag).
noInterrupts()
    Disables interrupts.  Same as cli() (clears interrupt flag).

Interrupts for Atmega328 in prority order
     1  Reset
     2  External Interrupt Request 0  (pin D2)          (INT0_vect)
     3  External Interrupt Request 1  (pin D3)          (INT1_vect)
     4  Pin Change Interrupt Request 0 (pins D8 to D13) (PCINT0_vect)
     5  Pin Change Interrupt Request 1 (pins A0 to A5)  (PCINT1_vect)
     6  Pin Change Interrupt Request 2 (pins D0 to D7)  (PCINT2_vect)
     7  Watchdog Time-out Interrupt                     (WDT_vect)
     8  Timer/Counter2 Compare Match A                  (TIMER2_COMPA_vect)
     9  Timer/Counter2 Compare Match B                  (TIMER2_COMPB_vect)
    10  Timer/Counter2 Overflow                         (TIMER2_OVF_vect)
    11  Timer/Counter1 Capture Event                    (TIMER1_CAPT_vect)
    12  Timer/Counter1 Compare Match A                  (TIMER1_COMPA_vect)
    13  Timer/Counter1 Compare Match B                  (TIMER1_COMPB_vect)
    14  Timer/Counter1 Overflow                         (TIMER1_OVF_vect)
    15  Timer/Counter0 Compare Match A                  (TIMER0_COMPA_vect)
    16  Timer/Counter0 Compare Match B                  (TIMER0_COMPB_vect)
    17  Timer/Counter0 Overflow                         (TIMER0_OVF_vect)
    18  SPI Serial Transfer Complete                    (SPI_STC_vect)
    19  USART Rx Complete                               (USART_RX_vect)
    20  USART, Data Register Empty                      (USART_UDRE_vect)
    21  USART, Tx Complete                              (USART_TX_vect)
    22  ADC Conversion Complete                         (ADC_vect)
    23  EEPROM Ready                                    (EE_READY_vect)
    24  Analog Comparator                               (ANALOG_COMP_vect)
    25  2-wire Serial Interface  (I2C)                  (TWI_vect)
    26  Store Program Memory Ready                      (SPM_READY_vect)

----------------------------------------------------------------------
Serial Communications                       *ard_Serial*

Serial
    Uno, Nano:  0(TX), 1(RX)  Used for communication with computer
    Mega:  0(TX), 1(RX)
        Serial1:  18(TX), 19(RX)
        Serial2:  16(TX), 17(RX)
        Serial3:  14(TX), 15(RX)
    The TX/RX pins use TTL logic (5 or 3.3 V depending on board)

Function list
    if (Serial)
    available()
    availableForWrite()
    begin()
    end()
    find()
    findUntil()
    flush()
    parseFloat()
    parseInt()
    peek()
    print()
    println()
    read()
    readBytes()
    readBytesUntil()
    readString()
    readStringUntil()
    setTimeout()
    write()
    serialEvent()

Function details; ∇ means an optional argument.

if(Serial)
    Returns true if serial port is ready.

available()
    Return number of bytes in serial receive buffer which holds 64 bytes.

availableForWrite()
    Get the number of bytes (characters) available for writing in the serial buffer without
    blocking the write operation.

begin()
    Sets the data rate in bits per second (baud) for serial data transmission. For communicating
    with Serial Monitor, make sure to use one of the baud rates listed in the menu at the bottom
    right corner of its screen. You can, however, specify other rates - for example, to
    communicate over pins 0 and 1 with a component that requires a particular baud rate.

    An optional second argument configures the data, parity, and stop bits. The default is 8 data
    bits, no parity, one stop bit:
        SERIAL_5E1    SERIAL_5O2    SERIAL_6O1    SERIAL_7N2    SERIAL_8N1
        SERIAL_5E2    SERIAL_6E1    SERIAL_6O2    SERIAL_7O1    SERIAL_8N2
        SERIAL_5N1    SERIAL_6E2    SERIAL_7E1    SERIAL_7O2    SERIAL_8O1
        SERIAL_5N2    SERIAL_6N1    SERIAL_7E2    SERIAL_8E1    SERIAL_8O2
        SERIAL_5O1    SERIAL_6N2    SERIAL_7N1    SERIAL_8E2

end()
    Disables serial communication, allowing the RX and TX pins to be used for general input and
    output. To re-enable serial communication, call Serial.begin().

find(target, length∇) --> bool
    Serial.find() reads data from the serial buffer until the target is found. The function
    returns true if target is found, false if it times out.  target is string to search for
    (char).  length is the length of the target (size_t).

findUntil(target, terminal) --> bool
    Serial.findUntil() reads data from the serial buffer until a target string of given length or
    terminator string is found.  The function returns true if the target string is found, false if
    it times out.  

flush()
    Waits for the transmission of outgoing serial data to complete. (Prior to Arduino 1.0, this
    instead removed any buffered incoming serial data.)

parseFloat(lookahead∇, ignore∇) --> float
    Serial.parseFloat() returns the first valid floating point number from the Serial buffer.
    parseFloat() is terminated by the first character that is not a floating point number. The
    function terminates if it times out (see Serial.setTimeout()).  Both arguments are optional.  

    lookahead: the mode used to look ahead in the stream for a floating point number. Allowed data
    types: LookaheadMode. Allowed lookahead values:

        SKIP_ALL: all characters other than a minus sign, decimal point, or digits are ignored
        when scanning the stream for a floating point number. This is the default mode.

        SKIP_NONE: Nothing is skipped, and the stream is not touched unless the first waiting
        character is valid.

        SKIP_WHITESPACE: Only tabs, spaces, line feeds, and carriage returns are skipped.

    ignore: used to skip the indicated char in the search. Used for example to skip thousands
    divider. Allowed data types: char

parseInt(lookahead∇, ignore∇) --> long
    Looks for the next valid integer in the incoming serial. The function terminates if it times
    out (see Serial.setTimeout()).

    Serial.parseInt() inherits from the Stream utility class.

    Parsing stops when no characters have been read for a configurable time-out value, or a
    non-digit is read; if no valid digits were read when the time-out (see Serial.setTimeout())
    occurs, 0 is returned;

    Syntax
    Serial.parseInt()
    Serial.parseInt(lookahead)
    Serial.parseInt(lookahead, ignore)

    lookahead: the mode used to look ahead in the stream for an integer. Allowed data
    types: LookaheadMode. Allowed lookahead values:

        SKIP_ALL: all characters other than digits or a minus sign are ignored when
        scanning the stream for an integer. This is the default mode.

        SKIP_NONE: Nothing is skipped, and the stream is not touched unless the first
        waiting character is valid.

        SKIP_WHITESPACE: Only tabs, spaces, line feeds, and carriage returns are skipped.

    ignore: used to skip the indicated char in the search. Used for example to skip
    thousands divider. Allowed data types: char

peek() --> int
    Returns the next byte (character) of incoming serial data without removing it from the
    internal serial buffer. That is, successive calls to peek() will return the same character, as
    will the next call to read().  Returns -1 if no data is available.

print(val, format∇) --> size_t (number of bytes written)
    Prints data to the serial port as human-readable ASCII text. This command can take many forms.
    Numbers are printed using an ASCII character for each digit. Floats are similarly printed as
    ASCII digits, defaulting to two decimal places. Bytes are sent as a single character.
    Characters and strings are sent as is. Examples:

        Serial.print(78) gives "78"
        Serial.print(1.23456) gives "1.23"
        Serial.print('N') gives "N"
        Serial.print("Hello world.") gives "Hello world."
        Serial.print("27.4 \xc2\xb0C") gives "27.4 °C"

            Note the Arduino 2.3.4 IDE's serial monitor is Unicode aware, so you can use
            UTF-8 encodings to get the characters you want.

    An optional second parameter specifies the base (format) to use; permitted values are BIN
    (binary, or base 2), OCT (octal, or base 8), DEC (decimal, or base 10), HEX (hexadecimal, or
    base 16). For floating point numbers, this parameter specifies the number of decimal places to
    use. Examples:

        Serial.print(78, BIN) gives "1001110"
        Serial.print(78, OCT) gives "116"
        Serial.print(78, DEC) gives "78"
        Serial.print(78, HEX) gives "4E"
        Serial.print(1.23456, 0) gives "1"
        Serial.print(1.23456, 2) gives "1.23"
        Serial.print(1.23456, 4) gives "1.2346"

    You can pass flash-memory based strings to Serial.print() by wrapping them with F(). For
    example:

        Serial.print(F(“Hello World”))

    To send data without conversion to its representation as characters, use Serial.write().

println(val, format∇) --> size_t (number of bytes written)
    Same as print() except output following by \r\n.

read() --> int
    Reads a byte from the serial port and returns it or returns -1 if no data available.

readBytes(buffer, length) --> size_t (number of bytes placed in buffer)

    Serial.readBytes() reads characters from the serial port into a buffer. The function
    terminates if the determined length has been read, or it times out (see Serial.setTimeout()).

    Serial.readBytes() returns the number of characters placed in the buffer. A 0 means no valid
    data was found.

    Serial.readBytes() inherits from the Stream utility class.

    buffer: the buffer to store the bytes in (char[] or byte[])

    length: the number of bytes to read (int)

    Serial.readBytesUntil() reads characters from the serial buffer into an array. The function
    terminates if the terminator character is detected, the determined length has been read, or it
    times out (see Serial.setTimeout()). The function returns the characters up to the last
    character before the supplied terminator. The terminator itself is not returned in the buffer.

    Arguments:

        character : the character to search for (char)

        buffer: the buffer to store the bytes in (char[] or byte[])

        length : the number of bytes to read (int)

readString() --> char (a string read from the serial buffer)

    Serial.readString() reads characters from the serial buffer into a String. The function
    terminates if it times out (see setTimeout()).

    Serial.readString() inherits from the Stream utility class.

readStringUntil(terminator) --> char (a string read from the serial buffer)

    readStringUntil() reads characters from the serial buffer into a String. The function
    terminates if it times out (see setTimeout()).  Returns the entire String read from the serial
    buffer, up to but not including the terminator character

    terminator: the character to search for (char)

setTimeout(time) --> void

    Serial.setTimeout() sets the maximum milliseconds to wait for serial data. It defaults to 1000
    milliseconds.

    time : timeout duration in milliseconds (long).

    Functions that use the timeout value:
        Serial.find()
        Serial.findUntil()
        Serial.parseInt()
        Serial.parseFloat()
        Serial.readBytes()
        Serial.readBytesUntil()
        Serial.readString()
        Serial.readStringUntil()

write() --> size_t (number of bytes written)

    Writes binary data to the serial port. This data is sent as a byte or series of bytes; to send
    the characters representing the digits of a number use the print() function instead.

    Serial.write(val)
    Serial.write(str)
    Serial.write(buf, len)

        val: a value to send as a single byte
        str: a string to send as a series of bytes
        buf: an array to send as a series of bytes
        len: the number of bytes to be sent from the array

serialEvent() --> void

    Called when data is available. Use Serial.read() to capture this data.

    void serialEvent() {
        //statements
    }

    For boards with additional serial ports (see the list of available serial ports for each board
    on the Serial main page):

    void serialEvent1() {
        //statements
    }

    void serialEvent2() {
        //statements
    }

    void serialEvent3() {
        //statements
    }

----------------------------------------------------------------------
Command line interface                      *ard_cli*

I have the CLI tool /usr/local/bin/arduino-cli.exe named to be 'ard'.  Note it runs significantly
faster under cygwin than WSL.

Getting started:
    https://docs.arduino.cc/arduino-cli/getting-started/

arduino-cli config init
Config file written to: C:\Users\Don\AppData\Local\Arduino15\arduino-cli.yaml

----------------------------------------------------------------------
FastLED                                     *ard_FastLED*

FastLED library at https://github.com/FastLED/FastLED
Class reference at https://fastled.io/docs/class_c_fast_l_e_d.html

    Measured output to addressable LED on Mega from FastLED:  Captured a signal that was one
    change of state, going to the red output.  A 24 pulse packet was captured, which contains the
    three bytes of the RGB color, with the red 8 bits appearing first.  The frequency for two
    successive narrow pulses is 800 kHz.  Scope measurements: 0 to 4.6 V pulses, a wide pulse is
    880 ns wide and a narrow pulse is 250 ns.  Pulses have rise and fall times of 12 ns.  This
    pulse burst lasted 30 μs.

Here's a simple demo with a single addressable LED using an Arduino
    - Wire the LED on the IN side with 5 V , ground, and the connection to the data pine
      of the processor

    #include <FastLED.h>
    setup() {
        const byte num_LEDs = 1;
        const byte light_stick_data_pin = 2;
        CRGB light_stick_colors[num_LEDs];

        pinMode(light_stick_data_pin, OUTPUT);
        FastLED.addLeds<NEOPIXEL, light_stick_data_pin>(light_stick_colors, num_LEDs);
        FastLED.setBrightness(20);
        CRGB light_stick_colors[num_LEDs];
        for (byte i=0; i < num_LEDs; i++) {
            light_stick_colors[i] = CRGB::White;
        }
        FastLED.show();
        delay(100);
        FastLED.setBrightness(0);
        FastLED.show();
        delay(200);
        FastLED.setBrightness(20);
        FastLED.show();
        delay(100);
        FastLED.setBrightness(0);
        FastLED.show();
    }
    



void addListener(fl::EngineEvents::Listener *listener)

void removeListener(fl::EngineEvents::Listener *listener)

void setBrightness(uint8_t scale)
    Set the global brightness scaling.

uint8_t getBrightness()
    Get the current global brightness setting.

void setMaxPowerInVoltsAndMilliamps(uint8_t volts, uint32_t milliamps)
    Set the maximum power to be used, given in volts and milliamps.

void setMaxPowerInMilliWatts(uint32_t milliwatts)
    Set the maximum power to be used, given in milliwatts.

void show(uint8_t scale)
    Update all our controllers with the current led colors, using the passed in brightness.

void show()
    Update all our controllers with the current led colors.

void clear(bool writeData=false)
    Clear the LEDs, wiping the local array of data.

void clearData()
    Clear out the local data array.

void showColor(const struct CRGB &color, uint8_t scale)
    Set all LEDs on all controllers to the given color/scale.

void showColor(const struct CRGB &color)
    Set all LEDs on all controllers to the given color.

void delay(unsigned long ms)
    Delay for the given number of milliseconds.

void setTemperature(const struct CRGB &temp)
    Set a global color temperature.

void setCorrection(const struct CRGB &correction)
    Set a global color correction.

void setDither(uint8_t ditherMode=BINARY_DITHER)
    Set the dithering mode.

void setMaxRefreshRate(uint16_t refresh, bool constrain=false)
    Set the maximum refresh rate.

void countFPS(int nFrames=25)
    For debugging, this will keep track of time between calls to countFPS().

uint16_t getFPS()
    Get the number of frames/second being written out.

int count()
    Get how many controllers have been registered.

CLEDController & operator[](int x)
    Get a reference to a registered controller.

int size()
    Get the number of LEDs in the first controller.

CRGB * leds()
    Get a pointer to led data for the first controller.

CRGB is a struct representing an RGB pixel.  Uses HTML color names:
    AliceBlue            ForestGreen          MistyRose
    Amethyst             Fuchsia              Moccasin
    AntiqueWhite         Gainsboro            NavajoWhite
    Aqua                 GhostWhite           Navy
    Aquamarine           Gold                 OldLace
    Azure                Goldenrod            Olive
    Beige                Gray                 OliveDrab
    Bisque               Green                Orange
    Black                GreenYellow          OrangeRed
    BlanchedAlmond       Grey                 Orchid
    Blue                 Honeydew             PaleGoldenrod
    BlueViolet           HotPink              PaleGreen
    Brown                IndianRed            PaleTurquoise
    BurlyWood            Indigo               PaleVioletRed
    CadetBlue            Ivory                PapayaWhip
    Chartreuse           Khaki                PeachPuff
    Chocolate            Lavender             Peru
    Coral                LavenderBlush        Pink
    CornflowerBlue       LawnGreen            Plaid
    Cornsilk             LemonChiffon         Plum
    Crimson              LightBlue            PowderBlue
    Cyan                 LightCoral           Purple
    DarkBlue             LightCyan            Red
    DarkCyan             LightGoldenrodYellow RosyBrown
    DarkGoldenrod        LightGreen           RoyalBlue
    DarkGray             LightGrey            SaddleBrown
    DarkGreen            LightPink            Salmon
    DarkGrey             LightSalmon          SandyBrown
    DarkKhaki            LightSeaGreen        SeaGreen
    DarkMagenta          LightSkyBlue         Seashell
    DarkOliveGreen       LightSlateGray       Sienna
    DarkOrange           LightSlateGrey       Silver
    DarkOrchid           LightSteelBlue       SkyBlue
    DarkRed              LightYellow          SlateBlue
    DarkSalmon           Lime                 SlateGray
    DarkSeaGreen         LimeGreen            SlateGrey
    DarkSlateBlue        Linen                Snow
    DarkSlateGray        Magenta              SpringGreen
    DarkSlateGrey        Maroon               SteelBlue
    DarkTurquoise        MediumAquamarine     Tan
    DarkViolet           MediumBlue           Teal
    DeepPink             MediumOrchid         Thistle
    DeepSkyBlue          MediumPurple         Tomato
    DimGray              MediumSeaGreen       Turquoise
    DimGrey              MediumSlateBlue      Violet
    DodgerBlue           MediumSpringGreen    Wheat
    FairyLight           MediumTurquoise      White
    FairyLightNCC        MediumVioletRed      WhiteSmoke
    FireBrick            MidnightBlue         Yellow
    FloralWhite          MintCream            YellowGreen

----------------------------------------------------------------------
LiquidCrystal.h                             *ard_LiquidCrystal*

https://reference.arduino.cc/reference/en/libraries/liquidcrystal/

This library allows an Arduino board to control LiquidCrystal displays (LCDs) based on the Hitachi
HD44780 (or a compatible) chipset, which is found on most text-based LCDs. The library works with
in either 4- or 8-bit mode (i.e. using 4 or 8 data lines in addition to the rs, enable, and,
optionally, the rw control lines).

LiquidCrystal(rs, enable, d4, d5, d6, d7)
    rs = pin number connected to RS pin on LCD
    enable pin
    d4-d7 pins for data line

begin(width, height, charsize)
    Initializes the interface to the LCD screen, and specifies the dimensions (width and height)
    of the display. begin() needs to be called before any other LCD library commands.  charsize is
    LCD_5x8DOTS (default) or LCD_5x10DOTS for 5x10.

clear()
    Clears the LCD screen and positions the cursor in the upper-left corner.

home()
    Positions the cursor in the upper-left of the LCD. That is, use that location in outputting
    subsequent text to the display. To also clear the display, use the clear() function instead.

setCursor(col, row)
    Set the location at which subsequent text written to the LCD will be displayed.  0 is the
    first column, 0 is first row.

write(char)
    Write a character to the LCD.  Returns number of bytes written.

print(text)
    Prints text to the LCD.  text can be char, byte, int, long, or string.

cursor()
    Display the LCD cursor: an underscore (line) at the position to which the next character will
    be written.

noCursor()
    Hides the LCD cursor.

blink()
    Display the blinking LCD cursor. If used in combination with the cursor() function, the result
    will depend on the particular display.

noBlink()
    Turns off the blinking LCD cursor.

display()
    Turns on the LCD display, after it’s been turned off with noDisplay(). This will restore the
    text (and cursor) that was on the display.

noDisplay()
    Turns off the LCD display, without losing the text currently shown on it.

scrollDisplayLeft()
    Scrolls the contents of the display (text and cursor) one space to the left.

scrollDisplayRight()
    Scrolls the contents of the display (text and cursor) one space to the right.

autoscroll()
    Turns on automatic scrolling of the LCD. This causes each character output to the display to
    push previous characters over by one space. If the current text direction is left-to-right
    (the default), the display scrolls to the left; if the current direction is right-to-left, the
    display scrolls to the right. This has the effect of outputting each new character to the same
    location on the LCD.

noAutoscroll()
    Turns off automatic scrolling of the LCD.

leftToRight()
    Set the direction for text written to the LCD to left-to-right, the default. This means that
    subsequent characters written to the display will go from left to right, but does not affect
    previously-output text.

rightToLeft()
    Set the direction for text written to the LCD to right-to-left (the default is left-to-right).
    This means that subsequent characters written to the display will go from right to left, but
    does not affect previously-output text.

createChar(num, data)
    Create a custom character (glyph) for use on the LCD. Up to eight characters of 5x8 pixels are
    supported (numbered 0 to 7). The appearance of each custom character is specified by an array
    of eight bytes, one for each row. The five least significant bits of each byte determine the
    pixels in that row. To display a custom character on the screen, write() its number.

    Note:  When referencing custom character "0", if it is not in a variable, you need to cast it
    as a byte, otherwise the compiler throws an error.

    num:  which character to create (0 to 7)
    data: the character’s pixel data

    Example:
        #include <LiquidCrystal.h>
        LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
        byte smiley[8] = {
            B00000,
            B10001,
            B00000,
            B00000,
            B10001,
            B01110,
            B00000,
        };
        void setup() {
            lcd.createChar(0, smiley);
            lcd.begin(16, 2);
            lcd.write(byte(0));
        }
        void loop() {}

vim: tw=90
