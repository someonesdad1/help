*arduino*

|ard_FastLED|
|ard_LiquidCrystal|
|ard_models|
|ard_control_structures|
|ard_string_functions|
|ard_analog_io|
|ard_digital_io|
|ard_other_stuff|
|ard_math|
|ard_characters|
|ard_bits_and_bytes|
|ard_interrupts|
|ard_Serial|

----------------------------------------------------------------------
Arduino models                                      *ard_models*

Nano
    Logic level                     5 V
    Input voltage (recommended)     7-12 V
    Input voltage (limits)          6-20 V
    Digital I/O pins                14 (6 provide 8-bit PWM)
    Analog input pins               8 (10-bits)
    Analog reference pin            1
    DC current per I/O pin (max)    40 mA
    DC current per I/O pin (rec)    20 mA
    DC current for package          200 mA
    Flash                           16 kB (2 used by bootloader)
    SRAM                            1 kB
    EEPROM                          512 B
    Clock                           16 MHz
    Size                            19x43 mm

Mega 2560
    Logic level                     5 V
    Digital I/O pins                54 (15 provide 8-bit PWM)
    Analog input pins               16 (10-bits)
    Serial ports                    4
    Clock                           16 MHz

Uno
    Logic level                     5 V
    Input voltage (recommended)     7-12 V
    Input voltage (limits)          6-20 V
    Digital I/O pins                14 (6 provide 8-bit PWM)
    Analog input pins               6 (10-bits)
    Analog reference pin            1
    DC current per I/O pin (rec)    20 mA
    DC current for 3.3 V pin        50 mA
    DC current for package          200 mA
    Flash                           32 kB
    SRAM                            2 kB
    EEPROM                          1024 B
    Clock                           16 MHz
    Size                            19x43 mm
    
Fairly good page:
https://www.electroniclinic.com/arduino-uno-vs-nano-vs-mega-pinout-and-technical-specifications/

----------------------------------------------------------------------
Control structures                                  *ard_control_structures*

Same as C:
    if, if/else, for, switch/case, while, do while, break, continue,
    return, goto, #define, #include

Constants
    HIGH, LOW
    INPUT, OUTPUT, INPUT_PULLUP
    LED_BUILTIN
    true, false

Types
    const 
    void 
    boolean (1 byte)
    char, unsigned char (1 byte)
    byte (8-bit unsigned number) e.g.:  byte b = B10010;
    word (16-bit unsigned Uno, 32-bit Due)
    short (16-bit signed)
    float (4 bytes ==> 6-7 decimal digits)
    double (same as float; 8 bytes on Due)

    strings:  null-terminated as in C
    string objects:  more memory, but includes numerous member functions
        (see |ard_string_functions|)

Integers
    Signed are 2's complement
    int and unsigned int (16 bits)
    long and unsigned long (32 bits)

----------------------------------------------------------------------
String Functions                            *ard_string_functions*

String()
charAt()
compartTo()
concat()
c_str()
endsWith()
equals()
equalsIgnoreCase()
getBytes()
indexOf()
lastIndexOf()

----------------------------------------------------------------------
Analog I/O                                  *ard_analog_io*

analogRead(pin)
    Read from analog pin, such as A0 or A1.  Returns 10-bit number between
    0 and 1023.

analogReference(type)
    Configures the analog reference value.  type can be (Mega, Uno, etc.)
        DEFAULT         5 V
        INTERNAL        A built-in ref, not on Mega
        INTERNAL1V1     Built-in 1.1 V on Mega only
        INTERNAL2V56    Built-in 2.56 V ref on Mega only
        EXTERNAL        On pin AREF (must be 0 to 5 V)

analogWrite(int pin, int value)
    PWM functionality
    Uno, Nano pins:  3, 5, 6, 9, 10, 11
    Mega pins:  2-13, 44-46
    value = duty cycle from 0 (always off) to 255 (always on).

    Warning:  PWM outputs on pins 5 and 6 will have higher than expected
    duty cycles because of some functions that share the internal timer
    used for interrupts.  This will be noticed mostly at low duty cycle
    settings of 0 to 10 or so.

----------------------------------------------------------------------
Digital I/O                                 *ard_digital_io*

pinMode(pin, mode)
    Configure a digital pin.
    mode is INPUT, OUTPUT, INPUT_PULLUP.  INPUT explicitly disables the
    pull-up resistor.  The internal pull-ups are typically 20k to 50k.

    Pins default to inputs = 100 Mohm input impedance state.

    Pins configured as output can provide significant current (up to 40
    mA, but 20 mA recommended with 200 mA package limit).  Good practice
    is to use series resistors of 470 to 1k.

digitalRead(pin)
    Returns HIGH or LOW.

digitalWrite(pin, value)
    Writes HIGH or LOW to indicated pin.

    If pin is configured as an INPUT, it is recommended to use 
    pinMode(pin, INPUT_PULLUP) to enable the pull-up resistor.

    If you do not set a pin to OUTPUT and connect an LED, the LED can be
    dim because digitalWrite() will have enabled the internal pull-up,
    which acts like a current limiting resistor.

----------------------------------------------------------------------
Other stuff                                 *ard_other_stuff*

tone(pin, ulong freq_Hz [, ulong duration_ms])
    Generates a square wave > 31 Hz.
noTone(pin)
    Turns tone off.

pulseIn(int pin, int value [, ulong timeout])
    Reads a HIGH or LOW pulse on a pin.  If value is HIGH, function waits
    for a pin to go from LOW to HIGH, starts timing, then waits for the pin
    to go LOW again; returns a ulong of the length of the pulse in us (or 0
    if it timed out).  Works for 10 us to 3 minutes.

    pulseInLong() has same form, but is used in long pulse and
    interrupt-affected scenarios.  Cannot be used in noInterrupts()
    context.

shiftIn(), shiftOut()   Shifts in or out a byte of data.

delay(ulong ms)
delayMicroseconds(uint us)  Don't use if us > 16383 (use delay() instead)

ulong micros()   Returns us since current program started.  Overflows at
    about 70 minutes.
ulong millis()   Returns ms since current program started.  Overflows at
    about 50 days.

----------------------------------------------------------------------
Math                                        *ard_math*

abs(x)      Absolute value.  Do not use abs(x++).

constrain(x, a, b)  Constrain a number to within a range.  All data types
    allowed.  Do not use other functions in the paretheses.

map(value, fromLow, fromHigh, toLow, toHigh)
    Actual code:
    long map(long x, long in_min, long in_max, long out_min, long out_max) {
        return (x - in_min)*(out_max - out_min)/(in_max - in_min) + out_min;
    }

min(x, y), max(x, y)    Take any data types.  Avoid use of other functions
    in the parentheses when using max.

double pow(float base, float exponent)

sq(x)   Squares number x (can be any data type).  No functions inside
    parentheses.

double sqrt(x)   Square root of x (can be any data type).

double cos(float x)
double sin(float x)
double tan(float x)

long random(max)
long random(min, max)
    Pseudorandom number generator.  min is inclusive, max is exclusive.
randomSeed(ulong seed)

----------------------------------------------------------------------
Characters                                  *ard_characters*

isAlpha()
isAlphaNumeric()
isAscii()
isControl()
isDigit()
isGraph()
isHexadecimalDigit()
isLowerCase()
isPrintable()
isPunct()
isSpace()
isUpperCase()
isWhitespace()

----------------------------------------------------------------------
Bits and Bytes                              *ard_bits_and_bytes*

bit()
bitClear()
bitRead()
bitSet()
bitWrite()
highByte()
lowByte()

----------------------------------------------------------------------
Interrupts                                  *ard_interrupts*

attachInterrupt()
detachInterrupt()
interrupts()
noInterrupts()

----------------------------------------------------------------------
Serial Communications                       *ard_Serial*

Serial
    Uno, Nano:  0(TX), 1(RX)  Used for communication with computer
    Mega:  0(TX), 1(RX)
        Serial1:  18(TX), 19(RX)
        Serial2:  16(TX), 17(RX)
        Serial3:  14(TX), 15(RX)
    The TX/RX pins use TTL logic (5 or 3.3 V depending on board)


if(Serial)
available()
availableForWrite()
begin()
end()
find()
findUntil()
flush()
parseFloat()
parseInt()
peek()
print()
println()
read()
readBytes()
readBytesUntil()
readString()
readStringUntil()
setTimeout()
write()
serialEvent()

----------------------------------------------------------------------
FastLED                                     *ard_FastLED*

FastLED library at https://github.com/FastLED/FastLED
Class reference at https://fastled.io/docs/class_c_fast_l_e_d.html

    Measured output to addressable LED on Mega from FastLED:  Captured a signal that was one
    change of state, going to the red output.  A 24 pulse packet was captured, which contains the
    three bytes of the RGB color, with the red 8 bits appearing first.  The frequency for two
    successive narrow pulses is 800 kHz.  Scope measurements: 0 to 4.6 V pulses, a wide pulse is
    880 ns wide and a narrow pulse is 250 ns.  Pulses have rise and fall times of 12 ns.  This
    pulse burst lasted 30 μs.

void addListener(fl::EngineEvents::Listener *listener)

void removeListener(fl::EngineEvents::Listener *listener)

void setBrightness(uint8_t scale)
    Set the global brightness scaling.

uint8_t getBrightness()
    Get the current global brightness setting.

void setMaxPowerInVoltsAndMilliamps(uint8_t volts, uint32_t milliamps)
    Set the maximum power to be used, given in volts and milliamps.

void setMaxPowerInMilliWatts(uint32_t milliwatts)
    Set the maximum power to be used, given in milliwatts.

void show(uint8_t scale)
    Update all our controllers with the current led colors, using the passed in brightness.

void show()
    Update all our controllers with the current led colors.

void clear(bool writeData=false)
    Clear the LEDs, wiping the local array of data.

void clearData()
    Clear out the local data array.

void showColor(const struct CRGB &color, uint8_t scale)
    Set all LEDs on all controllers to the given color/scale.

void showColor(const struct CRGB &color)
    Set all LEDs on all controllers to the given color.

void delay(unsigned long ms)
    Delay for the given number of milliseconds.

void setTemperature(const struct CRGB &temp)
    Set a global color temperature.

void setCorrection(const struct CRGB &correction)
    Set a global color correction.

void setDither(uint8_t ditherMode=BINARY_DITHER)
    Set the dithering mode.

void setMaxRefreshRate(uint16_t refresh, bool constrain=false)
    Set the maximum refresh rate.

void countFPS(int nFrames=25)
    For debugging, this will keep track of time between calls to countFPS().

uint16_t getFPS()
    Get the number of frames/second being written out.

int count()
    Get how many controllers have been registered.

CLEDController & operator[](int x)
    Get a reference to a registered controller.

int size()
    Get the number of LEDs in the first controller.

CRGB * leds()
    Get a pointer to led data for the first controller.

CRGB is a struct representing an RGB pixel.  Uses HTML color names:
    AliceBlue            ForestGreen          MistyRose
    Amethyst             Fuchsia              Moccasin
    AntiqueWhite         Gainsboro            NavajoWhite
    Aqua                 GhostWhite           Navy
    Aquamarine           Gold                 OldLace
    Azure                Goldenrod            Olive
    Beige                Gray                 OliveDrab
    Bisque               Green                Orange
    Black                GreenYellow          OrangeRed
    BlanchedAlmond       Grey                 Orchid
    Blue                 Honeydew             PaleGoldenrod
    BlueViolet           HotPink              PaleGreen
    Brown                IndianRed            PaleTurquoise
    BurlyWood            Indigo               PaleVioletRed
    CadetBlue            Ivory                PapayaWhip
    Chartreuse           Khaki                PeachPuff
    Chocolate            Lavender             Peru
    Coral                LavenderBlush        Pink
    CornflowerBlue       LawnGreen            Plaid
    Cornsilk             LemonChiffon         Plum
    Crimson              LightBlue            PowderBlue
    Cyan                 LightCoral           Purple
    DarkBlue             LightCyan            Red
    DarkCyan             LightGoldenrodYellow RosyBrown
    DarkGoldenrod        LightGreen           RoyalBlue
    DarkGray             LightGrey            SaddleBrown
    DarkGreen            LightPink            Salmon
    DarkGrey             LightSalmon          SandyBrown
    DarkKhaki            LightSeaGreen        SeaGreen
    DarkMagenta          LightSkyBlue         Seashell
    DarkOliveGreen       LightSlateGray       Sienna
    DarkOrange           LightSlateGrey       Silver
    DarkOrchid           LightSteelBlue       SkyBlue
    DarkRed              LightYellow          SlateBlue
    DarkSalmon           Lime                 SlateGray
    DarkSeaGreen         LimeGreen            SlateGrey
    DarkSlateBlue        Linen                Snow
    DarkSlateGray        Magenta              SpringGreen
    DarkSlateGrey        Maroon               SteelBlue
    DarkTurquoise        MediumAquamarine     Tan
    DarkViolet           MediumBlue           Teal
    DeepPink             MediumOrchid         Thistle
    DeepSkyBlue          MediumPurple         Tomato
    DimGray              MediumSeaGreen       Turquoise
    DimGrey              MediumSlateBlue      Violet
    DodgerBlue           MediumSpringGreen    Wheat
    FairyLight           MediumTurquoise      White
    FairyLightNCC        MediumVioletRed      WhiteSmoke
    FireBrick            MidnightBlue         Yellow
    FloralWhite          MintCream            YellowGreen

----------------------------------------------------------------------
LiquidCrystal.h                             *ard_LiquidCrystal*

https://reference.arduino.cc/reference/en/libraries/liquidcrystal/

This library allows an Arduino board to control LiquidCrystal displays (LCDs) based on the Hitachi
HD44780 (or a compatible) chipset, which is found on most text-based LCDs. The library works with
in either 4- or 8-bit mode (i.e. using 4 or 8 data lines in addition to the rs, enable, and,
optionally, the rw control lines).

LiquidCrystal(rs, enable, d4, d5, d6, d7)
    rs = pin number connected to RS pin on LCD
    enable pin
    d4-d7 pins for data line

begin(width, height, charsize)
    Initializes the interface to the LCD screen, and specifies the dimensions (width and height)
    of the display. begin() needs to be called before any other LCD library commands.  charsize is
    LCD_5x8DOTS (default) or LCD_5x10DOTS for 5x10.

clear()
    Clears the LCD screen and positions the cursor in the upper-left corner.

home()
    Positions the cursor in the upper-left of the LCD. That is, use that location in outputting
    subsequent text to the display. To also clear the display, use the clear() function instead.

setCursor(col, row)
    Set the location at which subsequent text written to the LCD will be displayed.  0 is the
    first column, 0 is first row.

write(char)
    Write a character to the LCD.  Returns number of bytes written.

print(text)
    Prints text to the LCD.  text can be char, byte, int, long, or string.

cursor()
    Display the LCD cursor: an underscore (line) at the position to which the next character will
    be written.

noCursor()
    Hides the LCD cursor.

blink()
    Display the blinking LCD cursor. If used in combination with the cursor() function, the result
    will depend on the particular display.

noBlink()
    Turns off the blinking LCD cursor.

display()
    Turns on the LCD display, after it’s been turned off with noDisplay(). This will restore the
    text (and cursor) that was on the display.

noDisplay()
    Turns off the LCD display, without losing the text currently shown on it.

scrollDisplayLeft()
    Scrolls the contents of the display (text and cursor) one space to the left.

scrollDisplayRight()
    Scrolls the contents of the display (text and cursor) one space to the right.

autoscroll()
    Turns on automatic scrolling of the LCD. This causes each character output to the display to
    push previous characters over by one space. If the current text direction is left-to-right
    (the default), the display scrolls to the left; if the current direction is right-to-left, the
    display scrolls to the right. This has the effect of outputting each new character to the same
    location on the LCD.

noAutoscroll()
    Turns off automatic scrolling of the LCD.

leftToRight()
    Set the direction for text written to the LCD to left-to-right, the default. This means that
    subsequent characters written to the display will go from left to right, but does not affect
    previously-output text.

rightToLeft()
    Set the direction for text written to the LCD to right-to-left (the default is left-to-right).
    This means that subsequent characters written to the display will go from right to left, but
    does not affect previously-output text.

createChar(num, data)
    Create a custom character (glyph) for use on the LCD. Up to eight characters of 5x8 pixels are
    supported (numbered 0 to 7). The appearance of each custom character is specified by an array
    of eight bytes, one for each row. The five least significant bits of each byte determine the
    pixels in that row. To display a custom character on the screen, write() its number.

    Note:  When referencing custom character "0", if it is not in a variable, you need to cast it
    as a byte, otherwise the compiler throws an error.

    num:  which character to create (0 to 7)
    data: the character’s pixel data

    Example:
        #include <LiquidCrystal.h>
        LiquidCrystal lcd(12, 11, 5, 4, 3, 2);
        byte smiley[8] = {
            B00000,
            B10001,
            B00000,
            B00000,
            B10001,
            B01110,
            B00000,
        };
        void setup() {
            lcd.createChar(0, smiley);
            lcd.begin(16, 2);
            lcd.write(byte(0));
        }
        void loop() {}
