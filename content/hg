*hg*

|hg_Commands|
|hg_Architecture|
|hg_Branching|
|hg_Tags|
|hg_Queues|
|hg_Cloning|
|hg_Guerrilla_SCM|
|hg_Dons_aliases|

Mecurial revision control system        http://mercurial.selenic.com/

[mr] Reference book:  "Mercurial:  The Definitive Guide" by Bryan O'Sullivan

---------------------------------------------------------------------------
Don's aliases & tips                                    *hg_Dons_aliases*

hg st --rev X
    Shows status-type display of file changes between current & rev X

.                   Status
..                  Status (show everything)
wd = wdiff          Visual diff of changes with Meld
kd = kdiff          Visual diff of changes with kdiff3
l                   One line log summary
tree                Short ASCII graphical tree picture

Exporting the most recent commit:
    hg export tip 

To import data from other VCS systems:
    Set 'convert =' under [extensions] in .hgrc
  This makes the 'hg convert' command available.  Then to get a
  Mercurial repository from a Subversion repository:
    hg convert http://python-nose.googlecode.com/svn/trunk

  The other systems supported are Subversion, CVS, git, darcs, Bazaar,
  Monotone, Arch, and Mercurial.  For Subversion, converting a big
  repository can be slow; see Appendix A in [mr] for how to use the
  svnsync command to speed things up.

---------------------------------------------------------------------------
Git stuff
    (Ref: http://www-cs-students.stanford.edu/~blynn/gitmagic/book.pdf)

git is another popular DVCS system.  Mercurial can pull from git
repositories if you use the hg-git plugin for Mercurial:

    hg clone http://bitbucket.org/durin42/hg-git/

---------------------------------------------------------------------------
Architecture                                            *hg_Architecture*

Is a distributed RCS tool, not a centralized one.  Each user has a complete
copy of the revisions, at least when they cloned their copy from the
server.  This allows independent, parallel development, then merging later.

When your copy of the revisioned directory is committed, its local .hg
directory is updated with the change information (the new changeset is 
recorded).  If you're working with a larger team, you can push your changes
to a server that everyone has access to.  This lets others update their
stuff with your changes.

Getting started:
    Make a new directory, cd to it, and populate it with files
    hg init
    hg add      # Adds all files recursively
    hg ci -m "Initial checkin"

    --> Now all files that weren't ignored are checked into the
    repository.  You can always get back to this point (and subsequent
    commit points) whenever you want.

Mercurial makes experimentation simple; here's the pattern:
    cd to the parent directory you want to clone
    hg clone parent child
    cd child
    
    Now you do whatever work you want and perform tests, etc.  If you
    don't like the results, just delete the child directory.
    Otherwise, push them back to the original:
        <you're working in the child directory>
        hg ci -m "I like these changes"
        hg push
    Now the parent repository is updated with your changes.
    Alternately:
        hg ci -m "I like these changes"
        cd ../parent
        hg pull ../child
    
Here are some tools that work with Mercurial:
    http://mercurial.selenic.com/wiki/OtherTools
    Most appear to need PyGTK

Here's a tutorial:
    http://mercurial.selenic.com/wiki/Tutorial

To ignore files:
    .hgignore file      http://mercurial.selenic.com/wiki/.hgignore
        Allows you to define regexps for files to ignore
        Put 'syntax: glob' as the first line to use plain file
        globbing.

---------------------------------------------------------------------------
Tasks

Make an existing directory tracked with Mercurial
    cd mydir
    hg init
    hg add .                        # Add all files recursively
    hg forget files_to_forget...    # Remove files you don't want tracked
    hg ci -m "Initial checkin"

See what has changed
    hg status
        ?   Untracked files
        A   Added files
        !   Missing files
        R   Removed files

Make a new cloned directory for experimentation:
    hg clone  .   ../my_new_directory
    cd ../my_new_directory
    <Do your work>
    If you don't like the changes, just delete the directory.  Otherwise,
    to push the changes back to the original directory:
        hg ci -m "I like these changes"
        hg push
    Now the original directory is sync'd with the experimental directory.
    You can delete the experimental directory if you wish.

You made a mistake before a commit; how to undo a change:
    hg revert file

    If you're not sure what will happen, use the -n option to show what
    will happen.

If you construct a directory, make it a repository, then populate it with
files, you may do things like 'hg add .' which adds everything.  Go ahead 
and do so; then you can go through the structure and 'hg rm' what you don't
want; you also build your .hgignore file.  DON'T EDIT FILES WHEN YOU WANT
THOSE EDITS TO BE SAVED.  Then when everything is as you want, do a 
'rm -rf .hg' and re-initialize Mercurial for that directory and executed
'hg add'.  Everything will be as you want and pristine.

If you accidentally commit, but e.g. forgot a file, you can execute ONE
(and only one) rollback to undo the commit:
    hg rollback
        Once a rollback is done, that's it -- there are no more stored
        transactions.

To get a repository from the web:
    hg clone http://bitbucket.org/bos/hgbook

To label a revision using a symbolic name ("tag")
    hg tag v1.0

    Use the -l option to make a tag local (i.e., it will never be pushed or
    pulled).  This can be useful with tags such as "Problem first seen
    here".

File globbing and regexps
    hgcmd 'glob:*.py'
        Finds python files in current dir.  Note glob: isn't needed, but it
        never hurts.
    hgcmd 'glob:**.py'
        Finds python files in current dir and all subdirectories.
    hgcmd 'glob:**[nr-t]'
        Match a character class, with ranges.  ! negates the class.
    hgcmd 'glob:**.{in,py}'
        Match a set of subpatterns

    Or, you can change to python regexps:
        hgcmd 're:.*.py'
            Note the regexps are anchored to the beginning of the line.

Handy additions to ~/.hgrc

    # Shows use of templates for the glog command
    [defaults]
    glog = --template 'changeset:   {rev}:{node|short} {tags}\nsummary: {desc|firstline|fill68|tabindent|tabindent}\n\n'

    [ui]
    username = donp <donp@gdssw.com>
    editor = c:/cygwin/home/don/bin/vim/vim71/vim.exe
    style = compact

    [extensions]
    # Lets you use glog command
    hgext.graphlog =
    # Lets you use the extdiff command
    extdiff =
    # Use color in commands
    color =

    [diff]
    # When doing a diff, use git output form
    git = True

    [alias]
    # Use a GUI for a diff
    wdiff = extdiff -p c:/bin/WinMerge/WinMergeU.exe

    [color]
    # Note you can use bold, underline, italic
    status.modified = yellow bold
    status.added = green bold
    status.removed = red bold
    status.deleted = red
    status.unknown = blue bold 
    status.ignored = black bold

    diff.diffline = bold
    diff.extended = cyan bold
    diff.file_a = red bold
    diff.file_b = green bold
    diff.hunk = yellow bold
    diff.deleted = red bold
    diff.inserted = green bold
    diff.changed = white bold
    diff.trailingwhitespace = bold red_background

---------------------------------------------------------------------------
Commands                                            *hg_Commands*

Basic commands:
    add        add the specified files on the next commit
    annotate   show changeset information by line for each file
    clone      make a copy of an existing repository
    commit     commit the specified files or all outstanding changes
    diff       diff repository (or selected files)
    export     dump the header and diffs for one or more changesets
    forget     forget the specified files on the next commit
    init       create a new repository in the given directory
    log        show revision history of entire repository or files
    merge      merge working directory with another revision
    pull       pull changes from the specified source
    push       push changes to the specified destination
    remove     remove the specified files on the next commit
    serve      export the repository via HTTP
    status     show changed files in the working directory
    summary    summarize working directory state
    update     update working directory

Other commands:
    addremove    add all new files, delete all missing files
    archive      create an unversioned archive of a repository revision
    backout      reverse effect of earlier changeset
    bisect       subdivision search of changesets
    branch       set or show the current branch name
    branches     list repository named branches
    bundle       create a changegroup file
    cat          output the current or given revision of files
    copy         mark files as copied for the next commit
    grep         search for a pattern in specified files and revisions
    heads        show current repository heads or show branch heads
    help         show help for a given topic or a help overview
    identify     identify the working copy or specified revision
    import       import an ordered set of patches
    incoming     show new changesets found in source
    locate       locate files matching specific patterns
    manifest     output the current or given revision of the project manifest
    outgoing     show changesets not found in the destination
    parents      show the parents of the working directory or revision
    paths        show aliases for remote repositories
    recover      roll back an interrupted transaction
    rename       rename files; equivalent of copy + remove
    resolve      various operations to help finish a merge
    revert       restore individual files or directories to an earlier state
    rollback     roll back the last transaction
    root         print the root (top) of the current working directory
    showconfig   show combined config settings from all hgrc files
    tag          add one or more tags for the current or given revision
    tags         list repository tags
    tip          show the tip revision
    unbundle     apply one or more changegroup files
    verify       verify the integrity of the repository
    version      output version and copyright information
    config       Configuration Files
    dates        Date Formats
    patterns     File Name Patterns
    environment  Environment Variables
    revisions    Specifying Single Revisions
    multirevs    Specifying Multiple Revisions
    diffs        Diff Formats
    templating   Template Usage
    urls         URL Paths
    extensions   Using additional features

---------------------------------------------------------------------------
Command details

hg add [OPTION]... [FILE]...

add the specified files on the next commit

    Schedule files to be version controlled and added to the repository.

    The files will be added to the repository at the next commit. To undo an
    add before that, see hg forget.

    If no names are given, add all files to the repository.

options:

 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns
 -n --dry-run  do not perform actions, just print output

--------------------------------------------------------

hg addremove [OPTION]... [FILE]...

add all new files, delete all missing files

    Add all new files and remove all missing files from the repository.

    New files are ignored if they match any of the patterns in .hgignore. As
    with add, these changes take effect at the next commit.

    Use the -s/--similarity option to detect renamed files. With a parameter
    greater than 0, this compares every removed file with every added file and
    records those similar enough as renames. This option takes a percentage
    between 0 (disabled) and 100 (files must be identical) as its parameter.
    Detecting renamed files this way can be expensive.

options:

 -s --similarity  guess renamed files by similarity (0<=s<=100)
 -I --include     include names matching the given patterns
 -X --exclude     exclude names matching the given patterns
 -n --dry-run     do not perform actions, just print output

--------------------------------------------------------

hg annotate [-r REV] [-f] [-a] [-u] [-d] [-n] [-c] [-l] FILE...

aliases: blame

show changeset information by line for each file

    List changes in files, showing the revision id responsible for each line

    This command is useful for discovering when a change was made and by whom.

    Without the -a/--text option, annotate will avoid processing files it
    detects as binary. With -a, annotate will annotate the file anyway,
    although the results will probably be neither useful nor desirable.

options:

 -r --rev          annotate the specified revision
    --no-follow    don't follow copies and renames
 -a --text         treat all files as text
 -u --user         list the author (long with -v)
 -f --file         list the filename
 -d --date         list the date (short with -q)
 -n --number       list the revision number (default)
 -c --changeset    list the changeset
 -l --line-number  show line number at the first appearance
 -I --include      include names matching the given patterns
 -X --exclude      exclude names matching the given patterns

--------------------------------------------------------

hg archive [OPTION]... DEST

create an unversioned archive of a repository revision

    By default, the revision used is the parent of the working directory; use
    -r/--rev to specify a different revision.

    To specify the type of archive to create, use -t/--type. Valid types are:

    "files"  a directory full of files (default)
    "tar"    tar archive, uncompressed
    "tbz2"   tar archive, compressed using bzip2
    "tgz"    tar archive, compressed using gzip
    "uzip"   zip archive, uncompressed
    "zip"    zip archive, compressed using deflate

    The exact name of the destination archive or directory is given using a
    format string; see 'hg help export' for details.

    Each member added to an archive file has a directory prefix prepended. Use
    -p/--prefix to specify a format string for the prefix. The default is the
    basename of the archive, with suffixes removed.

options:

    --no-decode  do not pass files through decoders
 -p --prefix     directory prefix for files in archive
 -r --rev        revision to distribute
 -t --type       type of distribution to create
 -I --include    include names matching the given patterns
 -X --exclude    exclude names matching the given patterns

--------------------------------------------------------

hg backout [OPTION]... [-r] REV

reverse effect of earlier changeset

    Commit the backed out changes as a new changeset. The new changeset is a
    child of the backed out changeset.

    If you backout a changeset other than the tip, a new head is created. This
    head will be the new tip and you should merge this backout changeset with
    another head.

    The --merge option remembers the parent of the working directory before
    starting the backout, then merges the new head with that changeset
    afterwards. This saves you from doing the merge by hand. The result of
    this merge is not committed, as with a normal merge.

    See 'hg help dates' for a list of formats valid for -d/--date.

options:

    --merge    merge with old dirstate parent after backout
    --parent   parent to choose when backing out merge
 -r --rev      revision to backout
 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns
 -m --message  use <text> as commit message
 -l --logfile  read commit message from <file>
 -d --date     record datecode as commit date
 -u --user     record the specified user as committer

--------------------------------------------------------

hg bisect [-gbsr] [-U] [-c CMD] [REV]

subdivision search of changesets

    This command helps to find changesets which introduce problems. To use,
    mark the earliest changeset you know exhibits the problem as bad, then
    mark the latest changeset which is free from the problem as good. Bisect
    will update your working directory to a revision for testing (unless the
    -U/--noupdate option is specified). Once you have performed tests, mark
    the working directory as good or bad, and bisect will either update to
    another candidate changeset or announce that it has found the bad
    revision.

    As a shortcut, you can also use the revision argument to mark a revision
    as good or bad without checking it out first.

    If you supply a command, it will be used for automatic bisection. Its exit
    status will be used to mark revisions as good or bad: status 0 means good,
    125 means to skip the revision, 127 (command not found) will abort the
    bisection, and any other non-zero exit status means the revision is bad.

options:

 -r --reset     reset bisect state
 -g --good      mark changeset good
 -b --bad       mark changeset bad
 -s --skip      skip testing changeset
 -c --command   use command to check changeset state
 -U --noupdate  do not update to target

--------------------------------------------------------

hg branch [-fC] [NAME]

set or show the current branch name

    With no argument, show the current branch name. With one argument, set the
    working directory branch name (the branch will not exist in the repository
    until the next commit). Standard practice recommends that primary
    development take place on the 'default' branch.

    Unless -f/--force is specified, branch will not let you set a branch name
    that already exists, even if it's inactive.

    Use -C/--clean to reset the working directory branch to that of the parent
    of the working directory, negating a previous branch change.

    Use the command 'hg update' to switch to an existing branch. Use 'hg
    commit --close-branch' to mark this branch as closed.

options:

 -f --force  set branch name even if it shadows an existing branch
 -C --clean  reset branch name to parent branch name

--------------------------------------------------------

hg branches [-ac]

list repository named branches

    List the repository's named branches, indicating which ones are inactive.
    If -c/--closed is specified, also list branches which have been marked
    closed (see hg commit --close-branch).

    If -a/--active is specified, only show active branches. A branch is
    considered active if it contains repository heads.

    Use the command 'hg update' to switch to an existing branch.

options:

 -a --active  show only branches that have unmerged heads
 -c --closed  show normal and closed branches

--------------------------------------------------------

hg bundle [-f] [-t TYPE] [-a] [-r REV]... [--base REV]... FILE [DEST]

create a changegroup file

    Generate a compressed changegroup file collecting changesets not known to
    be in another repository.

    If you omit the destination repository, then hg assumes the destination
    will have all the nodes you specify with --base parameters. To create a
    bundle containing all changesets, use -a/--all (or --base null).

    You can change compression method with the -t/--type option. The available
    compression methods are: none, bzip2, and gzip (by default, bundles are
    compressed using bzip2).

    The bundle file can then be transferred using conventional means and
    applied to another repository with the unbundle or pull command. This is
    useful when direct push and pull are not available or when exporting an
    entire repository is undesirable.

    Applying bundles preserves all changeset contents including permissions,
    copy/rename information, and revision history.

options:

 -f --force      run even when the destination is unrelated
 -r --rev        a changeset intended to be added to the destination
 -b --branch     a specific branch you would like to bundle
    --base       a base changeset assumed to be available at the destination
 -a --all        bundle all changesets in the repository
 -t --type       bundle compression type to use (default: bzip2)
 -e --ssh        specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

--------------------------------------------------------

hg cat [OPTION]... FILE...

output the current or given revision of files

    Print the specified files as they were at the given revision. If no
    revision is given, the parent of the working directory is used, or tip if
    no revision is checked out.

    Output may be to a file, in which case the name of the file is given using
    a format string. The formatting rules are the same as for the export
    command, with the following additions:

    "%s"  basename of file being printed
    "%d"  dirname of file being printed, or '.' if in repository root
    "%p"  root-relative path name of file being printed

options:

 -o --output   print output to file with formatted name
 -r --rev      print the given revision
    --decode   apply any matching decode filter
 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns

--------------------------------------------------------

hg clone [OPTION]... SOURCE [DEST]

make a copy of an existing repository

    Create a copy of an existing repository in a new directory.

    If no destination directory name is specified, it defaults to the basename
    of the source.

    The location of the source is added to the new repository's .hg/hgrc file,
    as the default to be used for future pulls.

    See 'hg help urls' for valid source format details.

    It is possible to specify an "ssh://" URL as the destination, but no
    .hg/hgrc and working directory will be created on the remote side. Please
    see 'hg help urls' for important details about "ssh://" URLs.

    A set of changesets (tags, or branch names) to pull may be specified by
    listing each changeset (tag, or branch name) with -r/--rev. If -r/--rev is
    used, the cloned repository will contain only a subset of the changesets
    of the source repository. Only the set of changesets defined by all
    -r/--rev options (including all their ancestors) will be pulled into the
    destination repository. No subsequent changesets (including subsequent
    tags) will be present in the destination.

    Using -r/--rev (or 'clone src#rev dest') implies --pull, even for local
    source repositories.

    For efficiency, hardlinks are used for cloning whenever the source and
    destination are on the same filesystem (note this applies only to the
    repository data, not to the working directory). Some filesystems, such as
    AFS, implement hardlinking incorrectly, but do not report errors. In these
    cases, use the --pull option to avoid hardlinking.

    In some cases, you can clone repositories and the working directory using
    full hardlinks with

      $ cp -al REPO REPOCLONE

    This is the fastest way to clone, but it is not always safe. The operation
    is not atomic (making sure REPO is not modified during the operation is up
    to you) and you have to make sure your editor breaks hardlinks (Emacs and
    most Linux Kernel tools do so). Also, this is not compatible with certain
    extensions that place their metadata under the .hg directory, such as mq.

    Mercurial will update the working directory to the first applicable
    revision from this list:

    a) null if -U or the source repository has no changesets
    b) if -u . and the source repository is local, the first parent of the
       source repository's working directory
    c) the changeset specified with -u (if a branch name, this means the
       latest head of that branch)
    d) the changeset specified with -r
    e) the tipmost head specified with -b
    f) the tipmost head specified with the url#branch source syntax
    g) the tipmost head of the default branch
    h) tip

options:

 -U --noupdate      the clone will include an empty working copy (only a
                    repository)
 -u --updaterev     revision, tag or branch to check out
 -r --rev           include the specified changeset
 -b --branch        clone only the specified branch
    --pull          use pull protocol to copy metadata
    --uncompressed  use uncompressed transfer (fast over LAN)
 -e --ssh           specify ssh command to use
    --remotecmd     specify hg command to run on the remote side

--------------------------------------------------------

hg commit [OPTION]... [FILE]...

aliases: ci

commit the specified files or all outstanding changes

    Commit changes to the given files into the repository. Unlike a
    centralized RCS, this operation is a local operation. See hg push for a
    way to actively distribute your changes.

    If a list of files is omitted, all changes reported by "hg status" will be
    committed.

    If you are committing the result of a merge, do not provide any filenames
    or -I/-X filters.

    If no commit message is specified, the configured editor is started to
    prompt you for a message.

    See 'hg help dates' for a list of formats valid for -d/--date.

options:

 -A --addremove     mark new/missing files as added/removed before committing
    --close-branch  mark a branch as closed, hiding it from the branch list
 -I --include       include names matching the given patterns
 -X --exclude       exclude names matching the given patterns
 -m --message       use <text> as commit message
 -l --logfile       read commit message from <file>
 -d --date          record datecode as commit date
 -u --user          record the specified user as committer

--------------------------------------------------------

Configuration Files

    Mercurial reads configuration data from several files, if they exist.
    Below we list the most specific file first.

    On Windows, these configuration files are read:

    - "<repo>\.hg\hgrc"
    - "%USERPROFILE%\.hgrc"
    - "%USERPROFILE%\Mercurial.ini"
    - "%HOME%\.hgrc"
    - "%HOME%\Mercurial.ini"
    - "C:\Mercurial\Mercurial.ini"
    - "HKEY_LOCAL_MACHINE\SOFTWARE\Mercurial"
    - "<install-dir>\Mercurial.ini"

    On Unix, these files are read:

    - "<repo>/.hg/hgrc"
    - "$HOME/.hgrc"
    - "/etc/mercurial/hgrc"
    - "/etc/mercurial/hgrc.d/*.rc"
    - "<install-root>/etc/mercurial/hgrc"
    - "<install-root>/etc/mercurial/hgrc.d/*.rc"

    The configuration files for Mercurial use a simple ini-file format. A
    configuration file consists of sections, led by a "[section]" header and
    followed by "name = value" entries:

      [ui]
      username = Firstname Lastname <firstname.lastname@example.net>
      verbose = True

    This above entries will be referred to as "ui.username" and "ui.verbose",
    respectively. Please see the hgrc man page for a full description of the
    possible configuration values:

    - on Unix-like systems: "man hgrc"
    - online: http://www.selenic.com/mercurial/hgrc.5.html
--------------------------------------------------------

hg copy [OPTION]... [SOURCE]... DEST

aliases: cp

mark files as copied for the next commit

    Mark dest as having copies of source files. If dest is a directory, copies
    are put in that directory. If dest is a file, the source must be a single
    file.

    By default, this command copies the contents of files as they exist in the
    working directory. If invoked with -A/--after, the operation is recorded,
    but no copying is performed.

    This command takes effect with the next commit. To undo a copy before
    that, see hg revert.

options:

 -A --after    record a copy that has already occurred
 -f --force    forcibly copy over an existing managed file
 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns
 -n --dry-run  do not perform actions, just print output

--------------------------------------------------------

Date Formats

    Some commands allow the user to specify a date, e.g.:

    - backout, commit, import, tag: Specify the commit date.
    - log, revert, update: Select revision(s) by date.

    Many date formats are valid. Here are some examples:

    - "Wed Dec 6 13:18:29 2006" (local timezone assumed)
    - "Dec 6 13:18 -0600" (year assumed, time offset provided)
    - "Dec 6 13:18 UTC" (UTC and GMT are aliases for +0000)
    - "Dec 6" (midnight)
    - "13:18" (today assumed)
    - "3:39" (3:39AM assumed)
    - "3:39pm" (15:39)
    - "2006-12-06 13:18:29" (ISO 8601 format)
    - "2006-12-6 13:18"
    - "2006-12-6"
    - "12-6"
    - "12/6"
    - "12/6/6" (Dec 6 2006)

    Lastly, there is Mercurial's internal format:

    - "1165432709 0" (Wed Dec 6 13:18:29 2006 UTC)

    This is the internal representation format for dates. unixtime is the
    number of seconds since the epoch (1970-01-01 00:00 UTC). offset is the
    offset of the local timezone, in seconds west of UTC (negative if the
    timezone is east of UTC).

    The log command also accepts date ranges:

    - "<{datetime}" - at or before a given date/time
    - ">{datetime}" - on or after a given date/time
    - "{datetime} to {datetime}" - a date range, inclusive
    - "-{days}" - within a given number of days of today
--------------------------------------------------------

hg diff [OPTION]... ([-c REV] | [-r REV1 [-r REV2]]) [FILE]...

diff repository (or selected files)

    Show differences between revisions for the specified files.

    Differences between files are shown using the unified diff format.

    NOTE: diff may generate unexpected results for merges, as it will default
    to comparing against the working directory's first parent changeset if no
    revisions are specified.

    When two revision arguments are given, then changes are shown between
    those revisions. If only one revision is specified then that revision is
    compared to the working directory, and, when no revisions are specified,
    the working directory files are compared to its parent.

    Alternatively you can specify -c/--change with a revision to see the
    changes in that changeset relative to its first parent.

    Without the -a/--text option, diff will avoid generating diffs of files it
    detects as binary. With -a, diff will generate a diff anyway, probably
    with undesirable results.

    Use the -g/--git option to generate diffs in the git extended diff format.
    For more information, read 'hg help diffs'.

options:

 -r --rev                  revision
 -c --change               change made by revision
 -a --text                 treat all files as text
 -g --git                  use git extended diff format
    --nodates              omit dates from diff headers
 -p --show-function        show which function each change is in
    --reverse              produce a diff that undoes the changes
 -w --ignore-all-space     ignore white space when comparing lines
 -b --ignore-space-change  ignore changes in the amount of white space
 -B --ignore-blank-lines   ignore changes whose lines are all blank
 -U --unified              number of lines of context to show
    --stat                 output diffstat-style summary of changes
 -I --include              include names matching the given patterns
 -X --exclude              exclude names matching the given patterns

--------------------------------------------------------

Diff Formats

    Mercurial's default format for showing changes between two versions of a
    file is compatible with the unified format of GNU diff, which can be used
    by GNU patch and many other standard tools.

    While this standard format is often enough, it does not encode the
    following information:

    - executable status and other permission bits
    - copy or rename information
    - changes in binary files
    - creation or deletion of empty files

    Mercurial also supports the extended diff format from the git VCS which
    addresses these limitations. The git diff format is not produced by
    default because a few widespread tools still do not understand this
    format.

    This means that when generating diffs from a Mercurial repository (e.g.
    with "hg export"), you should be careful about things like file copies and
    renames or other things mentioned above, because when applying a standard
    diff to a different repository, this extra information is lost.
    Mercurial's internal operations (like push and pull) are not affected by
    this, because they use an internal binary format for communicating
    changes.

    To make Mercurial produce the git extended diff format, use the --git
    option available for many commands, or set 'git = True' in the [diff]
    section of your hgrc. You do not need to set this option when importing
    diffs in this format or using them in the mq extension.
--------------------------------------------------------

Environment Variables

    HG
        Path to the 'hg' executable, automatically passed when running hooks,
        extensions or external tools. If unset or empty, this is the hg
        executable's name if it's frozen, or an executable named 'hg' (with
        %PATHEXT% [defaulting to COM/EXE/BAT/CMD] extensions on Windows) is
        searched.
    HGEDITOR
        This is the name of the editor to run when committing. See EDITOR.

        (deprecated, use .hgrc)

    HGENCODING
        This overrides the default locale setting detected by Mercurial. This
        setting is used to convert data including usernames, changeset
        descriptions, tag names, and branches. This setting can be overridden
        with the --encoding command-line option.
    HGENCODINGMODE
        This sets Mercurial's behavior for handling unknown characters while
        transcoding user input. The default is "strict", which causes
        Mercurial to abort if it can't map a character. Other settings include
        "replace", which replaces unknown characters, and "ignore", which
        drops them. This setting can be overridden with the --encodingmode
        command-line option.
    HGMERGE
        An executable to use for resolving merge conflicts. The program will
        be executed with three arguments: local file, remote file, ancestor
        file.

        (deprecated, use .hgrc)

    HGRCPATH
        A list of files or directories to search for hgrc files. Item
        separator is ":" on Unix, ";" on Windows. If HGRCPATH is not set,
        platform default search path is used. If empty, only the .hg/hgrc from
        the current repository is read.

        For each element in HGRCPATH:

        - if it's a directory, all files ending with .rc are added
        - otherwise, the file itself will be added

    HGPLAIN
        When set, this disables any options in .hgrc that might change
        Mercurial's default output. This includes encoding, defaults, verbose
        mode, debug mode, quiet mode, tracebacks, and localization. This can
        be useful when scripting against Mercurial in the face of existing
        user configuration.

        Equivalent options set via command line flags or environment variables
        are not overridden.

    HGUSER
        This is the string used as the author of a commit. If not set,
        available values will be considered in this order:

        - HGUSER (deprecated)
        - hgrc files from the HGRCPATH
        - EMAIL
        - interactive prompt
        - LOGNAME (with "@hostname" appended)

        (deprecated, use .hgrc)

    EMAIL
        May be used as the author of a commit; see HGUSER.
    LOGNAME
        May be used as the author of a commit; see HGUSER.
    VISUAL
        This is the name of the editor to use when committing. See EDITOR.
    EDITOR
        Sometimes Mercurial needs to open a text file in an editor for a user
        to modify, for example when writing commit messages. The editor it
        uses is determined by looking at the environment variables HGEDITOR,
        VISUAL and EDITOR, in that order. The first non-empty one is chosen.
        If all of them are empty, the editor defaults to 'vi'.
    PYTHONPATH
        This is used by Python to find imported modules and may need to be set
        appropriately if this Mercurial is not installed system-wide.
--------------------------------------------------------

hg export [OPTION]... [-o OUTFILESPEC] REV...

dump the header and diffs for one or more changesets

    Print the changeset header and diffs for one or more revisions.

    The information shown in the changeset header is: author, date, branch
    name (if non-default), changeset hash, parent(s) and commit comment.

    NOTE: export may generate unexpected diff output for merge changesets, as
    it will compare the merge changeset against its first parent only.

    Output may be to a file, in which case the name of the file is given using
    a format string. The formatting rules are as follows:

    "%%"  literal "%" character
    "%H"  changeset hash (40 bytes of hexadecimal)
    "%N"  number of patches being generated
    "%R"  changeset revision number
    "%b"  basename of the exporting repository
    "%h"  short-form changeset hash (12 bytes of hexadecimal)
    "%n"  zero-padded sequence number, starting at 1
    "%r"  zero-padded changeset revision number

    Without the -a/--text option, export will avoid generating diffs of files
    it detects as binary. With -a, export will generate a diff anyway,
    probably with undesirable results.

    Use the -g/--git option to generate diffs in the git extended diff format.
    See 'hg help diffs' for more information.

    With the --switch-parent option, the diff will be against the second
    parent. It can be useful to review a merge.

options:

 -o --output         print output to file with formatted name
    --switch-parent  diff against the second parent
 -r --rev            revisions to export
 -a --text           treat all files as text
 -g --git            use git extended diff format
    --nodates        omit dates from diff headers

--------------------------------------------------------

Using additional features

    Mercurial has the ability to add new features through the use of
    extensions. Extensions may add new commands, add options to existing
    commands, change the default behavior of commands, or implement hooks.

    Extensions are not loaded by default for a variety of reasons: they can
    increase startup overhead; they may be meant for advanced usage only; they
    may provide potentially dangerous abilities (such as letting you destroy
    or modify history); they might not be ready for prime time; or they may
    alter some usual behaviors of stock Mercurial. It is thus up to the user
    to activate extensions as needed.

    To enable the "foo" extension, either shipped with Mercurial or in the
    Python search path, create an entry for it in your hgrc, like this:

      [extensions]
      foo =

    You may also specify the full path to an extension:

      [extensions]
      myfeature = ~/.hgext/myfeature.py

    To explicitly disable an extension enabled in an hgrc of broader scope,
    prepend its path with !:

      [extensions]
      # disabling extension bar residing in /path/to/extension/bar.py
      bar = !/path/to/extension/bar.py
      # ditto, but no path was supplied for extension baz
      baz = !
--------------------------------------------------------

hg forget [OPTION]... FILE...

forget the specified files on the next commit

    Mark the specified files so they will no longer be tracked after the next
    commit.

    This only removes files from the current branch, not from the entire
    project history, and it does not delete them from the working directory.

    To undo a forget before the next commit, see hg add.

options:

 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns

--------------------------------------------------------

hg grep [OPTION]... PATTERN [FILE]...

search for a pattern in specified files and revisions

    Search revisions of files for a regular expression.

    This command behaves differently than Unix grep. It only accepts
    Python/Perl regexps. It searches repository history, not the working
    directory. It always prints the revision number in which a match appears.

    By default, grep only prints output for the first revision of a file in
    which it finds a match. To get it to print every revision that contains a
    change in match status ("-" for a match that becomes a non-match, or "+"
    for a non-match that becomes a match), use the --all flag.

options:

 -0 --print0              end fields with NUL
    --all                 print all revisions that match
 -f --follow              follow changeset history, or file history across
                          copies and renames
 -i --ignore-case         ignore case when matching
 -l --files-with-matches  print only filenames and revisions that match
 -n --line-number         print matching line numbers
 -r --rev                 only search files changed within revision range
 -u --user                list the author (long with -v)
 -d --date                list the date (short with -q)
 -I --include             include names matching the given patterns
 -X --exclude             exclude names matching the given patterns

--------------------------------------------------------

hg heads [-ac] [-r STARTREV] [REV]...

show current repository heads or show branch heads

    With no arguments, show all repository branch heads.

    Repository "heads" are changesets with no child changesets. They are where
    development generally takes place and are the usual targets for update and
    merge operations. Branch heads are changesets that have no child changeset
    on the same branch.

    If one or more REVs are given, only branch heads on the branches
    associated with the specified changesets are shown.

    If -c/--closed is specified, also show branch heads marked closed (see hg
    commit --close-branch).

    If STARTREV is specified, only those heads that are descendants of
    STARTREV will be displayed.

    If -t/--topo is specified, named branch mechanics will be ignored and only
    changesets without children will be shown.

options:

 -r --rev       show only heads which are descendants of REV
 -t --topo      show topological heads only
 -c --closed    show normal and closed branch heads
    --style     display using template map file
    --template  display with template

--------------------------------------------------------

hg help [TOPIC]

show help for a given topic or a help overview

    With no arguments, print a list of commands with short help messages.

    Given a topic, extension, or command name, print help for that topic.

--------------------------------------------------------

hg identify [-nibt] [-r REV] [SOURCE]

aliases: id

identify the working copy or specified revision

    With no revision, print a summary of the current state of the repository.

    Specifying a path to a repository root or Mercurial bundle will cause
    lookup to operate on that repository/bundle.

    This summary identifies the repository state using one or two parent hash
    identifiers, followed by a "+" if there are uncommitted changes in the
    working directory, a list of tags for this revision and a branch name for
    non-default branches.

options:

 -r --rev     identify the specified revision
 -n --num     show local revision number
 -i --id      show global revision id
 -b --branch  show branch
 -t --tags    show tags

--------------------------------------------------------

hg import [OPTION]... PATCH...

aliases: patch

import an ordered set of patches

    Import a list of patches and commit them individually (unless --no-commit
    is specified).

    If there are outstanding changes in the working directory, import will
    abort unless given the -f/--force flag.

    You can import a patch straight from a mail message. Even patches as
    attachments work (to use the body part, it must have type text/plain or
    text/x-patch). From and Subject headers of email message are used as
    default committer and commit message. All text/plain body parts before
    first diff are added to commit message.

    If the imported patch was generated by hg export, user and description
    from patch override values from message headers and body. Values given on
    command line with -m/--message and -u/--user override these.

    If --exact is specified, import will set the working directory to the
    parent of each patch before applying it, and will abort if the resulting
    changeset has a different ID than the one recorded in the patch. This may
    happen due to character set problems or other deficiencies in the text
    patch format.

    With -s/--similarity, hg will attempt to discover renames and copies in
    the patch in the same way as 'addremove'.

    To read a patch from standard input, use "-" as the patch name. If a URL
    is specified, the patch will be downloaded from it. See 'hg help dates'
    for a list of formats valid for -d/--date.

options:

 -p --strip          directory strip option for patch. This has the same
                     meaning as the corresponding patch option (default: 1)
 -b --base           base path
 -f --force          skip check for outstanding uncommitted changes
    --no-commit      don't commit, just update the working directory
    --exact          apply patch to the nodes from which it was generated
    --import-branch  use any branch information in patch (implied by --exact)
 -m --message        use <text> as commit message
 -l --logfile        read commit message from <file>
 -d --date           record datecode as commit date
 -u --user           record the specified user as committer
 -s --similarity     guess renamed files by similarity (0<=s<=100)

--------------------------------------------------------

hg incoming [-p] [-n] [-M] [-f] [-r REV]... [--bundle FILENAME] [SOURCE]

aliases: in

show new changesets found in source

    Show new changesets found in the specified path/URL or the default pull
    location. These are the changesets that would have been pulled if a pull
    at the time you issued this command.

    For remote repository, using --bundle avoids downloading the changesets
    twice if the incoming is followed by a pull.

    See pull for valid source format details.

options:

 -f --force         run even if remote repository is unrelated
 -n --newest-first  show newest record first
    --bundle        file to store the bundles into
 -r --rev           a remote changeset intended to be added
 -b --branch        a specific branch you would like to pull
 -p --patch         show patch
 -g --git           use git extended diff format
 -l --limit         limit number of changes displayed
 -M --no-merges     do not show merges
    --style         display using template map file
    --template      display with template
 -e --ssh           specify ssh command to use
    --remotecmd     specify hg command to run on the remote side

--------------------------------------------------------

hg init [-e CMD] [--remotecmd CMD] [DEST]

create a new repository in the given directory

    Initialize a new repository in the given directory. If the given directory
    does not exist, it will be created.

    If no directory is given, the current directory is used.

    It is possible to specify an "ssh://" URL as the destination. See 'hg help
    urls' for more information.

options:

 -e --ssh        specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

--------------------------------------------------------

hg locate [OPTION]... [PATTERN]...

locate files matching specific patterns

    Print files under Mercurial control in the working directory whose names
    match the given patterns.

    By default, this command searches all directories in the working
    directory. To search just the current directory and its subdirectories,
    use "--include .".

    If no patterns are given to match, this command prints the names of all
    files under Mercurial control in the working directory.

    If you want to feed the output of this command into the "xargs" command,
    use the -0 option to both this command and "xargs". This will avoid the
    problem of "xargs" treating single filenames that contain whitespace as
    multiple filenames.

options:

 -r --rev       search the repository as it is in REV
 -0 --print0    end filenames with NUL, for use with xargs
 -f --fullpath  print complete paths from the filesystem root
 -I --include   include names matching the given patterns
 -X --exclude   exclude names matching the given patterns

--------------------------------------------------------

hg log [OPTION]... [FILE]

aliases: history

show revision history of entire repository or files

    Print the revision history of the specified files or the entire project.

    File history is shown without following rename or copy history of files.
    Use -f/--follow with a filename to follow history across renames and
    copies. --follow without a filename will only show ancestors or
    descendants of the starting revision. --follow-first only follows the
    first parent of merge revisions.

    If no revision range is specified, the default is tip:0 unless --follow is
    set, in which case the working directory parent is used as the starting
    revision.

    See 'hg help dates' for a list of formats valid for -d/--date.

    By default this command prints revision number and changeset id, tags,
    non-trivial parents, user, date and time, and a summary for each commit.
    When the -v/--verbose switch is used, the list of changed files and full
    commit message are shown.

    NOTE: log -p/--patch may generate unexpected diff output for merge
    changesets, as it will only compare the merge changeset against its first
    parent. Also, only files different from BOTH parents will appear in
    files:.

options:

 -f --follow        follow changeset history, or file history across copies
                    and renames
    --follow-first  only follow the first parent of merge changesets
 -d --date          show revisions matching date spec
 -C --copies        show copied files
 -k --keyword       do case-insensitive search for a keyword
 -r --rev           show the specified revision or range
    --removed       include revisions where files were removed
 -m --only-merges   show only merges
 -u --user          revisions committed by user
 -b --only-branch   show only changesets within the given named branch
 -P --prune         do not display revision or any of its ancestors
 -p --patch         show patch
 -g --git           use git extended diff format
 -l --limit         limit number of changes displayed
 -M --no-merges     do not show merges
    --style         display using template map file
    --template      display with template
 -I --include       include names matching the given patterns
 -X --exclude       exclude names matching the given patterns

--------------------------------------------------------

hg manifest [-r REV]

output the current or given revision of the project manifest

    Print a list of version controlled files for the given revision. If no
    revision is given, the first parent of the working directory is used, or
    the null revision if no revision is checked out.

    With -v, print file permissions, symlink and executable bits. With
    --debug, print file revision hashes.

options:

 -r --rev  revision to display

--------------------------------------------------------

hg merge [-P] [-f] [[-r] REV]

merge working directory with another revision

    The current working directory is updated with all changes made in the
    requested revision since the last common predecessor revision.

    Files that changed between either parent are marked as changed for the
    next commit and a commit must be performed before any further updates to
    the repository are allowed. The next commit will have two parents.

    If no revision is specified, the working directory's parent is a head
    revision, and the current branch contains exactly one other head, the
    other head is merged with by default. Otherwise, an explicit revision with
    which to merge with must be provided.

options:

 -f --force    force a merge with outstanding changes
 -r --rev      revision to merge
 -P --preview  review revisions to merge (no merge is performed)

--------------------------------------------------------

Specifying Multiple Revisions

    When Mercurial accepts more than one revision, they may be specified
    individually, or provided as a topologically continuous range, separated
    by the ":" character.

    The syntax of range notation is [BEGIN]:[END], where BEGIN and END are
    revision identifiers. Both BEGIN and END are optional. If BEGIN is not
    specified, it defaults to revision number 0. If END is not specified, it
    defaults to the tip. The range ":" thus means "all revisions".

    If BEGIN is greater than END, revisions are treated in reverse order.

    A range acts as a closed interval. This means that a range of 3:5 gives 3,
    4 and 5. Similarly, a range of 9:6 gives 9, 8, 7, and 6.
--------------------------------------------------------

hg outgoing [-M] [-p] [-n] [-f] [-r REV]... [DEST]

aliases: out

show changesets not found in the destination

    Show changesets not found in the specified destination repository or the
    default push location. These are the changesets that would be pushed if a
    push was requested.

    See pull for details of valid destination formats.

options:

 -f --force         run even when the destination is unrelated
 -r --rev           a changeset intended to be included in the destination
 -n --newest-first  show newest record first
 -b --branch        a specific branch you would like to push
 -p --patch         show patch
 -g --git           use git extended diff format
 -l --limit         limit number of changes displayed
 -M --no-merges     do not show merges
    --style         display using template map file
    --template      display with template
 -e --ssh           specify ssh command to use
    --remotecmd     specify hg command to run on the remote side

--------------------------------------------------------

hg parents [-r REV] [FILE]

show the parents of the working directory or revision

    Print the working directory's parent revisions. If a revision is given via
    -r/--rev, the parent of that revision will be printed. If a file argument
    is given, the revision in which the file was last changed (before the
    working directory revision or the argument to --rev if given) is printed.

options:

 -r --rev       show parents of the specified revision
    --style     display using template map file
    --template  display with template

--------------------------------------------------------

hg paths [NAME]

show aliases for remote repositories

    Show definition of symbolic path name NAME. If no name is given, show
    definition of all available names.

    Path names are defined in the [paths] section of /etc/mercurial/hgrc and
    $HOME/.hgrc. If run inside a repository, .hg/hgrc is used, too.

    The path names "default" and "default-push" have a special meaning.  When
    performing a push or pull operation, they are used as fallbacks if no
    location is specified on the command-line. When "default-push" is set, it
    will be used for push and "default" will be used for pull; otherwise
    "default" is used as the fallback for both.  When cloning a repository,
    the clone source is written as "default" in ".hg/hgrc".  Note that
    "default" and "default-push" apply to all inbound (e.g. "hg incoming") and
    outbound (e.g. "hg outgoing", "hg email" and "hg bundle") operations.

    See 'hg help urls' for more information.

--------------------------------------------------------

File Name Patterns

    Mercurial accepts several notations for identifying one or more files at a
    time.

    By default, Mercurial treats filenames as shell-style extended glob
    patterns.

    Alternate pattern notations must be specified explicitly.

    To use a plain path name without any pattern matching, start it with
    "path:". These path names must completely match starting at the current
    repository root.

    To use an extended glob, start a name with "glob:". Globs are rooted at
    the current directory; a glob such as "*.c" will only match files in the
    current directory ending with ".c".

    The supported glob syntax extensions are "**" to match any string across
    path separators and "{a,b}" to mean "a or b".

    To use a Perl/Python regular expression, start a name with "re:". Regexp
    pattern matching is anchored at the root of the repository.

    Plain examples:

      path:foo/bar   a name bar in a directory named foo in the root
                     of the repository
      path:path:name a file or directory named "path:name"

    Glob examples:

      glob:*.c       any name ending in ".c" in the current directory
      *.c            any name ending in ".c" in the current directory
      **.c           any name ending in ".c" in any subdirectory of the
                     current directory including itself.
      foo/*.c        any name ending in ".c" in the directory foo
      foo/**.c       any name ending in ".c" in any subdirectory of foo
                     including itself.

    Regexp examples:

      re:.*\.c$      any name ending in ".c", anywhere in the repository
--------------------------------------------------------

hg pull [-u] [-f] [-r REV]... [-e CMD] [--remotecmd CMD] [SOURCE]

pull changes from the specified source

    Pull changes from a remote repository to a local one.

    This finds all changes from the repository at the specified path or URL
    and adds them to a local repository (the current one unless -R is
    specified). By default, this does not update the copy of the project in
    the working directory.

    Use hg incoming if you want to see what would have been added by a pull at
    the time you issued this command. If you then decide to added those
    changes to the repository, you should use pull -r X where X is the last
    changeset listed by hg incoming.

    If SOURCE is omitted, the 'default' path will be used. See 'hg help urls'
    for more information.

options:

 -u --update     update to new branch head if changesets were pulled
 -f --force      run even when remote repository is unrelated
 -r --rev        a remote changeset intended to be added
 -b --branch     a specific branch you would like to pull
 -e --ssh        specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

--------------------------------------------------------

hg push [-f] [-r REV]... [-e CMD] [--remotecmd CMD] [DEST]

push changes to the specified destination

    Push changesets from the local repository to the specified destination.

    This operation is symmetrical to pull: it is identical to a pull in the
    destination repository from the current one.

    By default, push will not allow creation of new heads at the destination,
    since multiple heads would make it unclear which head to use. In this
    situation, it is recommended to pull and merge before pushing.

    Use -f/--force to override the default behavior and push all changesets on
    all branches.

    If -r/--rev is used, the specified revision and all its ancestors will be
    pushed to the remote repository.

    Please see 'hg help urls' for important details about "ssh://" URLs. If
    DESTINATION is omitted, a default path will be used.

options:

 -f --force      force push
 -r --rev        a changeset intended to be included in the destination
 -b --branch     a specific branch you would like to push
 -e --ssh        specify ssh command to use
    --remotecmd  specify hg command to run on the remote side

--------------------------------------------------------

hg recover

roll back an interrupted transaction

    Recover from an interrupted commit or pull.

    This command tries to fix the repository status after an interrupted
    operation. It should only be necessary when Mercurial suggests it.

--------------------------------------------------------

hg remove [OPTION]... FILE...

aliases: rm

remove the specified files on the next commit

    Schedule the indicated files for removal from the repository.

    This only removes files from the current branch, not from the entire
    project history. -A/--after can be used to remove only files that have
    already been deleted, -f/--force can be used to force deletion, and -Af
    can be used to remove files from the next revision without deleting them
    from the working directory.

    The following table details the behavior of remove for different file
    states (columns) and option combinations (rows). The file states are Added
    [A], Clean [C], Modified [M] and Missing [!] (as reported by hg status).
    The actions are Warn, Remove (from branch) and Delete (from disk):

             A  C  M  !
      none   W  RD W  R
      -f     R  RD RD R
      -A     W  W  W  R
      -Af    R  R  R  R

    This command schedules the files to be removed at the next commit. To undo
    a remove before that, see hg revert.

options:

 -A --after    record delete for missing files
 -f --force    remove (and delete) file even if added or modified
 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns

--------------------------------------------------------

hg rename [OPTION]... SOURCE... DEST

aliases: mv

rename files; equivalent of copy + remove

    Mark dest as copies of sources; mark sources for deletion. If dest is a
    directory, copies are put in that directory. If dest is a file, there can
    only be one source.

    By default, this command copies the contents of files as they exist in the
    working directory. If invoked with -A/--after, the operation is recorded,
    but no copying is performed.

    This command takes effect at the next commit. To undo a rename before
    that, see hg revert.

options:

 -A --after    record a rename that has already occurred
 -f --force    forcibly copy over an existing managed file
 -I --include  include names matching the given patterns
 -X --exclude  exclude names matching the given patterns
 -n --dry-run  do not perform actions, just print output

--------------------------------------------------------

hg resolve [OPTION]... [FILE]...

various operations to help finish a merge

    This command includes several actions that are often useful while
    performing a merge, after running "merge" but before running "commit".
    (It is only meaningful if your working directory has two parents.)  It is
    most relevant for merges with unresolved conflicts, which are typically a
    result of non-interactive merging with "internal:merge" or a command-line
    merge tool like "diff3".

    The available actions are:

      1) list files that were merged with conflicts (U, for unresolved) and
         without conflicts (R, for resolved): "hg resolve -l" (this is like
         "status" for merges)
      2) record that you have resolved conflicts in certain files: "hg resolve
         -m [file ...]" (default: mark all unresolved files)
      3) forget that you have resolved conflicts in certain files: "hg resolve
         -u [file ...]" (default: unmark all resolved files)
      4) discard your current attempt(s) at resolving conflicts and restart
         the merge from scratch: "hg resolve file..." (or "-a" for all
         unresolved files)

    Note that Mercurial will not let you commit files with unresolved merge
    conflicts.  You must use "hg resolve -m ..." before you can commit after a
    conflicting merge.

options:

 -a --all        select all unresolved files
 -l --list       list state of files needing merge
 -m --mark       mark files as resolved
 -u --unmark     unmark files as resolved
 -n --no-status  hide status prefix
 -I --include    include names matching the given patterns
 -X --exclude    exclude names matching the given patterns

--------------------------------------------------------

hg revert [OPTION]... [-r REV] [NAME]...

restore individual files or directories to an earlier state

    (Use update -r to check out earlier revisions, revert does not change the
    working directory parents.)

    With no revision specified, revert the named files or directories to the
    contents they had in the parent of the working directory. This restores
    the contents of the affected files to an unmodified state and unschedules
    adds, removes, copies, and renames. If the working directory has two
    parents, you must explicitly specify a revision.

    Using the -r/--rev option, revert the given files or directories to their
    contents as of a specific revision. This can be helpful to "roll back"
    some or all of an earlier change. See 'hg help dates' for a list of
    formats valid for -d/--date.

    Revert modifies the working directory. It does not commit any changes, or
    change the parent of the working directory. If you revert to a revision
    other than the parent of the working directory, the reverted files will
    thus appear modified afterwards.

    If a file has been deleted, it is restored. If the executable mode of a
    file was changed, it is reset.

    If names are given, all files matching the names are reverted. If no
    arguments are given, no files are reverted.

    Modified files are saved with a .orig suffix before reverting. To disable
    these backups, use --no-backup.

options:

 -a --all        revert all changes when no arguments given
 -d --date       tipmost revision matching date
 -r --rev        revert to the specified revision
    --no-backup  do not save backup copies of files
 -I --include    include names matching the given patterns
 -X --exclude    exclude names matching the given patterns
 -n --dry-run    do not perform actions, just print output

--------------------------------------------------------

Specifying Single Revisions

    Mercurial supports several ways to specify individual revisions.

    A plain integer is treated as a revision number. Negative integers are
    treated as sequential offsets from the tip, with -1 denoting the tip, -2
    denoting the revision prior to the tip, and so forth.

    A 40-digit hexadecimal string is treated as a unique revision identifier.

    A hexadecimal string less than 40 characters long is treated as a unique
    revision identifier and is referred to as a short-form identifier. A
    short-form identifier is only valid if it is the prefix of exactly one
    full-length identifier.

    Any other string is treated as a tag or branch name. A tag name is a
    symbolic name associated with a revision identifier. A branch name denotes
    the tipmost revision of that branch. Tag and branch names must not contain
    the ":" character.

    The reserved name "tip" is a special tag that always identifies the most
    recent revision.

    The reserved name "null" indicates the null revision. This is the revision
    of an empty repository, and the parent of revision 0.

    The reserved name "." indicates the working directory parent. If no
    working directory is checked out, it is equivalent to null. If an
    uncommitted merge is in progress, "." is the revision of the first parent.
--------------------------------------------------------

hg rollback

roll back the last transaction

    This command should be used with care. There is only one level of
    rollback, and there is no way to undo a rollback. It will also restore the
    dirstate at the time of the last transaction, losing any dirstate changes
    since that time. This command does not alter the working directory.

    Transactions are used to encapsulate the effects of all commands that
    create new changesets or propagate existing changesets into a repository.
    For example, the following commands are transactional, and their effects
    can be rolled back:

    - commit
    - import
    - pull
    - push (with this repository as the destination)
    - unbundle

    This command is not intended for use on public repositories. Once changes
    are visible for pull by other users, rolling a transaction back locally is
    ineffective (someone else may already have pulled the changes).
    Furthermore, a race is possible with readers of the repository; for
    example an in-progress pull from the repository may fail if a rollback is
    performed.

--------------------------------------------------------

hg root

print the root (top) of the current working directory

    Print the root directory of the current repository.

--------------------------------------------------------

hg serve [OPTION]...

export the repository via HTTP

    Start a local HTTP repository browser and pull server. You can use this
    for ad-hoc sharing and browing of repositories. It is recommended to use a
    real web server to serve a repository for longer periods of time.

    Please note that the server does not implement access control. This means
    that, by default, anybody can read from the server and nobody can write to
    it by default. Set the "web.allow_push" option to "*" to allow everybody
    to push to the server. You should use a real web server if you need to
    authenticate users.

    By default, the server logs accesses to stdout and errors to stderr. Use
    the -A/--accesslog and -E/--errorlog options to log to files.

options:

 -A --accesslog       name of access log file to write to
 -d --daemon          run server in background
    --daemon-pipefds  used internally by daemon mode
 -E --errorlog        name of error log file to write to
 -p --port            port to listen on (default: 8000)
 -a --address         address to listen on (default: all interfaces)
    --prefix          prefix path to serve from (default: server root)
 -n --name            name to show in web pages (default: working directory)
    --webdir-conf     name of the webdir config file (serve more than one
                      repository)
    --pid-file        name of file to write process ID to
    --stdio           for remote clients
 -t --templates       web templates to use
    --style           template style to use
 -6 --ipv6            use IPv6 in addition to IPv4
    --certificate     SSL certificate file

--------------------------------------------------------

hg showconfig [-u] [NAME]...

aliases: debugconfig

show combined config settings from all hgrc files

    With no arguments, print names and values of all config items.

    With one argument of the form section.name, print just the value of that
    config item.

    With multiple arguments, print names and values of all config items with
    matching section names.

    With --debug, the source (filename and line number) is printed for each
    config item.

options:

 -u --untrusted  show untrusted configuration options

--------------------------------------------------------

hg status [OPTION]... [FILE]...

aliases: st

show changed files in the working directory

    Show status of files in the repository. If names are given, only files
    that match are shown. Files that are clean or ignored or the source of a
    copy/move operation, are not listed unless -c/--clean, -i/--ignored,
    -C/--copies or -A/--all are given. Unless options described with "show
    only ..." are given, the options -mardu are used.

    Option -q/--quiet hides untracked (unknown and ignored) files unless
    explicitly requested with -u/--unknown or -i/--ignored.

    NOTE: status may appear to disagree with diff if permissions have changed
    or a merge has occurred. The standard diff format does not report
    permission changes and diff only reports changes relative to one merge
    parent.

    If one revision is given, it is used as the base revision. If two
    revisions are given, the differences between them are shown. The --change
    option can also be used as a shortcut to list the changed files of a
    revision from its first parent.

    The codes used to show the status of files are:

      M = modified
      A = added
      R = removed
      C = clean
      ! = missing (deleted by non-hg command, but still tracked)
      ? = not tracked
      I = ignored
        = origin of the previous file listed as A (added)

options:

 -A --all        show status of all files
 -m --modified   show only modified files
 -a --added      show only added files
 -r --removed    show only removed files
 -d --deleted    show only deleted (but tracked) files
 -c --clean      show only files without changes
 -u --unknown    show only unknown (not tracked) files
 -i --ignored    show only ignored files
 -n --no-status  hide status prefix
 -C --copies     show source of copied files
 -0 --print0     end filenames with NUL, for use with xargs
    --rev        show difference from revision
    --change     list the changed files of a revision
 -I --include    include names matching the given patterns
 -X --exclude    exclude names matching the given patterns

--------------------------------------------------------

hg summary [--remote]

aliases: sum

summarize working directory state

    This generates a brief summary of the working directory state, including
    parents, branch, commit status, and available updates.

    With the --remote option, this will check the default paths for incoming
    and outgoing changes. This can be time-consuming.

options:

    --remote  check for push and pull

--------------------------------------------------------

hg tag [-f] [-l] [-m TEXT] [-d DATE] [-u USER] [-r REV] NAME...

add one or more tags for the current or given revision

    Name a particular revision using <name>.

    Tags are used to name particular revisions of the repository and are very
    useful to compare different revisions, to go back to significant earlier
    versions or to mark branch points as releases, etc.

    If no revision is given, the parent of the working directory is used, or
    tip if no revision is checked out.

    To facilitate version control, distribution, and merging of tags, they are
    stored as a file named ".hgtags" which is managed similarly to other
    project files and can be hand-edited if necessary. The file
    '.hg/localtags' is used for local tags (not shared among repositories).

    See 'hg help dates' for a list of formats valid for -d/--date.

options:

 -f --force    replace existing tag
 -l --local    make the tag local
 -r --rev      revision to tag
    --remove   remove a tag
 -m --message  use <text> as commit message
 -d --date     record datecode as commit date
 -u --user     record the specified user as committer

--------------------------------------------------------

hg tags 

list repository tags

    This lists both regular and local tags. When the -v/--verbose switch is
    used, a third column "local" is printed for local tags.

--------------------------------------------------------

Template Usage

    Mercurial allows you to customize output of commands through templates.
    You can either pass in a template from the command line, via the
    --template option, or select an existing template-style (--style).

    You can customize output for any "log-like" command: log, outgoing,
    incoming, tip, parents, heads and glog.

    Four styles are packaged with Mercurial: default (the style used when no
    explicit preference is passed), compact, changelog, and xml. Usage:

      $ hg log -r1 --style changelog

    A template is a piece of text, with markup to invoke variable expansion:

      $ hg log -r1 --template "{node}\n"
      b56ce7b07c52de7d5fd79fb89701ea538af65746

    Strings in curly braces are called keywords. The availability of keywords
    depends on the exact context of the templater. These keywords are usually
    available for templating a log-like command:

    author      String. The unmodified author of the changeset.
    branches    String. The name of the branch on which the changeset was
                committed. Will be empty if the branch name was default.
    date        Date information. The date when the changeset was committed.
    desc        String. The text of the changeset description.
    diffstat    String. Statistics of changes with the following format:
                "modified files: +added/-removed lines"
    files       List of strings. All files modified, added, or removed by this
                changeset.
    file_adds   List of strings. Files added by this changeset.
    file_copies
                List of strings. Files copied in this changeset with their
                sources.
    file_copies_switch
                List of strings. Like "file_copies" but displayed only if the
                --copied switch is set.
    file_mods   List of strings. Files modified by this changeset.
    file_dels   List of strings. Files removed by this changeset.
    node        String. The changeset identification hash, as a 40-character
                hexadecimal string.
    parents     List of strings. The parents of the changeset.
    rev         Integer. The repository-local changeset revision number.
    tags        List of strings. Any tags associated with the changeset.
    latesttag   String. Most recent global tag in the ancestors of this
                changeset.
    latesttagdistance
                Integer. Longest path to the latest tag.

    The "date" keyword does not produce human-readable output. If you want to
    use a date in your output, you can use a filter to process it. Filters are
    functions which return a string based on the input variable. Be sure to
    use the stringify filter first when you're applying a string-input filter
    to a list-like input variable. You can also use a chain of filters to get
    the desired output:

      $ hg tip --template "{date|isodate}\n"
      2008-08-21 18:22 +0000

    List of filters:

    addbreaks   Any text. Add an XHTML "<br />" tag before the end of every
                line except the last.
    age         Date. Returns a human-readable date/time difference between
                the given date/time and the current date/time.
    basename    Any text. Treats the text as a path, and returns the last
                component of the path after splitting by the path separator
                (ignoring trailing separators). For example, "foo/bar/baz"
                becomes "baz" and "foo/bar//" becomes "bar".
    stripdir    Treat the text as path and strip a directory level, if
                possible. For example, "foo" and "foo/bar" becomes "foo".
    date        Date. Returns a date in a Unix date format, including the
                timezone: "Mon Sep 04 15:13:13 2006 0700".
    domain      Any text. Finds the first string that looks like an email
                address, and extracts just the domain component. Example:
                "User <user@example.com>" becomes "example.com".
    email       Any text. Extracts the first string that looks like an email
                address. Example: "User <user@example.com>" becomes
                "user@example.com".
    escape      Any text. Replaces the special XML/XHTML characters "&", "<"
                and ">" with XML entities.
    fill68      Any text. Wraps the text to fit in 68 columns.
    fill76      Any text. Wraps the text to fit in 76 columns.
    firstline   Any text. Returns the first line of text.
    nonempty    Any text. Returns '(none)' if the string is empty.
    hgdate      Date. Returns the date as a pair of numbers: "1157407993
                25200" (Unix timestamp, timezone offset).
    isodate     Date. Returns the date in ISO 8601 format: "2009-08-18 13:00
                +0200".
    isodatesec  Date. Returns the date in ISO 8601 format, including seconds:
                "2009-08-18 13:00:13 +0200". See also the rfc3339date filter.
    localdate   Date. Converts a date to local date.
    obfuscate   Any text. Returns the input text rendered as a sequence of XML
                entities.
    person      Any text. Returns the text before an email address.
    rfc822date  Date. Returns a date using the same format used in email
                headers: "Tue, 18 Aug 2009 13:00:13 +0200".
    rfc3339date
                Date. Returns a date using the Internet date format specified
                in RFC 3339: "2009-08-18T13:00:13+02:00".
    short       Changeset hash. Returns the short form of a changeset hash,
                i.e. a 12-byte hexadecimal string.
    shortdate   Date. Returns a date like "2006-09-18".
    strip       Any text. Strips all leading and trailing whitespace.
    tabindent   Any text. Returns the text, with every line except the first
                starting with a tab character.
    urlescape   Any text. Escapes all "special" characters. For example, "foo
                bar" becomes "foo%20bar".
    user        Any text. Returns the user portion of an email address.
--------------------------------------------------------

hg tip [-p] [-g]

show the tip revision

    The tip revision (usually just called the tip) is the changeset most
    recently added to the repository (and therefore the most recently changed
    head).

    If you have just made a commit, that commit will be the tip. If you have
    just pulled changes from another repository, the tip of that repository
    becomes the current tip. The "tip" tag is special and cannot be renamed or
    assigned to a different changeset.

options:

 -p --patch     show patch
 -g --git       use git extended diff format
    --style     display using template map file
    --template  display with template

--------------------------------------------------------

hg unbundle [-u] FILE...

apply one or more changegroup files

    Apply one or more compressed changegroup files generated by the bundle
    command.

options:

 -u --update  update to new branch head if changesets were unbundled

--------------------------------------------------------

hg update [-c] [-C] [-d DATE] [[-r] REV]

aliases: up, checkout, co

update working directory

    Update the repository's working directory to the specified changeset.

    If no changeset is specified, attempt to update to the head of the current
    branch. If this head is a descendant of the working directory's parent,
    update to it, otherwise abort.

    The following rules apply when the working directory contains uncommitted
    changes:

    1. If neither -c/--check nor -C/--clean is specified, and if the requested
       changeset is an ancestor or descendant of the working directory's
       parent, the uncommitted changes are merged into the requested changeset
       and the merged result is left uncommitted. If the requested changeset
       is not an ancestor or descendant (that is, it is on another branch),
       the update is aborted and the uncommitted changes are preserved.
    2. With the -c/--check option, the update is aborted and the uncommitted
       changes are preserved.
    3. With the -C/--clean option, uncommitted changes are discarded and the
       working directory is updated to the requested changeset.

    Use null as the changeset to remove the working directory (like 'hg clone
    -U').

    If you want to update just one file to an older changeset, use 'hg
    revert'.

    See 'hg help dates' for a list of formats valid for -d/--date.

options:

 -C --clean  discard uncommitted changes (no backup)
 -c --check  check for uncommitted changes
 -d --date   tipmost revision matching date
 -r --rev    revision

--------------------------------------------------------

URL Paths

    Valid URLs are of the form:

      local/filesystem/path[#revision]
      file://local/filesystem/path[#revision]
      http://[user[:pass]@]host[:port]/[path][#revision]
      https://[user[:pass]@]host[:port]/[path][#revision]
      ssh://[user[:pass]@]host[:port]/[path][#revision]

    Paths in the local filesystem can either point to Mercurial repositories
    or to bundle files (as created by 'hg bundle' or 'hg incoming --bundle').

    An optional identifier after # indicates a particular branch, tag, or
    changeset to use from the remote repository. See also 'hg help revisions'.

    Some features, such as pushing to http:// and https:// URLs are only
    possible if the feature is explicitly enabled on the remote Mercurial
    server.

    Some notes about using SSH with Mercurial:

    - SSH requires an accessible shell account on the destination machine and
      a copy of hg in the remote path or specified with as remotecmd.
    - path is relative to the remote user's home directory by default. Use an
      extra slash at the start of a path to specify an absolute path:

        ssh://example.com//tmp/repository

    - Mercurial doesn't use its own compression via SSH; the right thing to do
      is to configure it in your ~/.ssh/config, e.g.:

        Host *.mylocalnetwork.example.com
          Compression no
        Host *
          Compression yes

      Alternatively specify "ssh -C" as your ssh command in your hgrc or with
      the --ssh command line option.

    These URLs can all be stored in your hgrc with path aliases under the
    [paths] section like so:

      [paths]
      alias1 = URL1
      alias2 = URL2
      ...

    You can then use the alias for any command that uses a URL (for example
    'hg pull alias1' will be treated as 'hg pull URL1').

    Two path aliases are special because they are used as defaults when you do
    not provide the URL to a command:

    default:
      When you create a repository with hg clone, the clone command saves the
      location of the source repository as the new repository's 'default'
      path. This is then used when you omit path from push- and pull-like
      commands (including incoming and outgoing).
    default-push:
      The push command will look for a path named 'default-push', and prefer
      it over 'default' if both are defined.
--------------------------------------------------------

hg verify

verify the integrity of the repository

    Verify the integrity of the current repository.

    This will perform an extensive check of the repository's integrity,
    validating the hashes and checksums of each entry in the changelog,
    manifest, and tracked files, as well as the integrity of their crosslinks
    and indices.

--------------------------------------------------------

hg version

output version and copyright information

--------------------------------------------------------

---------------------------------------------------------------------------
Branching                                            *hg_Branching*

Good discussion:
http://stevelosh.com/blog/2009/08/a-guide-to-branching-in-mercurial/

Branching is a way of doing development off the main line, such as for a
bug fix, then merging it back to main.  
There are a few different ways of "branching":

    * Cloning |hg_Cloning|
    * Bookmarks
    * Named branches in one repository
    * Implicit branching

Cloning:  safest (repositories are completely isolated), discarding is
    easy.  Might not be good if tools rely on a specific path.

Bookmarks:  a lightweight method.  See above link.

Named branches:  List branches with
    hg  branches
To see what branch you're on
    hg branch
To create a new branch (can also rename the current branch)
    hg  branch  new_branch_name

At the next commit, you'll automatically be on this branch.  Note
these branches are global -- they'll be exported to other repositories
on a push/pull.

To switch to a branch:
    hg  update  branch_name
  Use 'default' to go back to the default branch.

A good process would be to make the branch name contain the bug tracking
ID number -- then it's clear what's being done and where to look for more
detail.

To avoid cluttering your repository with branch names, it's a good idea
to close the branch name out when you're finished with it.  This is done
as follows:

    hg ci -m "Message" --close-branch

Once this is closed, it won't show up in branch listings anymore unless
you use 'hg branches -c'; here's example output:

    Another_branch                14:a4ca7f992e33
    default                       13:36337b400ee6 (inactive)
    first_bugfix                  12:9384bc44be8b (closed)

You can e.g. bounce back and forth between the default branch and
Another_branch while fixing problems.

When you're finished with the bug fix (and closed the branch), change back
to the default branch and do a 'hg merge Another_branch'.  Remember to 
commit; then your bug fix is in place and you continue working on default.

Anonymous branching
    You can create an anonymous, un-named branch by using 'hg update'
    to go to an old version, then making a modification and checking
    it it.  This creates a situation where the repository now has two
    head revisions.  This is best seen with a tool like graphlog
    (which I have aliased to 'll').

    These two heads will need to be merged:
        hg merge
    Don't forget to do a commit.

    Disadvantage:  there won't be any branch name around later, so
    you'll have to figure out what happened by the commit messages.

---------------------------------------------------------------------------
Tags                                            *hg_Tags*

Tags are symbols you can put on any revision at any time.  They are
basically a way of relating a human-friendly symbol to a particular
revision.

hg tag   -r version    tag_name

A tag name can't contain a colon, newline, or carriage return.  All
other characters are OK.

To list tags:
    hg tags

Note tags are stored in the file .hgtags -- and you can hand-edit it if
necessary.

Local tags
    You can also define local tags via 'hg tags -r ver -l tag_name'.
    These tags are not shared with other repositories.  They're in
    .hg/localtags.

    A good use of a local tag might be "I saw the flaky behavior with
    this version".  

You can remove tags at any time, either by editing .hgtags or using
hg tags --remove  tagname.

The nice feature of tags is that you can easily update using the tag; for
example:

    hg update v0.1

assuming a tag named v0.1 had been defined.

---------------------------------------------------------------------------
Cloning                                            *hg_Cloning*

    Contrast cloning to branching |hg_Branching|.

Cloning seems to be the most popular way to isolate work.  Since cloned
repositories are constructed with hard links, they're cheap and fast.  It's
not unusual for someone to have 5 to 10 clones around.

Suppose our main project files are in the repository main.  Then we need to
do some work for Feature1, so we clone:

    cd /somewhere/main
    cd ..
    hg clone main main_Feature1


Now main_Feature1 is a cloned repository of main and you can do your
development work there.  Commit as often as needed, use tags, whatever.
When you're finished, you push the changes back to main:

    cd /somewhere/main_Feature1
    hg push
    cd ../main
    hg update tip
    hg merge

The push resulted in two head revisions (use 'hg heads' to see them).
We update to the tip of the default branch, then merge with the other 
head that was pushed.

Note remote repositories are cloned as easily as local ones:

    hg  clone  https://code.google.com/p/abcdefhij

---------------------------------------------------------------------------
Guerrilla SCM                                      *hg_Guerrilla_SCM*

If you have to work on a project that uses some other VCS system O and you
miss Mercurial (or git), here's how to do your work using Mercurial:

    * Initialize a Mercurial repository in your working directory A.
        cd A
        hc init
        hc add .
        hc ci -m "Initial checkin"

    * Clone it to a new location 
        hc clone . B

    * Go to B and do all your work there.  Once in a while you'll need to
      sync with others, so go to A and sync (using the commands of O).
        O_cmd <sync with other VCS>
      Then, while in A, update A's Mercurial stuff:
        hc add .
        hc ci -m "Sync'd with everyone else"

    * Go to B and pull in the changes from the other VCS:
        hc ci -m "About to pull in sync'd with others stuff"
        hc pull

    * When you want to send your changes to others, push them back to A:
        hc push
      Then use O's scheme to update the O server.

---------------------------------------------------------------------------
Mercurial Queues                                *hg_Queues*

Basic idea:  keep a set of patches (unified diffs) on-hand and lets
    you decide how those patches should be applied.  Behavior derived
    from the quilt command.  The key difference is that quilt knows
    nothing about VCS tools, while MQ is integrated in Mercurial.

Common use case:  you download some software package and have to
    make a fix to use it.  Months or years later, you need to upgrade
    to a later version of the package.  This means you have to figure
    out what you did for the first fix, then apply it to the new
    version of the package.  This can be tedious and error-prone.

Patches offer agility:  your patches live on top of a repository's
    revision history and you can make them appear/disappear at will.
    Since every applied patch has a changeset, you can give 'hg log' a
    file name to see which changesets and patches affected the file.
    Use 'hg bisect' to find which patch to see where a bug got
    introduced.  Use 'hg annotate' to see which changeset/patch
    modified a particular source file line.

Enable MQ:  in .hgrc under [extensions], insert 'hgext.mp ='.  It
    worked if 'hg help' now shows the qinit is available.


qinit       Initialize a new queue repository.  -c for nested repository.
            Creates .hg/patches.

qnew name   Work on a new patch named name.  Recommended:  add .patch
            to name.

qrefresh    Update the patch you're working on (checkpoints your work).
            Refresh; try an experiment; if the experiment doesn't
            work, use 'hg revert'.

qseries     List every patch from oldest to newest.

qapplied    List every patch applied.

qpop        Undo effects of a patch.

qpush       Reapply an unapplied patch.

qdelete     Delete a patch file and remove it from patch series.

qfinish     Turn a patch into a permanent Mercurial changeset.

qbase       Tag identifying bottom-most patch.

qtip        Tag identifying top-most patch.

qguard      Patch guarding (see ch 13 [mr])

Working on two patches:  suppose you have a core feature and new
feature to work on.  First create the patch to the core feature and
get it working.  qrefresh it.  Then create a new patch for the new
feature.  If you notice a bug in the core stuff while working on the
new feature, qrefresh the feature to save current work, then qpop back
to the core patch.  Fix the core bug, qrefresh, then qpush back to the
new feature work.

When underlying code changes:  pattern is a set of patches on top of a
codebase you don't modify.  Then the codebase changes.
Recommendation:  'hg qpop -a' to remove the effects of all your
patches, 'hg pull' the codebase changes, then 'hg qpush -a' all
patches.  MQ will stop pushing if there's a patch that fails to apply
properly.  Fix conflict, qrefresh, and continue pushing until the
entire patch stack has been applied.  This works well if codebase and
your patches don't interact much.  See [mr] Ch 12 about 70% down the
page for "The process is a little involved".

The patch names behave as tags.  Example:

    hg log -r foo.patch:qtip subdir

shows all of the patches since foo.patch that have touched files in
the subdirectory subdir.

'hg log' also shows patch names as tags.
